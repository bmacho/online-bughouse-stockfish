(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.PychessVariants = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.aboutView = void 0;
const h_1 = __importDefault(require("snabbdom/h"));
const i18n_1 = require("./i18n");
const main_1 = require("./main");
function aboutView() {
    const untitled = [
        (0, i18n_1._)("\"To me, how we've got here today is owing to Stockfish in a BIG way. They rallied global volunteers to come together in the open-source spirit and create such a powerful engine for FREE. That's a lot of great minds and computing power they've managed to harness."),
        (0, i18n_1._)("Then we've got Lichess to thank. Lichess was also born out of the same open-source spirit, and it too drew in great people as well. Once Lichess incorporated Stockfish as its brains, the rest is history."),
        (0, i18n_1._)("Lichess enables the online, real-time, and competitive aspects of game-play. They also bring the enormous power of Stockfish to the masses, who can now benefit from it without configuring a local GUI. I believe this development turns out to be of great consequence and significance."),
        (0, i18n_1._)("Later on, developers close to the Lichess project eventually extended Stockfish into Multivariant-Stockfish, in order to support Crazyhouse et al. The father of Fairy-Stockfish, Fabian, is also one of those devs (still) working on that fork, and he later took several steps further in terms of variant support and extensibility. Thus Fairy-Stockfish was born, so powerful because it builds on the Stockfish project."),
        (0, i18n_1._)("Then comes our beloved pychess-variants, which again very smartly harnesses the underlying superpowers of the big projects. Same online, real-time, and competitive aspects. Same clean and familiar Lichess look and feel. Plus the power of Stockfish!\""),
    ];
    return [
        (0, h_1.default)('div.about', [
            (0, h_1.default)('img.center', { attrs: { src: `${main_1.model["asset-url"]}/favicon/favicon-96x96.png` } }),
            (0, h_1.default)('h1', { attrs: { align: 'center' } }, (0, i18n_1._)('About pychess')),
            (0, h_1.default)('p', (0, i18n_1._)('Pychess is a free, open-source chess server designed to play several chess variants.')),
            (0, h_1.default)('p', [
                // TODO Automate the generation of this list
                (0, i18n_1._)("Currently supported games are "),
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/makruk' } }, 'Makruk'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/makpong' } }, 'Makpong'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/cambodian' } }, 'Ouk Chatrang'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/sittuyin' } }, 'Sittuyin'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/shogi' } }, 'Shogi'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/minishogi' } }, 'Minishogi'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/kyotoshogi' } }, 'Kyoto shogi'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/dobutsu' } }, 'Dobutsu shogi'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/gorogoro' } }, 'Gorogoro shogi'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/xiangqi' } }, 'Xiangqi'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/manchu' } }, 'Manchu'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/janggi' } }, 'Janggi'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/minixiangqi' } }, 'Minixiangqi'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/placement' } }, 'Placement'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/crazyhouse' } }, 'Crazyhouse'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/atomic' } }, 'Atomic'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/seirawan' } }, 'S-chess'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/capablanca' } }, 'Capablanca'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/gothic' } }, 'Gothic'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/grand' } }, 'Grand'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/shako' } }, 'Shako'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/shogun' } }, 'Shogun'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/orda' } }, 'Orda'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/synochess' } }, 'Synochess'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/hoppelpoppel' } }, 'Hoppel-Poppel'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/shinobi' } }, 'Shinobi'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/empire' } }, 'Empire'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/ordamirror' } }, 'Orda Mirror'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/shouse' } }, 'S-house (S-chess+Crazyhouse)'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/capahouse' } }, 'Capahouse (Capablanca+Crazyhouse)'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/grandhouse' } }, 'Grandhouse (Grand+Crazyhouse)'),
                ", and ",
                (0, h_1.default)('a', { attrs: { href: 'https://www.pychess.org/variants/chess' } }, 'Chess.'),
            ]),
            (0, h_1.default)('p', [
                (0, i18n_1._)('Additionally, you can check the Chess960 option for Chess, Crazyhouse, Atomic, S-chess, Capablanca, and Capahouse to start games from random positions with '),
                (0, h_1.default)('a', { attrs: { href: 'https://en.wikipedia.org/wiki/Chess960#Castling_rules' } }, (0, i18n_1._)('Chess960 castling rules.'))
            ]),
            (0, h_1.default)('p', [
                (0, i18n_1._)('For move generation, validation, analysis, and engine play, we use '),
                (0, h_1.default)('a', { attrs: { href: 'https://github.com/gbtami/Fairy-Stockfish' } }, 'Fairy-Stockfish'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://github.com/gbtami/fairyfishnet' } }, 'fairyfishnet'),
                ", and ",
                (0, h_1.default)('a', { attrs: { href: 'https://github.com/gbtami/lichess-bot-variants' } }, 'lichess-bot-variants.'),
            ]),
            (0, h_1.default)('p', [
                (0, i18n_1._)('On client side, the user interface of the game board is based on '),
                (0, h_1.default)('a', { attrs: { href: 'https://github.com/gbtami/chessgroundx' } }, 'chessgroundx.'),
            ]),
            (0, h_1.default)('p', [
                (0, i18n_1._)('The source code of the server is available on '),
                (0, h_1.default)('a', { attrs: { href: 'https://github.com/gbtami/pychess-variants' } }, 'GitHub.'),
            ]),
            (0, h_1.default)('hr'),
            (0, h_1.default)('p', [
                (0, i18n_1._)('Regarding Privacy and Terms of Service, the rules of lichess.org are also applied here. '),
                (0, h_1.default)('a', { attrs: { href: 'https://lichess.org/privacy' } }, 'Privacy'),
                ", ",
                (0, h_1.default)('a', { attrs: { href: 'https://lichess.org/terms-of-service' } }, 'ToS'),
            ]),
            (0, h_1.default)('hr'),
            (0, h_1.default)('p', untitled.map(paragraph => (0, h_1.default)('p', paragraph))),
            (0, h_1.default)('p', 'Untitled_Entity'),
        ]),
    ];
}
exports.aboutView = aboutView;

},{"./i18n":18,"./main":31,"snabbdom/h":85}],2:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.analysisView = exports.embedView = void 0;
const snabbdom_1 = require("snabbdom");
const i18n_1 = require("./i18n");
const analysisCtrl_1 = __importDefault(require("./analysisCtrl"));
const chess_1 = require("./chess");
const datetime_1 = require("./datetime");
const profile_1 = require("./profile");
const view_1 = require("./view");
function runGround(vnode, model) {
    const el = vnode.elm;
    const ctrl = new analysisCtrl_1.default(el, model);
    window['onFSFline'] = ctrl.onFSFline;
    window['ctrl'] = ctrl;
}
function leftSide(model) {
    const variant = chess_1.VARIANTS[model.variant];
    const chess960 = model.chess960 === 'True';
    const dataIcon = variant.icon(chess960);
    const fc = variant.firstColor;
    const sc = variant.secondColor;
    if (model["gameId"] !== "") {
        const tc = (model["base"] == "0" && model["inc"] == "0") ? "" : (0, view_1.timeControlStr)(model["base"], model["inc"], model["byo"]) + " • ";
        return [
            (0, snabbdom_1.h)('div.game-info', [
                (0, snabbdom_1.h)('div.info0.icon', { attrs: { "data-icon": dataIcon } }, [
                    (0, snabbdom_1.h)('div.info2', [
                        (0, snabbdom_1.h)('div.tc', [
                            tc + (0, profile_1.gameType)(model["rated"]) + " • ",
                            (0, snabbdom_1.h)('a.user-link', {
                                attrs: {
                                    target: '_blank',
                                    href: '/variants/' + model["variant"] + (chess960 ? '960' : ''),
                                }
                            }, variant.displayName(chess960)),
                        ]),
                        Number(model["status"]) >= 0 ? (0, snabbdom_1.h)('info-date', { attrs: { timestamp: model["date"] } }, (0, datetime_1.timeago)(model["date"])) : (0, i18n_1._)("Playing right now"),
                    ]),
                ]),
                (0, snabbdom_1.h)('div.player-data', [
                    (0, snabbdom_1.h)('i-side.icon', {
                        class: {
                            "icon-white": fc === "White",
                            "icon-black": fc === "Black",
                            "icon-red": fc === "Red",
                            "icon-blue": fc === "Blue",
                            "icon-gold": fc === "Gold",
                            "icon-pink": fc === "Pink",
                        }
                    }),
                    (0, snabbdom_1.h)('player', playerInfo(model.wplayer, model.wtitle, model.level, model.wrating, model.wrdiff)),
                ]),
                (0, snabbdom_1.h)('div.player-data', [
                    (0, snabbdom_1.h)('i-side.icon', {
                        class: {
                            "icon-white": sc === "White",
                            "icon-black": sc === "Black",
                            "icon-red": sc === "Red",
                            "icon-blue": sc === "Blue",
                            "icon-gold": sc === "Gold",
                            "icon-pink": sc === "Pink",
                        }
                    }),
                    (0, snabbdom_1.h)('player', playerInfo(model.bplayer, model.btitle, model.level, model.brating, model.brdiff)),
                ]),
            ]),
            (0, snabbdom_1.h)('div#roundchat'),
        ];
    }
    else {
        const setVariant = (isInput) => {
            let e;
            e = document.getElementById('variant');
            const variant = e.options[e.selectedIndex].value;
            if (isInput)
                window.location.assign('/analysis/' + variant);
        };
        const vVariant = model.variant || "chess";
        return (0, snabbdom_1.h)('div.container', [
            (0, snabbdom_1.h)('div', [
                (0, snabbdom_1.h)('label', { attrs: { for: "variant" } }, (0, i18n_1._)("Variant")),
                (0, chess_1.selectVariant)("variant", vVariant, () => setVariant(true), () => setVariant(false)),
            ]),
        ]);
    }
}
function embedView(model) {
    const variant = chess_1.VARIANTS[model.variant];
    const chess960 = model.chess960 === 'True';
    return [
        (0, snabbdom_1.h)('div.embed-app', [
            (0, snabbdom_1.h)('selection#mainboard.' + variant.board + '.' + variant.piece, [
                (0, snabbdom_1.h)('div.cg-wrap.' + variant.cg, { hook: { insert: (vnode) => runGround(vnode, model) } }),
            ]),
            (0, snabbdom_1.h)('div.pocket-top', [
                (0, snabbdom_1.h)('div.' + variant.piece + '.' + model["variant"], [
                    (0, snabbdom_1.h)('div.cg-wrap.pocket', [
                        (0, snabbdom_1.h)('div#pocket0'),
                    ]),
                ]),
            ]),
            (0, snabbdom_1.h)('div.analysis-tools', [
                (0, snabbdom_1.h)('div.movelist-block', [
                    (0, snabbdom_1.h)('div#movelist'),
                ]),
                (0, snabbdom_1.h)('div#misc-info', [
                    (0, snabbdom_1.h)('div#misc-infow'),
                    (0, snabbdom_1.h)('div#misc-info-center'),
                    (0, snabbdom_1.h)('div#misc-infob'),
                ]),
            ]),
            (0, snabbdom_1.h)('div#move-controls'),
            (0, snabbdom_1.h)('div.pocket-bot', [
                (0, snabbdom_1.h)('div.' + variant.piece + '.' + model["variant"], [
                    (0, snabbdom_1.h)('div.cg-wrap.pocket', [
                        (0, snabbdom_1.h)('div#pocket1'),
                    ]),
                ]),
            ]),
        ]),
        (0, snabbdom_1.h)('div.footer', [
            (0, snabbdom_1.h)('a.gamelink', { attrs: { rel: "noopener", target: "_blank", href: '/' + model["gameId"] } }, [variant.displayName(chess960), '•', model.wtitle, model.wplayer, 'vs', model.btitle, model.bplayer].join(' ')),
        ]),
    ];
}
exports.embedView = embedView;
function analysisView(model) {
    const variant = chess_1.VARIANTS[model.variant];
    (0, datetime_1.renderTimeago)();
    return [
        (0, snabbdom_1.h)('div.analysis-app', [
            (0, snabbdom_1.h)('aside.sidebar-first', leftSide(model)),
            (0, snabbdom_1.h)('selection#mainboard.' + variant.board + '.' + variant.piece, [
                (0, snabbdom_1.h)('div.cg-wrap.' + variant.cg, { hook: { insert: (vnode) => runGround(vnode, model) } }),
            ]),
            (0, snabbdom_1.h)('div#gauge', [
                (0, snabbdom_1.h)('div.black', { props: { style: "height: 50%;" } }),
                (0, snabbdom_1.h)('div.tick', { props: { style: "height: 12.5%;" } }),
                (0, snabbdom_1.h)('div.tick', { props: { style: "height: 25%;" } }),
                (0, snabbdom_1.h)('div.tick', { props: { style: "height: 37.5%;" } }),
                (0, snabbdom_1.h)('div.tick.zero', { props: { style: "height: 50%;" } }),
                (0, snabbdom_1.h)('div.tick', { props: { style: "height: 62.5%;" } }),
                (0, snabbdom_1.h)('div.tick', { props: { style: "height: 75%;" } }),
                (0, snabbdom_1.h)('div.tick', { props: { style: "height: 87.5%;" } }),
            ]),
            (0, snabbdom_1.h)('div.pocket-top', [
                (0, snabbdom_1.h)('div.' + variant.piece + '.' + model["variant"], [
                    (0, snabbdom_1.h)('div.cg-wrap.pocket', [
                        (0, snabbdom_1.h)('div#pocket0'),
                    ]),
                ]),
            ]),
            (0, snabbdom_1.h)('div.analysis-tools', [
                (0, snabbdom_1.h)('div#ceval', [
                    (0, snabbdom_1.h)('div.engine', [
                        (0, snabbdom_1.h)('score#score', ''),
                        (0, snabbdom_1.h)('div.info', ['Fairy-Stockfish 11+', (0, snabbdom_1.h)('br'), (0, snabbdom_1.h)('info#info', (0, i18n_1._)('in local browser'))]),
                        (0, snabbdom_1.h)('label.switch', [
                            (0, snabbdom_1.h)('input#input', {
                                props: {
                                    name: "engine",
                                    type: "checkbox",
                                },
                            }),
                            (0, snabbdom_1.h)('span#slider.sw-slider'),
                        ]),
                    ]),
                ]),
                (0, snabbdom_1.h)('div#pv'),
                (0, snabbdom_1.h)('div.movelist-block', [
                    (0, snabbdom_1.h)('div#movelist'),
                ]),
                (0, snabbdom_1.h)('div#vari'),
                (0, snabbdom_1.h)('div#misc-info', [
                    (0, snabbdom_1.h)('div#misc-infow'),
                    (0, snabbdom_1.h)('div#misc-info-center'),
                    (0, snabbdom_1.h)('div#misc-infob'),
                ]),
            ]),
            (0, snabbdom_1.h)('div#move-controls'),
            (0, snabbdom_1.h)('div.pocket-bot', [
                (0, snabbdom_1.h)('div.' + variant.piece + '.' + model["variant"], [
                    (0, snabbdom_1.h)('div.cg-wrap.pocket', [
                        (0, snabbdom_1.h)('div#pocket1'),
                    ]),
                ]),
            ]),
            (0, snabbdom_1.h)('under-left#spectators'),
            (0, snabbdom_1.h)('under-board', [
                (0, snabbdom_1.h)('div#pgn', [
                    (0, snabbdom_1.h)('div#ctable-container'),
                    (0, snabbdom_1.h)('div.chart-container', [
                        (0, snabbdom_1.h)('div#chart'),
                        (0, snabbdom_1.h)('div#loader-wrapper', [(0, snabbdom_1.h)('div#loader')])
                    ]),
                    (0, snabbdom_1.h)('div#fentext', [
                        (0, snabbdom_1.h)('strong', 'FEN'),
                        (0, snabbdom_1.h)('input#fullfen', { attrs: { readonly: true, spellcheck: false } })
                    ]),
                    (0, snabbdom_1.h)('div#copyfen'),
                    (0, snabbdom_1.h)('div', [(0, snabbdom_1.h)('textarea#pgntext')]),
                ]),
            ]),
        ]),
    ];
}
exports.analysisView = analysisView;
function playerInfo(username, title, level, rating, rdiff) {
    return (0, snabbdom_1.h)('a.user-link', { attrs: { href: '/@/' + username } }, [
        (0, snabbdom_1.h)('player-title', " " + title + " "),
        username + (0, profile_1.aiLevel)(title, level) + (title !== 'BOT' ? (" (" + rating + ") ") : ''),
        rdiff === null ? (0, snabbdom_1.h)('rdiff') : (0, profile_1.renderRdiff)(rdiff),
    ]);
}

},{"./analysisCtrl":3,"./chess":8,"./datetime":12,"./i18n":18,"./profile":39,"./view":49,"snabbdom":93}],3:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
//import Module from 'ffish-es6';
//TODO: importing from node-modules causes error while running gulp:
//'import' and 'export' may appear only with 'sourceType: module'
const ffish_js_1 = __importDefault(require("../static/ffish.js"));
const sockette_1 = __importDefault(require("sockette"));
const snabbdom_1 = require("snabbdom");
const h_1 = require("snabbdom/h");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const chessgroundx_1 = require("chessgroundx");
const util_1 = require("chessgroundx/util");
const i18n_1 = require("./i18n");
const gating_1 = require("./gating");
const promotion_1 = require("./promotion");
const pocket_1 = require("./pocket");
const sound_1 = require("./sound");
const chess_1 = require("./chess");
const crosstable_1 = require("./crosstable");
const chat_1 = require("./chat");
const movelist_1 = require("./movelist");
const winningChances_1 = require("./winningChances");
const clipboard_1 = require("./clipboard");
const chart_1 = require("./chart");
const png_1 = require("./png");
const info_1 = require("./info");
const boardSettings_1 = require("./boardSettings");
const document_1 = require("./document");
const variantsIni_1 = require("./variantsIni");
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
const EVAL_REGEX = new RegExp(''
    + /^info depth (\d+) seldepth \d+ multipv (\d+) /.source
    + /score (cp|mate) ([-\d]+) /.source
    + /(?:(upper|lower)bound )?nodes (\d+) nps \S+ /.source
    + /(?:hashfull \d+ )?(?:tbhits \d+ )?time (\S+) /.source
    + /pv (.+)/.source);
const maxDepth = 18;
const maxThreads = Math.max((navigator.hardwareConcurrency || 1) - 1, 1);
function download(filename, text) {
    const element = document.createElement('a');
    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}
class AnalysisController {
    constructor(el, model) {
        this.getGround = () => this.chessground;
        this.pass = () => {
            let passKey = 'a0';
            const pieces = this.chessground.state.pieces;
            const dests = this.chessground.state.movable.dests;
            for (const key in pieces) {
                if (pieces[key].role === 'k-piece' && pieces[key].color === this.turnColor) {
                    if ((key in dests) && (dests[key].indexOf(key) >= 0))
                        passKey = key;
                }
            }
            if (passKey !== 'a0') {
                // prevent calling pass() again by selectSquare() -> onSelect()
                this.chessground.state.movable.dests = undefined;
                this.chessground.selectSquare(passKey);
                sound_1.sound.moveSound(this.variant, false);
                this.sendMove(passKey, passKey, '');
            }
        };
        this.renderInput = () => {
            return {
                attrs: {
                    disabled: !this.localEngine,
                },
                on: { change: () => {
                        this.localAnalysis = !this.localAnalysis;
                        if (this.localAnalysis) {
                            this.vinfo = patch(this.vinfo, (0, h_1.h)('info#info', '-'));
                            this.engineStop();
                            this.engineGo();
                        }
                        else {
                            this.vinfo = patch(this.vinfo, (0, h_1.h)('info#info', (0, i18n_1._)('in local browser')));
                            this.vpv = patch(this.vpv, (0, h_1.h)('div#pv'));
                            this.engineStop();
                        }
                    } }
            };
        };
        this.drawAnalysisChart = (withRequest) => {
            if (withRequest) {
                if (this.model["anon"] === 'True') {
                    alert((0, i18n_1._)('You need an account to do that.'));
                    return;
                }
                const element = document.getElementById('request-analysis');
                if (element !== null)
                    element.style.display = 'none';
                this.doSend({ type: "analysis", username: this.model["username"], gameId: this.gameId });
                const loaderEl = document.getElementById('loader');
                loaderEl.style.display = 'block';
            }
            const chartEl = document.getElementById('chart');
            chartEl.style.display = 'block';
            (0, chart_1.analysisChart)(this);
        };
        this.checkStatus = (msg) => {
            if ((msg.gameId !== this.gameId && !this.isAnalysisBoard) || this.model["embed"])
                return;
            if ((msg.status >= 0) || this.isAnalysisBoard) {
                // Save finished game full pgn sent by server
                if (msg.pgn !== undefined)
                    this.pgn = msg.pgn;
                // but on analysis page we always present pgn move list leading to current shown position!
                const pgn = (this.isAnalysisBoard) ? this.getPgn() : this.pgn;
                this.uci_usi = msg.uci_usi;
                let container = document.getElementById('copyfen');
                if (container !== null) {
                    const buttons = [
                        (0, h_1.h)('a.i-pgn', { on: { click: () => download("pychess-variants_" + this.gameId, pgn) } }, [
                            (0, h_1.h)('i', { props: { title: (0, i18n_1._)('Download game to PGN file') }, class: { "icon": true, "icon-download": true } }, (0, i18n_1._)(' Download PGN'))
                        ]),
                        (0, h_1.h)('a.i-pgn', { on: { click: () => (0, clipboard_1.copyTextToClipboard)(this.uci_usi) } }, [
                            (0, h_1.h)('i', { props: { title: (0, i18n_1._)('Copy USI/UCI to clipboard') }, class: { "icon": true, "icon-clipboard": true } }, (0, i18n_1._)(' Copy UCI/USI'))
                        ]),
                        (0, h_1.h)('a.i-pgn', { on: { click: () => (0, png_1.copyBoardToPNG)(this.fullfen) } }, [
                            (0, h_1.h)('i', { props: { title: (0, i18n_1._)('Download position to PNG image file') }, class: { "icon": true, "icon-download": true } }, (0, i18n_1._)(' PNG image'))
                        ]),
                    ];
                    if (this.steps[0].analysis === undefined && !this.isAnalysisBoard) {
                        buttons.push((0, h_1.h)('button#request-analysis', { on: { click: () => this.drawAnalysisChart(true) } }, [
                            (0, h_1.h)('i', { props: { title: (0, i18n_1._)('Request Computer Analysis') }, class: { "icon": true, "icon-bar-chart": true } }, (0, i18n_1._)(' Request Analysis'))
                        ]));
                    }
                    patch(container, (0, h_1.h)('div', buttons));
                }
                const e = document.getElementById('fullfen');
                e.value = this.fullfen;
                container = document.getElementById('pgntext');
                this.vpgn = patch(container, (0, h_1.h)('textarea#pgntext', { attrs: { rows: 13, readonly: true, spellcheck: false } }, pgn));
                if (!this.isAnalysisBoard)
                    (0, movelist_1.selectMove)(this, this.ply);
            }
        };
        this.onMsgBoard = (msg) => {
            if (msg.gameId !== this.gameId)
                return;
            const pocketsChanged = this.hasPockets && ((0, chess_1.getPockets)(this.fullfen) !== (0, chess_1.getPockets)(msg.fen));
            // console.log("got board msg:", msg);
            this.ply = msg.ply;
            this.fullfen = msg.fen;
            this.dests = msg.dests;
            // list of legal promotion moves
            this.promotions = msg.promo;
            const parts = msg.fen.split(" ");
            this.turnColor = parts[1] === "w" ? "white" : "black";
            this.result = msg.result;
            this.status = msg.status;
            if (msg.steps.length > 1) {
                this.steps = [];
                msg.steps.forEach((step, ply) => {
                    if (step.analysis !== undefined) {
                        step['ceval'] = step.analysis;
                        const scoreStr = this.buildScoreStr(ply % 2 === 0 ? "w" : "b", step.analysis);
                        step['scoreStr'] = scoreStr;
                    }
                    this.steps.push(step);
                });
                (0, movelist_1.updateMovelist)(this);
                if (this.steps[0].analysis !== undefined) {
                    this.vinfo = patch(this.vinfo, (0, h_1.h)('info#info', '-'));
                    this.drawAnalysisChart(false);
                }
            }
            else {
                if (msg.ply === this.steps.length) {
                    const step = {
                        'fen': msg.fen,
                        'move': msg.lastMove,
                        'check': msg.check,
                        'turnColor': this.turnColor,
                        'san': msg.steps[0].san,
                    };
                    this.steps.push(step);
                    (0, movelist_1.updateMovelist)(this);
                }
            }
            let lastMove = msg.lastMove;
            if (lastMove !== null) {
                lastMove = (0, chess_1.uci2cg)(lastMove);
                // drop lastMove causing scrollbar flicker,
                // so we remove from part to avoid that
                lastMove = lastMove.indexOf('@') > -1 ? [lastMove.slice(-2)] : [lastMove.slice(0, 2), lastMove.slice(2, 4)];
            }
            const step = this.steps[this.steps.length - 1];
            let capture = false;
            if (step.san !== undefined) {
                capture = step.san.slice(1, 2) === 'x';
            }
            if (lastMove !== null && (this.turnColor === this.mycolor || this.spectator)) {
                sound_1.sound.moveSound(this.variant, capture);
            }
            else {
                lastMove = [];
            }
            this.checkStatus(msg);
            if (this.spectator) {
                this.chessground.set({
                    fen: parts[0],
                    turnColor: this.turnColor,
                    check: msg.check,
                    lastMove: lastMove,
                });
                if (pocketsChanged)
                    (0, pocket_1.updatePockets)(this, this.vpocket0, this.vpocket1);
            }
            if (this.model["ply"]) {
                this.ply = parseInt(this.model["ply"]);
                (0, movelist_1.selectMove)(this, this.ply);
            }
        };
        this.moveIndex = (ply) => {
            return Math.floor((ply - 1) / 2) + 1 + (ply % 2 === 1 ? '.' : '...');
        };
        this.notation2ffishjs = (n) => {
            switch (n) {
                case 0 /* DEFAULT */: return this.ffish.Notation.DEFAULT;
                case 1 /* SAN */: return this.ffish.Notation.SAN;
                case 2 /* LAN */: return this.ffish.Notation.LAN;
                case 3 /* SHOGI_HOSKING */: return this.ffish.Notation.SHOGI_HOSKING;
                case 4 /* SHOGI_HODGES */: return this.ffish.Notation.SHOGI_HODGES;
                case 5 /* SHOGI_HODGES_NUMBER */: return this.ffish.Notation.SHOGI_HODGES_NUMBER;
                case 6 /* JANGGI */: return this.ffish.Notation.JANGGI;
                case 7 /* XIANGQI_WXF */: return this.ffish.Notation.XIANGQI_WXF;
                default: return this.ffish.Notation.DEFAULT;
            }
        };
        this.onFSFline = (line) => {
            //console.log(line);
            if (line.includes('readyok'))
                this.isEngineReady = true;
            if (!this.localEngine) {
                if (line.includes('UCI_Variant')) {
                    new ffish_js_1.default().then(loadedModule => {
                        this.ffish = loadedModule;
                        if (this.ffish !== null) {
                            this.ffish.loadVariantConfig(variantsIni_1.variantsIni);
                            this.notationAsObject = this.notation2ffishjs(this.notation);
                            const availableVariants = this.ffish.variants();
                            //console.log('Available variants:', availableVariants);
                            if (this.model.variant === 'chess' || availableVariants.includes(this.model.variant)) {
                                this.ffishBoard = new this.ffish.Board("bughouse", this.fullfen, this.chess960);
                                this.dests = this.getDests();
                                this.chessground.set({ movable: { color: this.turnColor, dests: this.dests } });
                            }
                            else {
                                console.log("Selected variant is not supported by ffish.js");
                            }
                        }
                    });
                    // TODO: enable S-chess960 when stockfish.wasm catches upstream Fairy-Stockfish
                    if ((this.model.variant === 'chess' || line.includes(this.model.variant)) &&
                        !(this.model.variant === 'seirawan' && this.chess960)) {
                        this.localEngine = true;
                        patch(document.getElementById('input'), (0, h_1.h)('input#input', { attrs: { disabled: false } }));
                    }
                    else {
                        const v = this.model.variant + ((this.chess960) ? '960' : '');
                        const title = (0, i18n_1._)("Selected variant %1 is not supported by stockfish.wasm", v);
                        patch(document.getElementById('slider'), (0, h_1.h)('span.sw-slider', { attrs: { title: title } }));
                    }
                }
            }
            if (!this.localAnalysis || !this.isEngineReady)
                return;
            const matches = line.match(EVAL_REGEX);
            if (!matches) {
                if (line.includes('mate 0')) {
                    const msg = { type: 'local-analysis', ply: this.ply, color: this.turnColor.slice(0, 1), ceval: { d: 0, s: { mate: 0 } } };
                    this.onMsgAnalysis(msg);
                }
                return;
            }
            const depth = parseInt(matches[1]), multiPv = parseInt(matches[2]), isMate = matches[3] === 'mate', povEv = parseInt(matches[4]), evalType = matches[5], nodes = parseInt(matches[6]), elapsedMs = parseInt(matches[7]), moves = matches[8];
            //console.log("---", depth, multiPv, isMate, povEv, evalType, nodes, elapsedMs, moves);
            // Sometimes we get #0. Let's just skip it.
            if (isMate && !povEv)
                return;
            // For now, ignore most upperbound/lowerbound messages.
            // The exception is for multiPV, sometimes non-primary PVs
            // only have an upperbound.
            // See: https://github.com/ddugovic/Stockfish/issues/228
            if (evalType && multiPv === 1)
                return;
            let score;
            if (isMate) {
                score = { mate: povEv };
            }
            else {
                score = { cp: povEv };
            }
            const knps = nodes / elapsedMs;
            const sanMoves = this.ffishBoard.variationSan(moves, this.notationAsObject);
            const msg = { type: 'local-analysis', ply: this.ply, color: this.turnColor.slice(0, 1), ceval: { d: depth, m: moves, p: sanMoves, s: score, k: knps } };
            this.onMsgAnalysis(msg);
        };
        this.onMoreDepth = () => {
            this.maxDepth = 99;
            this.engineStop();
            this.engineGo();
        };
        // Updates PV, score, gauge and the best move arrow
        this.drawEval = (ceval, scoreStr, turnColor) => {
            let shapes0 = [];
            this.chessground.setAutoShapes(shapes0);
            const gaugeEl = document.getElementById('gauge');
            if (gaugeEl) {
                const blackEl = gaugeEl.querySelector('div.black');
                if (blackEl && ceval !== undefined) {
                    const score = ceval['s'];
                    // TODO set gauge colour according to the variant's piece colour
                    const color = (this.variant.firstColor === "Black") ? turnColor === 'black' ? 'white' : 'black' : turnColor;
                    if (score !== undefined) {
                        const ev = (0, winningChances_1.povChances)(color, score);
                        blackEl.style.height = String(100 - (ev + 1) * 50) + '%';
                    }
                    else {
                        blackEl.style.height = '50%';
                    }
                }
            }
            if ((ceval === null || ceval === void 0 ? void 0 : ceval.p) !== undefined) {
                const pv_move = (0, chess_1.uci2cg)(ceval["m"].split(" ")[0]);
                console.log("ARROW", this.arrow);
                if (this.arrow) {
                    const atPos = pv_move.indexOf('@');
                    if (atPos > -1) {
                        const d = pv_move.slice(atPos + 1, atPos + 3);
                        let color = turnColor;
                        const dropPieceRole = (0, chess_1.san2role)(pv_move.slice(0, atPos));
                        const orientation = this.flip ? this.oppcolor : this.mycolor;
                        const side = color === orientation ? "ally" : "enemy";
                        const url = (0, document_1.getPieceImageUrl)(dropPieceRole, color, side);
                        this.chessground.set({ drawable: { pieces: { baseUrl: url } } });
                        shapes0 = [{
                                orig: d,
                                brush: 'paleGreen',
                                piece: {
                                    color: color,
                                    role: dropPieceRole
                                }
                            },
                            { orig: d, brush: 'paleGreen' }
                        ];
                    }
                    else {
                        const o = pv_move.slice(0, 2);
                        const d = pv_move.slice(2, 4);
                        shapes0 = [{ orig: o, dest: d, brush: 'paleGreen', piece: undefined },];
                    }
                }
                this.vscore = patch(this.vscore, (0, h_1.h)('score#score', scoreStr));
                const info = [(0, h_1.h)('span', (0, i18n_1._)('Depth') + ' ' + String(ceval.d) + '/' + this.maxDepth)];
                if (ceval.k) {
                    if (ceval.d === this.maxDepth && this.maxDepth !== 99) {
                        info.push((0, h_1.h)('a.icon.icon-plus-square', {
                            props: { type: "button", title: (0, i18n_1._)("Go deeper") },
                            on: { click: () => this.onMoreDepth() }
                        }));
                    }
                    else if (ceval.d !== 99) {
                        info.push((0, h_1.h)('span', ', ' + Math.round(ceval.k) + ' knodes/s'));
                    }
                }
                this.vinfo = patch(this.vinfo, (0, h_1.h)('info#info', info));
                let pvSan = ceval.p;
                if (this.ffishBoard !== null) {
                    try {
                        pvSan = this.ffishBoard.variationSan(ceval.p, this.notationAsObject);
                        if (pvSan === '')
                            pvSan = ceval.p;
                    }
                    catch (error) {
                        pvSan = ceval.p;
                    }
                }
                this.vpv = patch(this.vpv, (0, h_1.h)('div#pv', [(0, h_1.h)('pvline', ceval.p !== undefined ? pvSan : ceval.m)]));
            }
            else {
                this.vscore = patch(this.vscore, (0, h_1.h)('score#score', ''));
                this.vinfo = patch(this.vinfo, (0, h_1.h)('info#info', (0, i18n_1._)('in local browser')));
                this.vpv = patch(this.vpv, (0, h_1.h)('div#pv'));
            }
            console.log(shapes0);
            this.chessground.set({
                drawable: { autoShapes: shapes0 },
            });
        };
        // Updates chart and score in movelist
        this.drawServerEval = (ply, scoreStr) => {
            if (ply > 0) {
                const evalEl = document.getElementById('ply' + String(ply));
                patch(evalEl, (0, h_1.h)('eval#ply' + String(ply), scoreStr));
            }
            (0, chart_1.analysisChart)(this);
            const hc = this.analysisChart;
            if (hc !== undefined) {
                const hcPt = hc.series[0].data[ply];
                if (hcPt !== undefined)
                    hcPt.select();
            }
        };
        this.engineStop = () => {
            this.isEngineReady = false;
            window.fsf.postMessage('stop');
            window.fsf.postMessage('isready');
        };
        this.engineGo = () => {
            if (this.chess960) {
                window.fsf.postMessage('setoption name UCI_Chess960 value true');
            }
            if (this.model.variant !== 'chess') {
                window.fsf.postMessage('setoption name UCI_Variant value ' + 'bughouse');
            }
            //console.log('setoption name Threads value ' + maxThreads);
            window.fsf.postMessage('setoption name Threads value ' + maxThreads);
            //console.log('position fen ', this.fullfen);
            window.fsf.postMessage('position fen ' + this.fullfen);
            if (this.maxDepth >= 99) {
                window.fsf.postMessage('go depth 99');
            }
            else {
                window.fsf.postMessage('go movetime 90000 depth ' + this.maxDepth);
            }
        };
        this.getDests = () => {
            const legalMoves = this.ffishBoard.legalMoves().split(" ");
            // console.log(legalMoves);
            const dests = {};
            this.promotions = [];
            legalMoves.forEach((move) => {
                move = (0, chess_1.uci2cg)(move);
                const source = move.slice(0, 2);
                const dest = move.slice(2, 4);
                if (source in dests) {
                    dests[source].push(dest);
                }
                else {
                    dests[source] = [dest];
                }
                const tail = move.slice(-1);
                if (tail > '9' || tail === '+' || tail === '-') {
                    if (!(this.variant.gate && (move.slice(1, 2) === '1' || move.slice(1, 2) === '8'))) {
                        this.promotions.push(move);
                    }
                }
                if (this.variant.promotion === 'kyoto' && move.slice(0, 1) === '+') {
                    this.promotions.push(move);
                }
            });
            this.chessground.set({ movable: { dests: dests } });
            return dests;
        };
        // When we are moving inside a variation move list
        // then plyVari > 0 and ply is the index inside vari movelist
        this.goPly = (ply, plyVari = 0) => {
            if (this.localAnalysis) {
                this.engineStop();
                // Go back to the main line
                if (plyVari === 0) {
                    const container = document.getElementById('vari');
                    patch(container, (0, h_1.h)('div#vari', ''));
                }
            }
            const step = (plyVari > 0) ? this.steps[plyVari]['vari'][ply] : this.steps[ply];
            let move = step.move;
            let capture = false;
            if (move !== undefined) {
                move = (0, chess_1.uci2cg)(move);
                move = move.indexOf('@') > -1 ? [move.slice(-2)] : [move.slice(0, 2), move.slice(2, 4)];
                // 960 king takes rook castling is not capture
                capture = (this.chessground.state.pieces[move[move.length - 1]] !== undefined && step.san.slice(0, 2) !== 'O-') || (step.san.slice(1, 2) === 'x');
            }
            this.chessground.set({
                fen: step.fen,
                turnColor: step.turnColor,
                movable: {
                    color: step.turnColor,
                    dests: this.dests,
                },
                check: step.check,
                lastMove: move,
            });
            this.fullfen = step.fen;
            (0, pocket_1.updatePockets)(this, this.vpocket0, this.vpocket1);
            if (this.variant.counting) {
                (0, info_1.updateCount)(step.fen, document.getElementById('misc-infow'), document.getElementById('misc-infob'));
            }
            if (this.variant.materialPoint) {
                (0, info_1.updatePoint)(step.fen, document.getElementById('misc-infow'), document.getElementById('misc-infob'));
            }
            if (ply === this.ply + 1) {
                sound_1.sound.moveSound(this.variant, capture);
            }
            // Go back to the main line
            if (plyVari === 0) {
                this.ply = ply;
            }
            this.turnColor = step.turnColor;
            if (this.plyVari > 0 && plyVari === 0) {
                this.steps[this.plyVari]['vari'] = undefined;
                this.plyVari = 0;
                (0, movelist_1.updateMovelist)(this);
            }
            if (this.model["embed"])
                return;
            if (this.ffishBoard !== null) {
                this.ffishBoard.setFen(this.fullfen);
                this.dests = this.getDests();
            }
            this.drawEval(step.ceval, step.scoreStr, step.turnColor);
            this.drawServerEval(ply, step.scoreStr);
            // TODO: multi PV
            this.maxDepth = maxDepth;
            if (this.localAnalysis)
                this.engineGo();
            const e = document.getElementById('fullfen');
            e.value = this.fullfen;
            if (this.isAnalysisBoard) {
                const idxInVari = (plyVari > 0) ? ply : 0;
                this.vpgn = patch(this.vpgn, (0, h_1.h)('textarea#pgntext', { attrs: { rows: 13, readonly: true, spellcheck: false } }, this.getPgn(idxInVari)));
            }
            else {
                const hist = this.model["home"] + '/' + this.gameId + '?ply=' + ply.toString();
                window.history.replaceState({}, this.model['title'], hist);
            }
        };
        this.doSend = (message) => {
            // console.log("---> doSend():", message);
            this.sock.send(JSON.stringify(message));
        };
        this.onMove = () => {
            return (orig, dest, capturedPiece) => {
                console.log("   ground.onMove()", orig, dest, capturedPiece);
                sound_1.sound.moveSound(this.variant, capturedPiece);
            };
        };
        this.onDrop = () => {
            return (piece, dest) => {
                // console.log("ground.onDrop()", piece, dest);
                if (dest != 'a0' && piece.role && (0, chess_1.dropIsValid)(this.dests, piece.role, dest)) {
                    sound_1.sound.moveSound(this.variant, false);
                }
            };
        };
        this.getPgn = (idxInVari = 0) => {
            const moves = [];
            for (let ply = 1; ply <= this.ply; ply++) {
                const moveCounter = (ply % 2 !== 0) ? (ply + 1) / 2 + '.' : '';
                if (this.steps[ply]['vari'] !== undefined && this.plyVari > 0) {
                    const variMoves = this.steps[ply]['vari'];
                    for (let idx = 0; idx <= idxInVari; idx++) {
                        moves.push(moveCounter + variMoves[idx]['sanSAN']);
                    }
                    break;
                }
                moves.push(moveCounter + this.steps[ply]['sanSAN']);
            }
            return moves.join(' ');
        };
        this.sendMove = (orig, dest, promo) => {
            const move = (0, chess_1.cg2uci)(orig + dest + promo);
            const san = this.ffishBoard.sanMove(move, this.notationAsObject);
            const sanSAN = this.ffishBoard.sanMove(move);
            // console.log('sendMove()', move, san);
            // Instead of sending moves to the server we can get new FEN and dests from ffishjs
            this.ffishBoard.push(move);
            this.dests = this.getDests();
            // We can't use ffishBoard.gamePly() to determine newply because it returns +1 more
            // when new this.ffish.Board() initial FEN moving color was "b"
            const moves = this.ffishBoard.moveStack().split(' ');
            const newPly = moves.length;
            const msg = {
                gameId: this.gameId,
                fen: this.ffishBoard.fen(),
                ply: newPly,
                lastMove: move,
                dests: this.dests,
                promo: this.promotions,
                bikjang: this.ffishBoard.isBikjang(),
                check: this.ffishBoard.isCheck(),
            };
            this.onMsgAnalysisBoard(msg);
            const step = {
                'fen': msg.fen,
                'move': msg.lastMove,
                'check': msg.check,
                'turnColor': this.turnColor,
                'san': san,
                'sanSAN': sanSAN,
            };
            // New main line move
            if (this.ffishBoard.gamePly() === this.steps.length && this.plyVari === 0) {
                this.steps.push(step);
                this.ply = this.ffishBoard.gamePly();
                (0, movelist_1.updateMovelist)(this);
                this.checkStatus(msg);
                // variation move
            }
            else {
                // new variation starts
                if (newPly === 1) {
                    if (msg.lastMove === this.steps[this.ply].move) {
                        // existing main line played
                        (0, movelist_1.selectMove)(this, this.ply);
                        return;
                    }
                    if (this.steps[this.plyVari]['vari'] === undefined || msg.ply === this.steps[this.plyVari]['vari'].length) {
                        // continuing the variation
                        this.plyVari = this.ffishBoard.gamePly();
                        this.steps[this.plyVari]['vari'] = [];
                    }
                    else {
                        // variation in the variation: drop old moves
                        this.steps[this.plyVari]['vari'] = this.steps[this.plyVari]['vari'].slice(0, this.ffishBoard.gamePly() - this.plyVari);
                    }
                }
                this.steps[this.plyVari]['vari'].push(step);
                const full = true;
                const activate = false;
                (0, movelist_1.updateMovelist)(this, full, activate);
                (0, movelist_1.activatePlyVari)(this.plyVari + this.steps[this.plyVari]['vari'].length - 1);
            }
            const e = document.getElementById('fullfen');
            e.value = this.fullfen;
            if (this.isAnalysisBoard) {
                const idxInVari = (this.plyVari > 0) ? this.steps[this.plyVari]['vari'].length - 1 : 0;
                this.vpgn = patch(this.vpgn, (0, h_1.h)('textarea#pgntext', { attrs: { rows: 13, readonly: true, spellcheck: false } }, this.getPgn(idxInVari)));
            }
            // TODO: But sending moves to the server will be useful to implement shared live analysis!
            // this.doSend({ type: "analysis_move", gameId: this.gameId, move: move, fen: this.fullfen, ply: this.ply + 1 });
        };
        this.onMsgAnalysisBoard = (msg) => {
            // console.log("got analysis_board msg:", msg);
            if (msg.gameId !== this.gameId)
                return;
            if (this.localAnalysis)
                this.engineStop();
            const pocketsChanged = this.hasPockets && ((0, chess_1.getPockets)(this.fullfen) !== (0, chess_1.getPockets)(msg.fen));
            this.fullfen = msg.fen;
            this.dests = msg.dests;
            // list of legal promotion moves
            this.promotions = msg.promo;
            this.ply = msg.ply;
            const parts = msg.fen.split(" ");
            this.turnColor = parts[1] === "w" ? "white" : "black";
            let lastMove = msg.lastMove;
            if (lastMove !== null) {
                lastMove = (0, chess_1.uci2cg)(lastMove);
                // drop lastMove causing scrollbar flicker,
                // so we remove from part to avoid that
                lastMove = lastMove.indexOf('@') > -1 ? [lastMove.slice(-2)] : [lastMove.slice(0, 2), lastMove.slice(2, 4)];
            }
            this.chessground.set({
                fen: this.fullfen,
                turnColor: this.turnColor,
                lastMove: lastMove,
                check: msg.check,
                movable: {
                    color: this.turnColor,
                    dests: this.dests,
                },
            });
            if (pocketsChanged)
                (0, pocket_1.updatePockets)(this, this.vpocket0, this.vpocket1);
            if (this.localAnalysis)
                this.engineGo();
        };
        this.onUserMove = (orig, dest, meta) => {
            this.preaction = meta.premove === true;
            // chessground doesn't knows about ep, so we have to remove ep captured pawn
            const pieces = this.chessground.state.pieces;
            // console.log("ground.onUserMove()", orig, dest, meta);
            let moved = pieces[dest];
            // Fix king to rook 960 castling case
            if (moved === undefined)
                moved = { role: 'k-piece', color: this.mycolor };
            if (meta.captured === undefined && moved !== undefined && moved.role === "p-piece" && orig[0] != dest[0] && this.variant.enPassant) {
                const pos = (0, util_1.key2pos)(dest), pawnPos = [pos[0], pos[1] + (this.mycolor === 'white' ? -1 : 1)];
                const diff = {};
                diff[(0, util_1.pos2key)(pawnPos)] = undefined;
                this.chessground.setPieces(diff);
                meta.captured = { role: "p-piece" };
            }
            // increase pocket count
            //~ if (this.variant.drop && meta.captured) {
            //~ let role = meta.captured.role
            //~ if (meta.captured.promoted)
            //~ role = (this.variant.promotion === 'shogi' || this.variant.promotion === 'kyoto') ? meta.captured.role.slice(1) as Role : "p-piece";
            //~ let position = (this.turnColor === this.mycolor) ? "bottom": "top";
            //~ if (this.flip) position = (position === "top") ? "bottom" : "top";
            //~ if (position === "top") {
            //~ this.pockets[0][role]++;
            //~ this.vpocket0 = patch(this.vpocket0, pocketView(this, this.turnColor, "top"));
            //~ } else {
            //~ this.pockets[1][role]++;
            //~ this.vpocket1 = patch(this.vpocket1, pocketView(this, this.turnColor, "bottom"));
            //~ }
            //~ }
            //  gating elephant/hawk
            if (this.variant.gate) {
                if (!this.promotion.start(moved.role, orig, dest) && !this.gating.start(this.fullfen, orig, dest))
                    this.sendMove(orig, dest, '');
            }
            else {
                if (!this.promotion.start(moved.role, orig, dest))
                    this.sendMove(orig, dest, '');
                this.preaction = false;
            }
        };
        this.onUserDrop = (role, dest, meta) => {
            this.preaction = meta.predrop === true;
            // console.log("ground.onUserDrop()", role, dest, meta);
            // decrease pocket count
            if ((0, chess_1.dropIsValid)(this.dests, role, dest)) {
                let position = (this.turnColor === this.mycolor) ? "bottom" : "top";
                if (this.flip)
                    position = (position === "top") ? "bottom" : "top";
                if (position === "top") {
                    this.pockets[0][role]--;
                    this.vpocket0 = patch(this.vpocket0, (0, pocket_1.pocketView)(this, this.turnColor, "top"));
                }
                else {
                    this.pockets[1][role]--;
                    this.vpocket1 = patch(this.vpocket1, (0, pocket_1.pocketView)(this, this.turnColor, "bottom"));
                }
                if (this.variant.promotion === 'kyoto') {
                    if (!this.promotion.start(role, 'a0', dest))
                        this.sendMove((0, chess_1.role2san)(role) + "@", dest, '');
                }
                else {
                    this.sendMove((0, chess_1.role2san)(role) + "@", dest, '');
                }
                // console.log("sent move", move);
            }
            else {
                // console.log("!!! invalid move !!!", role, dest);
                // restore board
                this.chessground.set({
                    fen: this.fullfen,
                    lastMove: this.lastmove,
                    turnColor: this.mycolor,
                    animation: { enabled: this.animation },
                    movable: {
                        dests: this.dests,
                        showDests: this.showDests,
                    },
                });
            }
            this.preaction = false;
        };
        this.onSelect = () => {
            return (key) => {
                if (this.chessground.state.movable.dests === undefined)
                    return;
                // Save state.pieces to help recognise 960 castling (king takes rook) moves
                // Shouldn't this be implemented in chessground instead?
                if (this.chess960 && this.variant.gate) {
                    this.prevPieces = Object.assign({}, this.chessground.state.pieces);
                }
                // Janggi pass and Sittuyin in place promotion on Ctrl+click
                if (this.chessground.state.stats.ctrlKey &&
                    (key in this.chessground.state.movable.dests) &&
                    (this.chessground.state.movable.dests[key].indexOf(key) >= 0)) {
                    const piece = this.chessground.state.pieces[key];
                    if (this.variant.name === 'sittuyin') { // TODO make this more generic
                        // console.log("Ctrl in place promotion", key);
                        const pieces = {};
                        pieces[key] = {
                            color: piece.color,
                            role: 'f-piece',
                            promoted: true
                        };
                        this.chessground.setPieces(pieces);
                        this.sendMove(key, key, 'f');
                    }
                    else if (this.variant.pass && piece.role === 'k-piece') {
                        this.pass();
                    }
                }
            };
        };
        this.buildScoreStr = (color, analysis) => {
            const score = analysis['s'];
            let scoreStr = '';
            let ceval = '';
            if (score['mate'] !== undefined) {
                ceval = score['mate'];
                const sign = ((color === 'b' && Number(ceval) > 0) || (color === 'w' && Number(ceval) < 0)) ? '-' : '';
                scoreStr = '#' + sign + Math.abs(Number(ceval));
            }
            else {
                ceval = score['cp'];
                let nscore = Number(ceval) / 100.0;
                if (color === 'b')
                    nscore = -nscore;
                scoreStr = nscore.toFixed(1);
            }
            return scoreStr;
        };
        this.onMsgAnalysis = (msg) => {
            // console.log(msg);
            if (msg['ceval']['s'] === undefined)
                return;
            const scoreStr = this.buildScoreStr(msg.color, msg.ceval);
            // Server side analysis message
            if (msg.type === 'analysis') {
                this.steps[msg.ply]['ceval'] = msg.ceval;
                this.steps[msg.ply]['scoreStr'] = scoreStr;
                if (this.steps.every((step) => { return step.scoreStr !== undefined; })) {
                    const element = document.getElementById('loader-wrapper');
                    element.style.display = 'none';
                }
                this.drawServerEval(msg.ply, scoreStr);
            }
            else {
                const turnColor = msg.color === 'w' ? 'white' : 'black';
                this.drawEval(msg.ceval, scoreStr, turnColor);
            }
        };
        // User running a fishnet worker asked new server side analysis with chat message: !analysis
        this.onMsgRequestAnalysis = () => {
            this.steps.forEach((step) => {
                step.analysis = undefined;
                step.ceval = undefined;
                step.score = undefined;
            });
            this.drawAnalysisChart(true);
        };
        this.onMsgUserConnected = (msg) => {
            this.model["username"] = msg["username"];
            // we want to know lastMove and check status
            this.doSend({ type: "board", gameId: this.gameId });
        };
        this.onMsgSpectators = (msg) => {
            const container = document.getElementById('spectators');
            patch(container, (0, h_1.h)('under-left#spectators', (0, i18n_1._)('Spectators: ') + msg.spectators));
        };
        this.onMsgChat = (msg) => {
            if ((this.spectator && msg.room === 'spectator') || (!this.spectator && msg.room !== 'spectator') || msg.user.length === 0) {
                (0, chat_1.chatMessage)(msg.user, msg.message, "roundchat");
            }
        };
        this.onMsgFullChat = (msg) => {
            // To prevent multiplication of messages we have to remove old messages div first
            patch(document.getElementById('messages'), (0, h_1.h)('div#messages-clear'));
            // then create a new one
            patch(document.getElementById('messages-clear'), (0, h_1.h)('div#messages'));
            msg.lines.forEach((line) => {
                if ((this.spectator && line.room === 'spectator') || (!this.spectator && line.room !== 'spectator') || line.user.length === 0) {
                    (0, chat_1.chatMessage)(line.user, line.message, "roundchat");
                }
            });
        };
        this.onMsgGameNotFound = (msg) => {
            alert((0, i18n_1._)("Requested game %1 not found!", msg['gameId']));
            window.location.assign(this.model["home"]);
        };
        this.onMsgShutdown = (msg) => {
            alert(msg.message);
        };
        this.onMsgCtable = (ct, gameId) => {
            if (ct !== "") {
                this.ctableContainer = patch(this.ctableContainer, (0, h_1.h)('div#ctable-container'));
                this.ctableContainer = patch(this.ctableContainer, (0, crosstable_1.crosstableView)(ct, gameId));
            }
        };
        this.onMessage = (evt) => {
            // console.log("<+++ onMessage():", evt.data);
            const msg = JSON.parse(evt.data);
            switch (msg.type) {
                case "board":
                    this.onMsgBoard(msg);
                    break;
                case "analysis_board":
                    this.onMsgAnalysisBoard(msg);
                    break;
                case "crosstable":
                    this.onMsgCtable(msg.ct, this.gameId);
                    break;
                case "analysis":
                    this.onMsgAnalysis(msg);
                    break;
                case "embed_user_connected":
                case "game_user_connected":
                    this.onMsgUserConnected(msg);
                    break;
                case "spectators":
                    this.onMsgSpectators(msg);
                    break;
                case "roundchat":
                    this.onMsgChat(msg);
                    break;
                case "fullchat":
                    this.onMsgFullChat(msg);
                    break;
                case "game_not_found":
                    this.onMsgGameNotFound(msg);
                    break;
                case "shutdown":
                    this.onMsgShutdown(msg);
                    break;
                case "logout":
                    this.doSend({ type: "logout" });
                    break;
                case "request_analysis":
                    this.onMsgRequestAnalysis();
                    break;
            }
        };
        this.onCancelDropMode = () => {
            return () => { (0, pocket_1.refreshPockets)(this); };
        };
        this.isAnalysisBoard = model["gameId"] === "";
        const onOpen = (evt) => {
            console.log("ctrl.onOpen()", evt);
            if (this.model['embed']) {
                this.doSend({ type: "embed_user_connected", gameId: this.model["gameId"] });
            }
            else if (!this.isAnalysisBoard) {
                this.doSend({ type: "game_user_connected", username: this.model["username"], gameId: this.model["gameId"] });
            }
        };
        const opts = {
            maxAttempts: 10,
            onopen: e => onOpen(e),
            onmessage: e => this.onMessage(e),
            onreconnect: e => console.log('Reconnecting in round...', e),
            onmaximum: e => console.log('Stop Attempting!', e),
            onclose: e => console.log('Closed!', e),
            onerror: e => console.log('Error:', e),
        };
        const ws = (location.host.indexOf('pychess') === -1) ? 'wss://' : 'wss://';
        this.sock = new sockette_1.default(ws + location.host + "/wsr", opts);
        // is local stockfish.wasm engine supports current variant?
        this.localEngine = false;
        // is local engine analysis enabled? (the switch)
        this.localAnalysis = false;
        // UCI isready/readyok
        this.isEngineReady = false;
        // loaded Fairy-Stockfish ffish.js wasm module
        this.ffish = null;
        this.ffishBoard = null;
        this.maxDepth = maxDepth;
        // current interactive analysis variation ply
        this.plyVari = 0;
        this.model = model;
        this.gameId = model["gameId"];
        this.variant = chess_1.VARIANTS[model["variant"]];
        this.chess960 = model["chess960"] === 'True';
        this.fullfen = model["fen"];
        this.wplayer = model["wplayer"];
        this.bplayer = model["bplayer"];
        this.base = model["base"];
        this.inc = model["inc"];
        this.status = model["status"];
        this.steps = [];
        this.pgn = "";
        this.ply = 0;
        this.flip = false;
        this.settings = true;
        this.animation = localStorage.animation === undefined ? true : localStorage.animation === "true";
        this.showDests = localStorage.showDests === undefined ? true : localStorage.showDests === "true";
        this.arrow = localStorage.arrow === undefined ? true : localStorage.arrow === "true";
        this.spectator = this.model["username"] !== this.wplayer && this.model["username"] !== this.bplayer;
        this.hasPockets = this.variant.pocket;
        if (this.variant.name === 'janggi') { // TODO make this more generic / customisable
            this.notation = 6 /* JANGGI */;
        }
        else {
            if (this.variant.name.endsWith("shogi") || this.variant.name === 'dobutsu' || this.variant.name === 'gorogoro') {
                this.notation = 5 /* SHOGI_HODGES_NUMBER */;
            }
            else {
                this.notation = 1 /* SAN */;
            }
        }
        // orientation = this.mycolor
        if (this.spectator) {
            this.mycolor = 'white';
            this.oppcolor = 'black';
        }
        else {
            this.mycolor = this.model["username"] === this.wplayer ? 'white' : 'black';
            this.oppcolor = this.model["username"] === this.wplayer ? 'black' : 'white';
        }
        // players[0] is top player, players[1] is bottom player
        this.players = [
            this.mycolor === "white" ? this.bplayer : this.wplayer,
            this.mycolor === "white" ? this.wplayer : this.bplayer
        ];
        this.titles = [
            this.mycolor === "white" ? this.model['btitle'] : this.model['wtitle'],
            this.mycolor === "white" ? this.model['wtitle'] : this.model['btitle']
        ];
        this.ratings = [
            this.mycolor === "white" ? this.model['brating'] : this.model['wrating'],
            this.mycolor === "white" ? this.model['wrating'] : this.model['brating']
        ];
        this.result = "*";
        const parts = this.fullfen.split(" ");
        const fen_placement = parts[0];
        this.turnColor = parts[1] === "w" ? "white" : "black";
        this.steps.push({
            'fen': this.fullfen,
            'move': undefined,
            'check': false,
            'turnColor': this.turnColor,
        });
        this.chessground = (0, chessgroundx_1.Chessground)(el, {
            fen: fen_placement,
            variant: this.variant.name,
            chess960: this.chess960,
            geometry: this.variant.geometry,
            notation: this.notation,
            orientation: this.mycolor,
            turnColor: this.turnColor,
            animation: { enabled: this.animation },
        });
        this.chessground.set({
            animation: { enabled: this.animation },
            movable: {
                free: false,
                color: this.mycolor,
                showDests: this.showDests,
                events: {
                    after: this.onUserMove,
                    afterNewPiece: this.onUserDrop,
                }
            },
            events: {
                move: this.onMove(),
                dropNewPiece: this.onDrop(),
                select: this.onSelect(),
            },
            dropmode: {
                events: {
                    cancel: this.onCancelDropMode()
                }
            }
        });
        this.gating = new gating_1.Gating(this);
        this.promotion = new promotion_1.Promotion(this);
        // initialize pockets
        if (this.hasPockets) {
            const pocket0 = document.getElementById('pocket0');
            const pocket1 = document.getElementById('pocket1');
            (0, pocket_1.updatePockets)(this, pocket0, pocket1);
        }
        if (!this.isAnalysisBoard && !this.model["embed"]) {
            this.ctableContainer = document.getElementById('ctable-container');
        }
        // Hide #chart div (embed view has no #chart)
        if (!this.model["embed"]) {
            const element = document.getElementById('chart');
            element.style.display = 'none';
        }
        (0, movelist_1.createMovelistButtons)(this);
        this.vmovelist = document.getElementById('movelist');
        if (!this.isAnalysisBoard && !this.model["embed"]) {
            patch(document.getElementById('roundchat'), (0, chat_1.chatView)(this, "roundchat"));
            document.documentElement.style.setProperty('--toolsHeight', '136px');
        }
        else {
            this.checkStatus({ fen: this.fullfen });
            document.documentElement.style.setProperty('--toolsHeight', '92px');
        }
        if (!this.model["embed"]) {
            patch(document.getElementById('input'), (0, h_1.h)('input#input', this.renderInput()));
            this.vscore = document.getElementById('score');
            this.vinfo = document.getElementById('info');
            this.vpv = document.getElementById('pv');
        }
        if (this.variant.materialPoint) {
            const miscW = document.getElementById('misc-infow');
            const miscB = document.getElementById('misc-infob');
            miscW.style.textAlign = 'right';
            miscB.style.textAlign = 'left';
            miscW.style.width = '100px';
            miscB.style.width = '100px';
            patch(document.getElementById('misc-info-center'), (0, h_1.h)('div#misc-info-center', '-'));
            document.getElementById('misc-info').style.justifyContent = 'space-around';
        }
        if (this.variant.counting) {
            document.getElementById('misc-infow').style.textAlign = 'center';
            document.getElementById('misc-infob').style.textAlign = 'center';
        }
        boardSettings_1.boardSettings.ctrl = this;
        const boardFamily = this.variant.board;
        const pieceFamily = this.variant.piece;
        boardSettings_1.boardSettings.updateBoardStyle(boardFamily);
        boardSettings_1.boardSettings.updatePieceStyle(pieceFamily);
        boardSettings_1.boardSettings.updateZoom(boardFamily);
    }
}
exports.default = AnalysisController;

},{"../static/ffish.js":98,"./boardSettings":5,"./chart":6,"./chat":7,"./chess":8,"./clipboard":9,"./crosstable":11,"./document":13,"./gating":17,"./i18n":18,"./info":19,"./movelist":32,"./png":37,"./pocket":38,"./promotion":40,"./sound":45,"./variantsIni":48,"./winningChances":50,"chessgroundx":55,"chessgroundx/util":69,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"sockette":97}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.backgroundSettings = void 0;
const h_1 = require("snabbdom/h");
const i18n_1 = require("./i18n");
const settings_1 = require("./settings");
const view_1 = require("./view");
function backgrounds() {
    return {
        light: (0, i18n_1._)("Light"),
        dark: (0, i18n_1._)("Dark"),
    };
}
class BackgroundSettings extends settings_1.StringSettings {
    constructor() {
        super('theme', 'light');
    }
    update() {
        document.documentElement.setAttribute('data-theme', this.value);
    }
    view() {
        return (0, h_1.h)('div#settings-background', (0, view_1.radioList)(this, 'background', backgrounds(), (_, key) => this.value = key));
    }
}
exports.backgroundSettings = new BackgroundSettings();

},{"./i18n":18,"./settings":43,"./view":49,"snabbdom/h":85}],5:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.boardSettings = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default, style_1.default]);
const h_1 = __importDefault(require("snabbdom/h"));
const i18n_1 = require("./i18n");
const chess_1 = require("./chess");
const document_1 = require("./document");
const analysisCtrl_1 = __importDefault(require("./analysisCtrl"));
const roundCtrl_1 = __importDefault(require("./roundCtrl"));
const chart_1 = require("./chart");
const info_1 = require("./info");
const pocket_1 = require("./pocket");
const player_1 = require("./player");
const settings_1 = require("./settings");
const view_1 = require("./view");
const main_1 = require("./main");
class BoardSettings {
    constructor() {
        this.settings = {};
        this.settings["animation"] = new AnimationSettings(this);
        this.settings["showDests"] = new ShowDestsSettings(this);
        this.settings["autoQueen"] = new AutoQueenSettings(this);
        this.settings["arrow"] = new ArrowSettings(this);
        this.settings["blindfold"] = new BlindfoldSettings(this);
    }
    getSettings(settingsType, family) {
        const fullName = family + settingsType;
        if (!this.settings[fullName]) {
            switch (settingsType) {
                case "BoardStyle":
                    this.settings[fullName] = new BoardStyleSettings(this, family);
                    break;
                case "PieceStyle":
                    this.settings[fullName] = new PieceStyleSettings(this, family);
                    break;
                case "Zoom":
                    this.settings[fullName] = new ZoomSettings(this, family);
                    break;
                default:
                    throw "Unknown settings type " + settingsType;
            }
        }
        return this.settings[fullName];
    }
    updateBoardAndPieceStyles() {
        Object.keys(chess_1.BOARD_FAMILIES).forEach(family => this.updateBoardStyle(family));
        Object.keys(chess_1.PIECE_FAMILIES).forEach(family => this.updatePieceStyle(family));
    }
    updateBoardStyle(family) {
        const idx = this.getSettings("BoardStyle", family).value;
        const board = chess_1.BOARD_FAMILIES[family].boardCSS[idx];
        (0, document_1.changeBoardCSS)(main_1.model["asset-url"], family, board);
    }
    updatePieceStyle(family) {
        const idx = this.getSettings("PieceStyle", family).value;
        let css = chess_1.PIECE_FAMILIES[family].pieceCSS[idx];
        (0, document_1.changePieceCSS)(main_1.model["asset-url"], family, css);
        this.updateDropSuggestion();
    }
    updateDropSuggestion() {
        // Redraw the piece being suggested for dropping in the new piece style
        if (this.ctrl && this.ctrl.hasPockets) {
            const chessground = this.ctrl.chessground;
            const el = document.querySelector('svg image');
            // if there is any
            if (el) {
                const classNames = el.getAttribute('className').split(' ');
                const role = classNames[0];
                const color = classNames[1];
                const orientation = this.ctrl.flip ? this.ctrl.oppcolor : this.ctrl.mycolor;
                const side = color === orientation ? "ally" : "enemy";
                chessground.set({ drawable: { pieces: { baseUrl: (0, document_1.getPieceImageUrl)(role, color, side) } } });
                chessground.redrawAll();
            }
        }
    }
    updateZoom(family) {
        var _a;
        const variant = (_a = this.ctrl) === null || _a === void 0 ? void 0 : _a.variant;
        if (variant && variant.board === family) {
            const zoomSettings = this.getSettings("Zoom", family);
            const zoom = zoomSettings.value;
            const el = document.querySelector('.cg-wrap:not(.pocket)');
            if (el) {
                document.body.setAttribute('style', '--zoom:' + zoom);
                document.body.dispatchEvent(new Event('chessground.resize'));
                const baseWidth = el.getBoundingClientRect()['width'];
                const baseHeight = el.getBoundingClientRect()['height'];
                const pxw = `${baseWidth}px`;
                const pxh = `${baseHeight}px`;
                document.body.setAttribute('style', '--cgwrapwidth:' + pxw + '; --cgwrapheight:' + pxh + '; --zoom:' + zoom);
                if (this.ctrl instanceof analysisCtrl_1.default && !this.ctrl.model["embed"]) {
                    (0, chart_1.analysisChart)(this.ctrl);
                }
            }
        }
    }
    updateBlindfold() {
        this.settings["blindfold"].update();
    }
    view(variantName) {
        var _a;
        if (!variantName)
            return (0, h_1.default)("div#board-settings");
        const variant = chess_1.VARIANTS[variantName];
        const settingsList = [];
        const boardFamily = chess_1.VARIANTS[variantName].board;
        const pieceFamily = chess_1.VARIANTS[variantName].piece;
        settingsList.push(this.settings["animation"].view());
        settingsList.push(this.settings["showDests"].view());
        if (variant.autoQueenable)
            settingsList.push(this.settings["autoQueen"].view());
        settingsList.push(this.settings["arrow"].view());
        settingsList.push(this.settings["blindfold"].view());
        if (variantName === ((_a = this.ctrl) === null || _a === void 0 ? void 0 : _a.variant.name))
            settingsList.push(this.getSettings("Zoom", boardFamily).view());
        settingsList.push((0, h_1.default)('div#style-settings', [
            this.getSettings("BoardStyle", boardFamily).view(),
            this.getSettings("PieceStyle", pieceFamily).view(),
        ]));
        settingsList.push();
        return (0, h_1.default)('div#board-settings', settingsList);
    }
    // TODO This should be in the theoretical "ChessgroundController" class,
    // which is the common class between EditorController, RoundController, and AnalysisController
    toggleOrientation() {
        if (this.ctrl) {
            this.ctrl.flip = !this.ctrl.flip;
            this.ctrl.chessground.toggleOrientation();
            this.updateDropSuggestion();
            // console.log("FLIP");
            if (this.ctrl.hasPockets) {
                const tmp_pocket = this.ctrl.pockets[0];
                this.ctrl.pockets[0] = this.ctrl.pockets[1];
                this.ctrl.pockets[1] = tmp_pocket;
                this.ctrl.vpocket0 = patch(this.ctrl.vpocket0, (0, pocket_1.pocketView)(this.ctrl, this.ctrl.flip ? this.ctrl.mycolor : this.ctrl.oppcolor, "top"));
                this.ctrl.vpocket1 = patch(this.ctrl.vpocket1, (0, pocket_1.pocketView)(this.ctrl, this.ctrl.flip ? this.ctrl.oppcolor : this.ctrl.mycolor, "bottom"));
            }
            // TODO: moretime button
            if (this.ctrl instanceof roundCtrl_1.default) {
                const new_running_clck = (this.ctrl.clocks[0].running) ? this.ctrl.clocks[1] : this.ctrl.clocks[0];
                this.ctrl.clocks[0].pause(false);
                this.ctrl.clocks[1].pause(false);
                const tmp_clock = this.ctrl.clocks[0];
                const tmp_clock_time = tmp_clock.duration;
                this.ctrl.clocks[0].setTime(this.ctrl.clocks[1].duration);
                this.ctrl.clocks[1].setTime(tmp_clock_time);
                if (this.ctrl.status < 0)
                    new_running_clck.start();
                this.ctrl.vplayer0 = patch(this.ctrl.vplayer0, (0, player_1.player)('player0', this.ctrl.titles[this.ctrl.flip ? 1 : 0], this.ctrl.players[this.ctrl.flip ? 1 : 0], this.ctrl.ratings[this.ctrl.flip ? 1 : 0], this.ctrl.model["level"]));
                this.ctrl.vplayer1 = patch(this.ctrl.vplayer1, (0, player_1.player)('player1', this.ctrl.titles[this.ctrl.flip ? 0 : 1], this.ctrl.players[this.ctrl.flip ? 0 : 1], this.ctrl.ratings[this.ctrl.flip ? 0 : 1], this.ctrl.model["level"]));
                if (this.ctrl.variant.counting)
                    [this.ctrl.vmiscInfoW, this.ctrl.vmiscInfoB] = (0, info_1.updateCount)(this.ctrl.fullfen, this.ctrl.vmiscInfoB, this.ctrl.vmiscInfoW);
                if (this.ctrl.variant.materialPoint)
                    [this.ctrl.vmiscInfoW, this.ctrl.vmiscInfoB] = (0, info_1.updatePoint)(this.ctrl.fullfen, this.ctrl.vmiscInfoB, this.ctrl.vmiscInfoW);
            }
        }
    }
}
class AnimationSettings extends settings_1.BooleanSettings {
    constructor(boardSettings) {
        super('animation', true);
        this.boardSettings = boardSettings;
    }
    update() {
        var _a;
        (_a = this.boardSettings.ctrl) === null || _a === void 0 ? void 0 : _a.chessground.set({ animation: { enabled: this.value } });
    }
    view() {
        return (0, h_1.default)('div', (0, view_1.checkbox)(this, 'animation', (0, i18n_1._)("Piece animation")));
    }
}
class BoardStyleSettings extends settings_1.NumberSettings {
    constructor(boardSettings, boardFamily) {
        super(boardFamily + '-board', 0);
        this.boardSettings = boardSettings;
        this.boardFamily = boardFamily;
    }
    update() {
        this.boardSettings.updateBoardStyle(this.boardFamily);
    }
    view() {
        const vboard = this.value;
        const boards = [];
        const boardCSS = chess_1.BOARD_FAMILIES[this.boardFamily].boardCSS;
        for (let i = 0; i < boardCSS.length; i++) {
            boards.push((0, h_1.default)('input#board' + i, {
                on: { change: evt => this.value = Number(evt.target.value) },
                props: { type: "radio", name: "board", value: i },
                attrs: { checked: vboard === i },
            }));
            boards.push((0, h_1.default)('label.board.board' + i + '.' + this.boardFamily, { attrs: { for: "board" + i } }, ""));
        }
        return (0, h_1.default)('settings-board', boards);
    }
}
class PieceStyleSettings extends settings_1.NumberSettings {
    constructor(boardSettings, pieceFamily) {
        super(pieceFamily + '-piece', 0);
        this.boardSettings = boardSettings;
        this.pieceFamily = pieceFamily;
    }
    update() {
        this.boardSettings.updatePieceStyle(this.pieceFamily);
    }
    view() {
        const vpiece = this.value;
        const pieces = [];
        const pieceCSS = chess_1.PIECE_FAMILIES[this.pieceFamily].pieceCSS;
        for (let i = 0; i < pieceCSS.length; i++) {
            pieces.push((0, h_1.default)('input#piece' + i, {
                on: { change: e => this.value = Number(e.target.value) },
                props: { type: "radio", name: "piece", value: i },
                attrs: { checked: vpiece === i },
            }));
            pieces.push((0, h_1.default)('label.piece.piece' + i + '.' + this.pieceFamily, { attrs: { for: "piece" + i } }, ""));
        }
        return (0, h_1.default)('settings-pieces', pieces);
    }
}
class ZoomSettings extends settings_1.NumberSettings {
    constructor(boardSettings, boardFamily) {
        super(boardFamily + '-zoom', 80);
        this.boardSettings = boardSettings;
        this.boardFamily = boardFamily;
    }
    update() {
        this.boardSettings.updateZoom(this.boardFamily);
    }
    view() {
        return (0, view_1.slider)(this, 'zoom', 0, 100, this.boardFamily.includes("shogi") ? 1 : 1.15625);
    }
}
class ShowDestsSettings extends settings_1.BooleanSettings {
    constructor(boardSettings) {
        super('showDests', true);
        this.boardSettings = boardSettings;
    }
    update() {
        var _a;
        (_a = this.boardSettings.ctrl) === null || _a === void 0 ? void 0 : _a.chessground.set({ movable: { showDests: this.value }, dropmode: { showDropDests: this.value }, predroppable: { showDropDests: this.value } });
    }
    view() {
        return (0, h_1.default)('div', (0, view_1.checkbox)(this, 'showDests', (0, i18n_1._)("Show piece destinations")));
    }
}
class AutoQueenSettings extends settings_1.BooleanSettings {
    constructor(boardSettings) {
        super('autoqueen', false);
        this.boardSettings = boardSettings;
    }
    update() {
        if (this.boardSettings.ctrl instanceof roundCtrl_1.default)
            this.boardSettings.ctrl.autoqueen = this.value;
    }
    view() {
        return (0, h_1.default)('div', (0, view_1.checkbox)(this, 'autoqueen', (0, i18n_1._)("Promote to Queen automatically")));
    }
}
class ArrowSettings extends settings_1.BooleanSettings {
    constructor(boardSettings) {
        super('arrow', true);
        this.boardSettings = boardSettings;
    }
    update() {
        if (this.boardSettings.ctrl instanceof analysisCtrl_1.default)
            this.boardSettings.ctrl.arrow = this.value;
    }
    view() {
        return (0, h_1.default)('div', (0, view_1.checkbox)(this, 'arrow', (0, i18n_1._)("Best move arrow in analysis board")));
    }
}
class BlindfoldSettings extends settings_1.BooleanSettings {
    constructor(boardSettings) {
        super('blindfold', false);
        this.boardSettings = boardSettings;
    }
    update() {
        if (this.boardSettings.ctrl instanceof roundCtrl_1.default)
            this.boardSettings.ctrl.blindfold = this.value;
        const el = document.getElementById('mainboard');
        if (el) {
            if (this.value) {
                el.classList.add('blindfold');
            }
            else {
                el.classList.remove('blindfold');
            }
        }
    }
    view() {
        return (0, h_1.default)('div', (0, view_1.checkbox)(this, 'blindfold', (0, i18n_1._)("Invisible pieces")));
    }
}
exports.boardSettings = new BoardSettings();

},{"./analysisCtrl":3,"./chart":6,"./chess":8,"./document":13,"./i18n":18,"./info":19,"./main":31,"./player":36,"./pocket":38,"./roundCtrl":42,"./settings":43,"./view":49,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92}],6:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.analysisChart = void 0;
const highcharts_1 = __importDefault(require("highcharts"));
const i18n_1 = require("./i18n");
const movelist_1 = require("./movelist");
const winningChances_1 = require("./winningChances");
function analysisChart(ctrl) {
    const scores = ctrl.steps.map((step, ply) => {
        if (step.ceval !== undefined) {
            const score = step.ceval.s;
            const color = (ctrl.variant.firstColor === "Black") ? step.turnColor === 'black' ? 'white' : 'black' : step.turnColor;
            if (score !== undefined) {
                const turn = Math.floor((ply - 1) / 2) + 1;
                const dots = step.turnColor === 'black' ? '.' : '...';
                const point = {
                    name: turn + dots + ' ' + step.san,
                    y: (0, winningChances_1.povChances)(color, score)
                };
                if (ply === 0)
                    point.name = (0, i18n_1._)('Initial position');
                return point;
            }
            else {
                return null;
            }
        }
        else {
            return null;
        }
    });
    ctrl.analysisChart = highcharts_1.default.chart('chart', {
        chart: { type: 'area',
            spacing: [3, 0, 3, 0],
            animation: false,
            backgroundColor: undefined,
        },
        credits: { enabled: false },
        legend: { enabled: false },
        title: { text: undefined },
        plotOptions: {
            series: {
                animation: false
            },
            area: {
                fillColor: 'rgba(255,255,255,0.7)',
                negativeFillColor: 'rgba(0,0,0,0.2)',
                threshold: 0,
                lineWidth: 1,
                color: '#d85000',
                allowPointSelect: true,
                cursor: 'pointer',
                states: {
                    hover: {
                        lineWidth: 1
                    }
                },
                events: {
                    click: function (event) {
                        if (event.point) {
                            event.point.select();
                            (0, movelist_1.selectMove)(ctrl, event.point.x);
                        }
                    }
                },
                marker: {
                    radius: 1,
                    states: {
                        hover: {
                            radius: 4,
                            lineColor: '#d85000'
                        },
                        select: {
                            radius: 4,
                            lineColor: '#d85000'
                        }
                    }
                }
            }
        },
        tooltip: {
            pointFormatter: function (format) {
                format = format.replace('{series.name}', (0, i18n_1._)('Advantage'));
                const self = this;
                const ceval = ctrl.steps[self.x].ceval.s;
                if (!ceval)
                    return '';
                else
                    return format.replace('{point.y}', ctrl.steps[self.x].scoreStr);
            }
        },
        xAxis: {
            title: { text: undefined },
            labels: { enabled: false },
            gridLineWidth: 1,
            lineWidth: 0,
            tickWidth: 0
        },
        yAxis: {
            title: { text: undefined },
            labels: { enabled: false },
            min: -1.1,
            max: 1.1,
            startOnTick: false,
            endOnTick: false,
            lineWidth: 1,
            gridLineWidth: 0,
            plotLines: [{
                    color: '#a0a0a0',
                    width: 1,
                    value: 0,
                }]
        },
        series: [{ data: scores }]
    });
}
exports.analysisChart = analysisChart;

},{"./i18n":18,"./movelist":32,"./winningChances":50,"highcharts":72}],7:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chatMessage = exports.chatView = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
const h_1 = __importDefault(require("snabbdom/h"));
const i18n_1 = require("./i18n");
function chatView(ctrl, chatType) {
    function onKeyPress(e) {
        if (!document.getElementById('checkbox').checked)
            return;
        const message = e.target.value;
        if ((e.keyCode == 13 || e.which == 13) && message.length > 0) {
            ctrl.doSend({ "type": chatType, "message": message, "gameId": ctrl.model["gameId"], "tournamentId": ctrl.model["tournamentId"], "room": (ctrl.spectator) ? "spectator" : "player" });
            e.target.value = "";
        }
    }
    function onClick() {
        const activated = document.getElementById('checkbox').checked;
        const chatEntry = document.getElementById('chat-entry');
        document.getElementById(chatType + "-messages").style.display = activated ? "block" : "none";
        chatEntry.disabled = !activated;
        chatEntry.placeholder = activated ? (anon ? (0, i18n_1._)('Sign in to chat') : (0, i18n_1._)('Please be nice in the chat!')) : (0, i18n_1._)("Chat is disabled");
    }
    const anon = ctrl.model["anon"] === 'True';
    return (0, h_1.default)(`div#${chatType}.${chatType}.chat`, [
        (0, h_1.default)('div.chatroom', [
            ctrl.spectator ? (0, i18n_1._)('Spectator room') : (0, i18n_1._)('Chat room'),
            (0, h_1.default)('input#checkbox', { props: { title: (0, i18n_1._)("Toggle the chat"), name: "checkbox", type: "checkbox", checked: "true" }, on: { click: onClick } })
        ]),
        // TODO: lock/unlock chat to spectators
        (0, h_1.default)(`ol#${chatType}-messages`, [(0, h_1.default)('div#messages')]),
        (0, h_1.default)('input#chat-entry', {
            props: {
                type: "text",
                name: "entry",
                autocomplete: "off",
                placeholder: (anon) ? (0, i18n_1._)('Sign in to chat') : (0, i18n_1._)('Please be nice in the chat!'),
                disabled: anon,
            },
            attrs: {
                maxlength: 140,
            },
            on: { keypress: onKeyPress },
        })
    ]);
}
exports.chatView = chatView;
function chatMessage(user, message, chatType) {
    const myDiv = document.getElementById(chatType + '-messages');
    // You must add border widths, padding and margins to the right.
    const isScrolled = myDiv.scrollTop == myDiv.scrollHeight - myDiv.offsetHeight;
    const container = document.getElementById('messages');
    if (user.length === 0) {
        patch(container, (0, h_1.default)('div#messages', [(0, h_1.default)("li.message.offer", [(0, h_1.default)("t", message)])]));
    }
    else if (user === '_server') {
        patch(container, (0, h_1.default)('div#messages', [(0, h_1.default)("li.message.server", [(0, h_1.default)("user", (0, i18n_1._)('Server')), (0, h_1.default)("t", message)])]));
    }
    else {
        patch(container, (0, h_1.default)('div#messages', [(0, h_1.default)("li.message", [(0, h_1.default)("user", (0, h_1.default)("a", { attrs: { href: "/@/" + user } }, user)), (0, h_1.default)("t", message)])]));
    }
    if (isScrolled)
        setTimeout(() => { myDiv.scrollTop = myDiv.scrollHeight; }, 200);
}
exports.chatMessage = chatMessage;

},{"./i18n":18,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91}],8:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lc = exports.san2role = exports.role2san = exports.letter2role = exports.role2letter = exports.uci2array = exports.moveDests = exports.dropIsValid = exports.unpromotedRole = exports.getJanggiPoints = exports.getCounting = exports.getPockets = exports.validFen = exports.cg2uci = exports.uci2cg = exports.hasCastling = exports.isHandicap = exports.selectVariant = exports.enabledVariants = exports.variants = exports.VARIANTS = exports.PIECE_FAMILIES = exports.BOARD_FAMILIES = void 0;
const h_1 = require("snabbdom/h");
const cg = __importStar(require("chessgroundx/types"));
const util = __importStar(require("chessgroundx/util"));
const fen_1 = require("chessgroundx/fen");
const i18n_1 = require("./i18n");
const pieceSan = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
exports.BOARD_FAMILIES = {
    standard8x8: { geometry: 0 /* dim8x8 */, cg: "cg-512", boardCSS: ["8x8brown.svg", "8x8blue.svg", "8x8green.svg", "8x8maple.jpg", "8x8olive.jpg", "8x8santa.png"] },
    standard10x8: { geometry: 2 /* dim10x8 */, cg: "cg-640", boardCSS: ["10x8brown.svg", "10x8blue.svg", "10x8green.svg", "10x8maple.jpg", "10x8olive.jpg"] },
    standard10x10: { geometry: 4 /* dim10x10 */, cg: "cg-640-640", boardCSS: ["10x10brown.svg", "10x10blue.svg", "10x10green.svg", "10x10maple.jpg", "10x10olive.jpg"] },
    grand10x10: { geometry: 4 /* dim10x10 */, cg: "cg-640-640", boardCSS: ["Grandboard.svg", "10x10brown.svg", "10x10blue.svg", "10x10green.svg", "10x10maple.jpg", "10x10mapleGrand.png"] },
    makruk8x8: { geometry: 0 /* dim8x8 */, cg: "cg-512", boardCSS: ["makruk2.svg", "makruk.svg", "makruk.jpg"] },
    sittuyin8x8: { geometry: 0 /* dim8x8 */, cg: "cg-512", boardCSS: ["sittuyin.svg", "sittuyin.jpg", "sittuyingreen.svg", "sittuyinGrainBrown.svg"] },
    shogi9x9: { geometry: 1 /* dim9x9 */, cg: "cg-576", boardCSS: ["shogi.svg", "Shogiban1.png", "Shogiban2.png", "shogic.svg", "ShogiMaple.png", 'ShogiGrayTexture.png', "ShogiSpace1.png", "doubutsu.svg", "ShogiOak.png"] },
    shogi7x7: { geometry: 6 /* dim7x7 */, cg: "cg-448-516", boardCSS: ["ToriPlain.svg", "ToriWood.svg", "ToriDaySky.svg", "ToriNightSky.svg"] },
    shogi5x5: { geometry: 5 /* dim5x5 */, cg: "cg-260", boardCSS: ["minishogi.svg", "MiniboardWood1.png", "MiniboardWood2.png", "MinishogiDobutsu.svg", "MinishogiDobutsu2.svg"] },
    shogi5x6: { geometry: 8 /* dim5x6 */, cg: "cg-260-360", boardCSS: ["gorogoro.svg", "gorogoroboard.svg", "gorogoro2.svg", "GorogoroWood.png"] },
    shogi3x4: { geometry: 7 /* dim3x4 */, cg: "cg-156", boardCSS: ["doubutsuboard.svg", "dobutsu3x4.svg"] },
    xiangqi9x10: { geometry: 3 /* dim9x10 */, cg: "cg-576-640", boardCSS: ["xiangqi.svg", "xiangqic.svg", "xiangqiCTexture.png", "xiangqiPaper.png", "xiangqiWood.png", "xiangqiDark.svg", "xiangqiWikimedia.svg"] },
    xiangqi7x7: { geometry: 6 /* dim7x7 */, cg: "cg-448", boardCSS: ["minixiangqi.svg", "minixiangqiw.png", "minixqlg.svg"] },
    janggi9x10: { geometry: 3 /* dim9x10 */, cg: "cg-576-640", boardCSS: ["JanggiBrown.svg", "JanggiPaper.png", "JanggiWood.png", "JanggiDark.svg", "JanggiWoodDark.svg", "JanggiStone.svg"] },
    shogun8x8: { geometry: 0 /* dim8x8 */, cg: "cg-512", boardCSS: ["ShogunPlain.svg", "ShogunMaple.png", "ShogunMaple2.png", "ShogunBlue.svg", "8x8brown.svg", "8x8maple.jpg"] },
};
exports.PIECE_FAMILIES = {
    standard: { pieceCSS: ["standard", "green", "alpha", "chess_kaneo", "santa"] },
    capa: { pieceCSS: ["capa0", "capa1", "capa2", "capa3", "capa4"] },
    seirawan: { pieceCSS: ["seir1", "seir0", "seir2", "seir3", "seir4"] },
    makruk: { pieceCSS: ["makrukwb", "makrukwr", "makruk", "makruks", "makruki"] },
    sittuyin: { pieceCSS: ["sittuyins", "sittuyinkagr", "sittuyinkabr", "sittuyinm", "sittuyini"] },
    shogi: { pieceCSS: ["shogik", "shogi", "shogiw", "shogip", "shogim", "shogip3d", "shogikw3d", "shogid", "shogiim"] },
    kyoto: { pieceCSS: ["kyoto", "kyotok", "kyotoi", "kyotod"] },
    dobutsu: { pieceCSS: ["dobutsu"] },
    tori: { pieceCSS: ["torii", "torik", "torim"] },
    xiangqi: { pieceCSS: ["xiangqi", "xiangqict3", "xiangqict2", "xiangqihnz", "xiangqict2w", "xiangqihnzw", "xiangqiKa", "xiangqiwikim"] },
    janggi: { pieceCSS: ["janggihb", "janggihg", "janggiikak", "janggiikaw", "janggikak", "janggikaw"] },
    shako: { pieceCSS: ["shako0", "shako1", "shako2"] },
    shogun: { pieceCSS: ["shogun0", "shogun1", "shogun2", "shogun3", "shogun4", "shogun5"] },
    orda: { pieceCSS: ["orda0", "orda1"] },
    synochess: { pieceCSS: ["synochess0", "synochess1", "synochess2", "synochess3", "synochess4", "synochess5"] },
    hoppel: { pieceCSS: ["hoppel0", "hoppel1", "hoppel2"] },
    shinobi: { pieceCSS: ["shinobi0", "shinobi1"] },
    empire: { pieceCSS: ["empire0", "empire1"] },
    ordamirror: { pieceCSS: ["ordamirror0", "ordamirror1"] },
};
const alwaysMandatory = () => true;
function distanceBased(required, boardHeight) {
    return (role, _orig, dest, color) => {
        const letter = role2letter(role);
        return (letter in required) ? distFromLastRank(dest, color, boardHeight) < required[letter] : false;
    };
}
function distFromLastRank(dest, color, boardHeight) {
    const rank = util.key2pos(dest)[1];
    return (color === "white") ? boardHeight - rank : rank - 1;
}
class Variant {
    constructor(data) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        this.name = data.name;
        this._displayName = ((_a = data.displayName) !== null && _a !== void 0 ? _a : data.name).toUpperCase();
        this._tooltip = data.tooltip;
        this.startFen = data.startFen;
        this.board = data.board;
        this.boardFamily = exports.BOARD_FAMILIES[data.board];
        this.piece = data.piece;
        this.pieceFamily = exports.PIECE_FAMILIES[data.piece];
        this.firstColor = (_b = data.firstColor) !== null && _b !== void 0 ? _b : "White";
        this.secondColor = (_c = data.secondColor) !== null && _c !== void 0 ? _c : "Black";
        this._pieceRoles = [data.pieceRoles, (_d = data.pieceRoles2) !== null && _d !== void 0 ? _d : data.pieceRoles];
        this.pocket = Boolean(data.pocketRoles || data.pocketRoles2);
        this._pocketRoles = [data.pocketRoles, (_e = data.pocketRoles2) !== null && _e !== void 0 ? _e : data.pocketRoles];
        this.promotion = (_f = data.promotion) !== null && _f !== void 0 ? _f : "regular";
        this.isMandatoryPromotion = (_g = data.isMandatoryPromotion) !== null && _g !== void 0 ? _g : alwaysMandatory;
        this.timeControl = (_h = data.timeControl) !== null && _h !== void 0 ? _h : "incremental";
        this.counting = data.counting;
        this.materialPoint = data.materialPoint;
        this.enPassant = (_j = data.enPassant) !== null && _j !== void 0 ? _j : false;
        this.autoQueenable = (_k = data.autoQueenable) !== null && _k !== void 0 ? _k : false;
        this.drop = (_l = data.drop) !== null && _l !== void 0 ? _l : false;
        this.gate = (_m = data.gate) !== null && _m !== void 0 ? _m : false;
        this.pass = (_o = data.pass) !== null && _o !== void 0 ? _o : false;
        this.alternateStart = data.alternateStart;
        this.chess960 = (_p = data.chess960) !== null && _p !== void 0 ? _p : false;
        this._icon = data.icon;
        this._icon960 = (_q = data.icon960) !== null && _q !== void 0 ? _q : data.icon;
        this.pieceSound = (_r = data.pieceSound) !== null && _r !== void 0 ? _r : "regular";
    }
    displayName(chess960 = false) { return this._displayName + (chess960 ? "960" : ""); }
    tooltip() { return this._tooltip(); }
    get geometry() { return this.boardFamily.geometry; }
    get boardWidth() { return cg.dimensions[this.geometry].width; }
    get boardHeight() { return cg.dimensions[this.geometry].height; }
    get cg() { return this.boardFamily.cg; }
    get boardCSS() { return this.boardFamily.boardCSS; }
    get pieceCSS() { return this.pieceFamily.pieceCSS; }
    pieceRoles(color) { return color === "white" ? this._pieceRoles[0] : this._pieceRoles[1]; }
    pocketRoles(color) { return color === "white" ? this._pocketRoles[0] : this._pocketRoles[1]; }
    icon(chess960 = false) { return chess960 ? this._icon960 : this._icon; }
}
exports.VARIANTS = {
    chess: new Variant({
        name: "chess", tooltip: () => (0, i18n_1._)("Chess, unmodified, as it's played by FIDE standards."),
        startFen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
        board: "standard8x8", piece: "standard",
        pieceRoles: ["k", "q", "r", "b", "n", "p"],
        enPassant: true, autoQueenable: true,
        alternateStart: {
            '': '',
            'PawnsPushed': "rnbqkbnr/8/8/pppppppp/PPPPPPPP/8/8/RNBQKBNR w KQkq - 0 1",
            'PawnsPassed': "rnbqkbnr/8/8/PPPPPPPP/pppppppp/8/8/RNBQKBNR w KQkq - 0 1",
            'UpsideDown': "RNBKQBNR/PPPPPPPP/8/8/8/8/pppppppp/rnbkqbnr w - - 0 1",
            'Theban': "1p6/2p3kn/3p2pp/4pppp/5ppp/8/PPPPPPPP/PPPPPPKN w - - 0 1",
            'No castle': 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1'
        },
        chess960: true, icon: "M", icon960: "V",
    }),
    crazyhouse: new Variant({
        name: "crazyhouse", tooltip: () => (0, i18n_1._)("Take captured pieces and drop them back on to the board as your own."),
        startFen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR[] w KQkq - 0 1",
        board: "standard8x8", piece: "standard",
        pieceRoles: ["k", "q", "r", "b", "n", "p"],
        pocketRoles: ["p", "n", "b", "r", "q"],
        enPassant: true, autoQueenable: true, drop: true,
        alternateStart: {
            '': '',
            'PawnsPushed': "rnbqkbnr/8/8/pppppppp/PPPPPPPP/8/8/RNBQKBNR w - - 0 1",
            'PawnsPassed': "rnbqkbnr/8/8/PPPPPPPP/pppppppp/8/8/RNBQKBNR w - - 0 1",
            'UpsideDown': "RNBQKBNR/PPPPPPPP/8/8/8/8/pppppppp/rnbqkbnr w - - 0 1",
            'Theban': "1p6/2p3kn/3p2pp/4pppp/5ppp/8/PPPPPPPP/PPPPPPKN w - - 0 1",
            'No castle': 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1'
        },
        chess960: true, icon: "+", icon960: "%",
    }),
    placement: new Variant({
        name: "placement", tooltip: () => (0, i18n_1._)("Choose where your pieces start."),
        startFen: "8/pppppppp/8/8/8/8/PPPPPPPP/8[KQRRBBNNkqrrbbnn] w - - 0 1",
        board: "standard8x8", piece: "standard",
        pieceRoles: ["k", "q", "r", "b", "n", "p"],
        pocketRoles: ["n", "b", "r", "q", "k"],
        enPassant: true, autoQueenable: true,
        icon: "S",
    }),
    atomic: new Variant({
        name: "atomic", tooltip: () => (0, i18n_1._)("Pieces explode upon capture."),
        startFen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
        board: "standard8x8", piece: "standard",
        pieceRoles: ["k", "q", "r", "b", "n", "p"],
        enPassant: true, autoQueenable: true,
        pieceSound: "atomic",
        chess960: true, icon: "~", icon960: "\\",
    }),
    makruk: new Variant({
        name: "makruk", tooltip: () => (0, i18n_1._)("Thai Chess. A game closely resembling the original Chaturanga. Similar to Chess but with a different queen and bishop."),
        startFen: "rnsmksnr/8/pppppppp/8/8/PPPPPPPP/8/RNSKMSNR w - - 0 1",
        board: "makruk8x8", piece: "makruk",
        pieceRoles: ["k", "s", "m", "n", "r", "p", "m~"],
        counting: "makruk",
        icon: "Q",
    }),
    makpong: new Variant({
        name: "makpong", tooltip: () => (0, i18n_1._)("Makruk variant where kings cannot move to escape out of check."),
        startFen: "rnsmksnr/8/pppppppp/8/8/PPPPPPPP/8/RNSKMSNR w - - 0 1",
        board: "makruk8x8", piece: "makruk",
        pieceRoles: ["k", "s", "m", "n", "r", "p", "m~"],
        counting: "makruk",
        icon: "O",
    }),
    cambodian: new Variant({
        name: "cambodian", displayName: "ouk chatrang", tooltip: () => (0, i18n_1._)("Cambodian Chess. Makruk with a few additional opening abilities."),
        startFen: "rnsmksnr/8/pppppppp/8/8/PPPPPPPP/8/RNSKMSNR w DEde - 0 1",
        board: "makruk8x8", piece: "makruk",
        pieceRoles: ["k", "s", "m", "n", "r", "p", "m~"],
        counting: "makruk",
        icon: "!",
    }),
    sittuyin: new Variant({
        name: "sittuyin", tooltip: () => (0, i18n_1._)("Burmese Chess. Similar to Makruk, but pieces are placed at the start of the match."),
        startFen: "8/8/4pppp/pppp4/4PPPP/PPPP4/8/8[KFRRSSNNkfrrssnn] w - - 0 1",
        board: "sittuyin8x8", piece: "sittuyin",
        firstColor: "Red", secondColor: "Black",
        pieceRoles: ["k", "f", "s", "n", "r", "p"],
        pocketRoles: ["r", "n", "s", "f", "k"],
        counting: "asean",
        icon: ":",
    }),
    shogi: new Variant({
        name: "shogi", tooltip: () => (0, i18n_1._)("Japanese Chess, and the standard 9x9 version played today with drops and promotions. "),
        startFen: "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL[-] w 0 1",
        board: "shogi9x9", piece: "shogi",
        firstColor: "Black", secondColor: "White",
        pieceRoles: ["k", "r", "b", "g", "s", "n", "l", "p", "+r", "+b", "+s", "+n", "+l", "+p"],
        pocketRoles: ["p", "l", "n", "s", "g", "b", "r"],
        promotion: "shogi",
        isMandatoryPromotion: distanceBased({ p: 1, l: 1, n: 2 }, 9),
        timeControl: "byoyomi",
        pieceSound: "shogi",
        drop: true,
        alternateStart: {
            '': '',
            'Lance HC': 'lnsgkgsn1/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL[-] b 0 1',
            'Bishop HC': 'lnsgkgsnl/1r7/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL[-] b 0 1',
            'Rook HC': 'lnsgkgsnl/7b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL[-] b 0 1',
            'Rook+Lance HC': 'lnsgkgsn1/7b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL[-] b 0 1',
            '2-Piece HC': 'lnsgkgsnl/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL[-] b 0 1',
            '4-Piece HC': '1nsgkgsn1/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL[-] b 0 1',
            '6-Piece HC': '2sgkgs2/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL[-] b 0 1',
            '8-Piece HC': '3gkg3/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL[-] b 0 1',
            '9-Piece HC': '3gk4/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL[-] b 0 1',
            '10-Piece HC': '4k4/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL[-] b 0 1'
        },
        icon: "K",
    }),
    minishogi: new Variant({
        name: "minishogi", tooltip: () => (0, i18n_1._)("5x5 Shogi for more compact and faster games. There are no knights or lances."),
        startFen: "rbsgk/4p/5/P4/KGSBR[-] w 0 1",
        board: "shogi5x5", piece: "shogi",
        firstColor: "Black", secondColor: "White",
        pieceRoles: ["k", "r", "b", "g", "s", "p", "+r", "+b", "+s", "+p"],
        pocketRoles: ["p", "s", "g", "b", "r"],
        promotion: "shogi",
        isMandatoryPromotion: distanceBased({ p: 1 }, 5),
        timeControl: "byoyomi",
        pieceSound: "shogi",
        drop: true,
        icon: "6",
    }),
    kyotoshogi: new Variant({
        name: "kyotoshogi", tooltip: () => (0, i18n_1._)("A wild Shogi variant on a 5x5 board where pieces flip into a different piece after each move."),
        startFen: "p+nks+l/5/5/5/+LSK+NP[-] w 0 1",
        board: "shogi5x5", piece: "kyoto",
        firstColor: "Black", secondColor: "White",
        pieceRoles: ["k", "+n", "n", "+s", "s", "+l", "l", "+p", "p"],
        pocketRoles: ["p", "l", "n", "s"],
        promotion: "kyoto",
        isMandatoryPromotion: (_role, orig, _dest, _color) => orig !== 'a0',
        timeControl: "byoyomi",
        pieceSound: "shogi",
        drop: true,
        icon: ")",
    }),
    dobutsu: new Variant({
        name: "dobutsu", tooltip: () => (0, i18n_1._)("3x4 game with cute animals, designed to teach children how to play Shogi."),
        startFen: "gle/1c1/1C1/ELG[-] w 0 1",
        board: "shogi3x4", piece: "dobutsu",
        firstColor: "Black", secondColor: "White",
        pieceRoles: ["l", "g", "e", "c", "+c"],
        pocketRoles: ["e", "g", "c"],
        promotion: "shogi",
        timeControl: "byoyomi",
        pieceSound: "shogi",
        drop: true,
        icon: "8",
    }),
    gorogoro: new Variant({
        name: "gorogoro", tooltip: () => (0, i18n_1._)("5x6 Shogi designed to introduce tactics with the generals."),
        startFen: "sgkgs/5/1ppp1/1PPP1/5/SGKGS[-] w 0 1",
        board: "shogi5x6", piece: "shogi",
        firstColor: "Black", secondColor: "White",
        pieceRoles: ["k", "g", "s", "p", "+s", "+p"],
        pocketRoles: ["p", "s", "g"],
        promotion: "shogi",
        isMandatoryPromotion: distanceBased({ p: 1 }, 6),
        timeControl: "byoyomi",
        pieceSound: "shogi",
        drop: true,
        icon: "🐱",
    }),
    torishogi: new Variant({
        name: "torishogi", tooltip: () => (0, i18n_1._)("A confrontational 7x7 variant with unique pieces each named after different birds."),
        startFen: "rpckcpl/3f3/sssssss/2s1S2/SSSSSSS/3F3/LPCKCPR[-] w 0 1",
        board: "shogi7x7", piece: "tori",
        firstColor: "Black", secondColor: "White",
        pieceRoles: ["k", "f", "c", "p", "l", "r", "s", "+f", "+s"],
        pocketRoles: ["s", "p", "l", "r", "c", "f"],
        promotion: "shogi",
        timeControl: "byoyomi",
        pieceSound: "shogi",
        drop: true,
        alternateStart: {
            '': '',
            'Left Quail HC': 'rpckcp1/3f3/sssssss/2s1S2/SSSSSSS/3F3/LPCKCPR[] b 0 1',
            'Falcon HC': 'rpckcpl/7/sssssss/2s1S2/SSSSSSS/3F3/LPCKCPR[] b 0 1',
            'Falcon + Left Quail HC': 'rpckcp1/7/sssssss/2s1S2/SSSSSSS/3F3/LPCKCPR[] b 0 1',
            'Falcon + Both Quails HC': '1pckcp1/7/sssssss/2s1S2/SSSSSSS/3F3/LPCKCPR[] b 0 1',
        },
        icon: "🐦",
    }),
    xiangqi: new Variant({
        name: "xiangqi", tooltip: () => (0, i18n_1._)("Chinese Chess, one of the oldest and most played board games in the world."),
        startFen: "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1",
        board: "xiangqi9x10", piece: "xiangqi",
        firstColor: "Red", secondColor: "Black",
        pieceRoles: ["k", "a", "c", "r", "b", "n", "p"],
        icon: "|",
    }),
    manchu: new Variant({
        name: "manchu", tooltip: () => (0, i18n_1._)("Xiangqi variant where one side has a chariot that can also move as a cannon or horse."),
        startFen: "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/9/9/M1BAKAB2 w - - 0 1",
        board: "xiangqi9x10", piece: "xiangqi",
        firstColor: "Red", secondColor: "Black",
        pieceRoles: ["k", "a", "m", "b", "p"],
        pieceRoles2: ["k", "a", "c", "r", "b", "n", "p"],
        icon: "{",
    }),
    janggi: new Variant({
        name: "janggi", tooltip: () => (0, i18n_1._)("Korean Chess, similar to Xiangqi but plays much differently. Tournament rules are used."),
        startFen: "rnba1abnr/4k4/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/4K4/RNBA1ABNR w - - 0 1",
        board: "janggi9x10", piece: "janggi",
        firstColor: "Blue", secondColor: "Red",
        pieceRoles: ["k", "a", "c", "r", "b", "n", "p"],
        timeControl: "byoyomi",
        materialPoint: "janggi",
        pass: true,
        icon: "=",
    }),
    minixiangqi: new Variant({
        name: "minixiangqi", tooltip: () => (0, i18n_1._)("Compact version of Xiangqi played on a 7x7 board without a river."),
        startFen: "rcnkncr/p1ppp1p/7/7/7/P1PPP1P/RCNKNCR w - - 0 1",
        board: "xiangqi7x7", piece: "xiangqi",
        firstColor: "Red", secondColor: "Black",
        pieceRoles: ["k", "c", "r", "n", "p"],
        icon: "7",
    }),
    capablanca: new Variant({
        name: "capablanca", tooltip: () => (0, i18n_1._)("Play with the hybrid pieces, archbishop (B+N) and chancellor (R+N), on a 10x8 board."),
        startFen: "rnabqkbcnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNABQKBCNR w KQkq - 0 1",
        board: "standard10x8", piece: "capa",
        pieceRoles: ["k", "q", "c", "a", "r", "b", "n", "p"],
        enPassant: true, autoQueenable: true,
        alternateStart: {
            '': '',
            'Bird': 'rnbcqkabnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNBCQKABNR w KQkq - 0 1',
            'Carrera': 'rcnbqkbnar/pppppppppp/10/10/10/10/PPPPPPPPPP/RCNBQKBNAR w KQkq - 0 1',
            'Gothic': 'rnbqckabnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNBQCKABNR w KQkq - 0 1',
            'Embassy': 'rnbqkcabnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNBQKCABNR w KQkq - 0 1',
            'Conservative': 'arnbqkbnrc/pppppppppp/10/10/10/10/PPPPPPPPPP/ARNBQKBNRC w KQkq - 0 1'
        },
        chess960: true, icon: "P", icon960: ",",
    }),
    capahouse: new Variant({
        name: "capahouse", tooltip: () => (0, i18n_1._)("Capablanca with Crazyhouse drop rules."),
        startFen: "rnabqkbcnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNABQKBCNR[] w KQkq - 0 1",
        board: "standard10x8", piece: "capa",
        pieceRoles: ["k", "q", "c", "a", "r", "b", "n", "p"],
        pocketRoles: ["p", "n", "b", "r", "a", "c", "q"],
        enPassant: true, autoQueenable: true, drop: true,
        alternateStart: {
            '': '',
            'Bird': 'rnbcqkabnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNBCQKABNR w KQkq - 0 1',
            'Carrera': 'rcnbqkbnar/pppppppppp/10/10/10/10/PPPPPPPPPP/RCNBQKBNAR w KQkq - 0 1',
            'Gothic': 'rnbqckabnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNBQCKABNR w KQkq - 0 1',
            'Embassy': 'rnbqkcabnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNBQKCABNR w KQkq - 0 1'
        },
        chess960: true, icon: "&", icon960: "'",
    }),
    seirawan: new Variant({
        name: "seirawan", displayName: "s-chess", tooltip: () => (0, i18n_1._)("Hybrid pieces, the hawk (B+N) and elephant (R+N), can enter the board after moving a back rank piece."),
        startFen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR[HEhe] w KQBCDFGkqbcdfg - 0 1",
        board: "standard8x8", piece: "seirawan",
        pieceRoles: ["k", "q", "e", "h", "r", "b", "n", "p"],
        pocketRoles: ["h", "e"],
        enPassant: true, autoQueenable: true, gate: true,
        icon: "L", chess960: true, icon960: "}",
    }),
    shouse: new Variant({
        name: "shouse", displayName: "s-house", tooltip: () => (0, i18n_1._)("S-Chess with Crazyhouse drop rules."),
        startFen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR[HEhe] w KQBCDFGkqbcdfg - 0 1",
        board: "standard8x8", piece: "seirawan",
        pieceRoles: ["k", "q", "e", "h", "r", "b", "n", "p"],
        pocketRoles: ["p", "n", "b", "r", "h", "e", "q"],
        enPassant: true, autoQueenable: true, drop: true, gate: true,
        icon: "$",
    }),
    grand: new Variant({
        name: "grand", tooltip: () => (0, i18n_1._)("Play with the hybrid pieces, archbishop (B+N) and chancellor (R+N), on a grand 10x10 board."),
        startFen: "r8r/1nbqkcabn1/pppppppppp/10/10/10/10/PPPPPPPPPP/1NBQKCABN1/R8R w - - 0 1",
        board: "grand10x10", piece: "capa",
        pieceRoles: ["k", "q", "c", "a", "r", "b", "n", "p"],
        isMandatoryPromotion: distanceBased({ p: 1 }, 10),
        enPassant: true, autoQueenable: true,
        icon: "(",
    }),
    grandhouse: new Variant({
        name: "grandhouse", tooltip: () => (0, i18n_1._)("Grand Chess with Crazyhouse drop rules."),
        startFen: "r8r/1nbqkcabn1/pppppppppp/10/10/10/10/PPPPPPPPPP/1NBQKCABN1/R8R[] w - - 0 1",
        board: "grand10x10", piece: "capa",
        pieceRoles: ["k", "q", "c", "a", "r", "b", "n", "p"],
        pocketRoles: ["p", "n", "b", "r", "a", "c", "q"],
        isMandatoryPromotion: distanceBased({ p: 1 }, 10),
        enPassant: true, autoQueenable: true, drop: true,
        icon: "*",
    }),
    shako: new Variant({
        name: "shako", tooltip: () => (0, i18n_1._)("Introduces the cannon and elephant from Xiangqi into a 10x10 chess board."),
        startFen: "c8c/ernbqkbnre/pppppppppp/10/10/10/10/PPPPPPPPPP/ERNBQKBNRE/C8C w KQkq - 0 1",
        board: "standard10x10", piece: "shako",
        pieceRoles: ["k", "q", "e", "c", "r", "b", "n", "p"],
        enPassant: true, autoQueenable: true,
        icon: "9",
    }),
    shogun: new Variant({
        name: "shogun", tooltip: () => (0, i18n_1._)("Pieces promote and can be dropped, similar to Shogi."),
        startFen: "rnb+fkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNB+FKBNR w KQkq - 0 1",
        board: "shogun8x8", piece: "shogun",
        pieceRoles: ["k", "+f", "r", "b", "n", "p", "f", "+r", "+b", "+n", "+p"],
        pocketRoles: ["p", "n", "b", "r", "f"],
        promotion: "shogi",
        isMandatoryPromotion: distanceBased({ p: 1 }, 8),
        timeControl: "byoyomi",
        enPassant: true, drop: true,
        icon: "-",
    }),
    orda: new Variant({
        name: "orda", tooltip: () => (0, i18n_1._)("Asymmetric variant where one army has pieces that move like knights but capture differently."),
        startFen: "lhaykahl/8/pppppppp/8/8/8/PPPPPPPP/RNBQKBNR w KQ - 0 1",
        board: "standard8x8", piece: "orda",
        firstColor: "White", secondColor: "Gold",
        pieceRoles: ["k", "q", "r", "b", "n", "p", "h"],
        pieceRoles2: ["k", "y", "l", "a", "h", "p", "q"],
        enPassant: true,
        icon: "R",
    }),
    synochess: new Variant({
        name: "synochess", tooltip: () => (0, i18n_1._)("Asymmetric East vs. West variant which pits the western Chess army against a Xiangqi and Janggi-styled army."),
        startFen: "rneakenr/8/1c4c1/1ss2ss1/8/8/PPPPPPPP/RNBQKBNR[ss] w KQ - 0 1",
        board: "standard8x8", piece: "synochess",
        firstColor: "White", secondColor: "Red",
        pieceRoles: ["k", "q", "r", "b", "n", "p"],
        pieceRoles2: ["k", "a", "c", "r", "e", "n", "s"],
        pocketRoles: [], pocketRoles2: ["s"],
        autoQueenable: true,
        icon: "_",
    }),
    hoppelpoppel: new Variant({
        name: "hoppelpoppel", displayName: "hoppel-poppel", tooltip: () => (0, i18n_1._)("Knights capture as bishops; bishops  capture as knights."),
        startFen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
        board: "standard8x8", piece: "hoppel",
        pieceRoles: ["k", "q", "r", "b", "n", "p"],
        enPassant: true, autoQueenable: true,
        icon: "`",
    }),
    shinobi: new Variant({
        name: "shinobi", tooltip: () => (0, i18n_1._)("Asymmetric variant which pits the western Chess army against a drop-based, Shogi-styled army."),
        startFen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/LH1CK1HL[LHMMDJ] w kq - 0 1",
        board: "standard8x8", piece: "shinobi",
        firstColor: "Pink", secondColor: "Black",
        pieceRoles: ["k", "c", "l", "h", "m", "d", "j", "p", "+l", "+h", "+m", "+p"],
        pieceRoles2: ["k", "q", "r", "b", "n", "p", "+p"],
        pocketRoles: ["l", "h", "m", "d", "j"],
        pocketRoles2: [],
        promotion: "shogi",
        enPassant: true,
        icon: "🐢",
    }),
    empire: new Variant({
        name: "empire", tooltip: () => (0, i18n_1._)("Asymmetric variant where one army has pieces that move like queens but capture as usual."),
        startFen: "rnbqkbnr/pppppppp/8/8/8/PPPSSPPP/8/TECDKCET w kq - 0 1",
        board: "standard8x8", piece: "empire",
        firstColor: "Gold", secondColor: "Black",
        pieceRoles: ["k", "d", "t", "c", "e", "p", "s", "q"],
        pieceRoles2: ["k", "q", "r", "b", "n", "p"],
        enPassant: true,
        icon: "♚",
    }),
    ordamirror: new Variant({
        name: "ordamirror", displayName: "orda mirror", tooltip: () => (0, i18n_1._)("Orda Chess variant with two Horde armies. The Falcon replaces the Yurt."),
        startFen: "lhafkahl/8/pppppppp/8/8/PPPPPPPP/8/LHAFKAHL w - - 0 1",
        board: "standard8x8", piece: "ordamirror",
        firstColor: "White", secondColor: "Gold",
        pieceRoles: ["k", "f", "l", "a", "h", "p"],
        icon: "◩",
    }),
    // We support to import/store/analyze some variants
    // but don't want to add them to leaderboard page
    embassy: new Variant({
        name: "embassy", tooltip: () => (0, i18n_1._)("Like Capablanca Chess but with Grand starting setup."),
        startFen: "rnbqkcabnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNBQKCABNR w KQkq - 0 1",
        board: "standard10x8", piece: "capa",
        pieceRoles: ["k", "q", "c", "a", "r", "b", "n", "p"],
        pocketRoles: ["p", "n", "b", "r", "a", "c", "q"],
        enPassant: true, autoQueenable: true,
        icon: "P",
    }),
    gothic: new Variant({
        name: "gothic", tooltip: () => (0, i18n_1._)("Like Capablanca Chess but with a different starting setup."),
        startFen: "rnbqckabnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNBQCKABNR w KQkq - 0 1",
        board: "standard10x8", piece: "capa",
        pieceRoles: ["k", "q", "c", "a", "r", "b", "n", "p"],
        pocketRoles: ["p", "n", "b", "r", "a", "c", "q"],
        enPassant: true, autoQueenable: true,
        icon: "P",
    }),
    gothhouse: new Variant({
        name: "gothhouse", tooltip: () => (0, i18n_1._)("Gothic with Crazyhouse drop rules."),
        startFen: "rnbqckabnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNBQCKABNR[] w KQkq - 0 1",
        board: "standard10x8", piece: "capa",
        pieceRoles: ["k", "q", "c", "a", "r", "b", "n", "p"],
        pocketRoles: ["p", "n", "b", "r", "a", "c", "q"],
        enPassant: true, autoQueenable: true, drop: true,
        icon: "P",
    }),
};
exports.variants = Object.keys(exports.VARIANTS);
const disabledVariants = ["gothic", "gothhouse", "embassy"];
exports.enabledVariants = exports.variants.filter(v => !disabledVariants.includes(v));
const variantGroups = {
    standard: { variants: ["chess", "crazyhouse", "placement", "atomic"] },
    sea: { variants: ["makruk", "makpong", "cambodian", "sittuyin"] },
    shogi: { variants: ["shogi", "minishogi", "kyotoshogi", "dobutsu", "gorogoro", "torishogi"] },
    xiangqi: { variants: ["xiangqi", "manchu", "janggi", "minixiangqi"] },
    fairy: { variants: ["capablanca", "capahouse", "seirawan", "shouse", "grand", "grandhouse", "shako", "shogun", "hoppelpoppel"] },
    army: { variants: ["orda", "synochess", "shinobi", "empire", "ordamirror"] },
};
function variantGroupLabel(group) {
    const groups = {
        standard: (0, i18n_1._)("Standard piece variants"),
        sea: (0, i18n_1._)("Southeast Asian variants"),
        shogi: (0, i18n_1._)("Shogi variants"),
        xiangqi: (0, i18n_1._)("Xiangqi variants"),
        fairy: (0, i18n_1._)("Fairy piece variants"),
        army: (0, i18n_1._)("New Army Variants"),
    };
    return groups[group];
}
function selectVariant(id, selected, onChange, hookInsert) {
    return (0, h_1.h)('select#' + id, {
        props: { name: id },
        on: { change: onChange },
        hook: { insert: hookInsert },
    }, Object.keys(variantGroups).map(g => {
        const group = variantGroups[g];
        return (0, h_1.h)('optgroup', { props: { label: variantGroupLabel(g) } }, group.variants.map(v => {
            const variant = exports.VARIANTS[v];
            return (0, h_1.h)('option', {
                props: { value: v, title: variant.tooltip() },
                attrs: { selected: v === selected },
            }, variant.displayName(false));
        }));
    }));
}
exports.selectVariant = selectVariant;
const handicapKeywords = ["HC", "Handicap", "Odds"];
function isHandicap(name) {
    return handicapKeywords.some(keyword => name.endsWith(keyword));
}
exports.isHandicap = isHandicap;
function hasCastling(variant, color) {
    if (variant.name === 'placement')
        return true;
    const castl = variant.startFen.split(' ')[2];
    if (color === 'white') {
        return castl.includes('KQ');
    }
    else {
        return castl.includes('kq');
    }
}
exports.hasCastling = hasCastling;
function uci2cg(move) {
    return move.replace(/10/g, ":");
}
exports.uci2cg = uci2cg;
function cg2uci(move) {
    return move.replace(/:/g, "10");
}
exports.cg2uci = cg2uci;
// TODO Will be deprecated after WASM Fairy integration
function validFen(variant, fen) {
    const as = variant.alternateStart;
    if (as !== undefined) {
        if (Object.keys(as).some((key) => { return as[key].includes(fen); }))
            return true;
    }
    const variantName = variant.name;
    const startfen = variant.startFen;
    const start = startfen.split(' ');
    const parts = fen.split(' ');
    // Need starting color
    if (parts.length < 2)
        return false;
    // Allowed characters in placement part
    const placement = parts[0];
    const startPlacement = start[0];
    let good = startPlacement + ((variantName === "orda") ? "Hq" : "") + ((variantName === "dobutsu") ? "Hh" : "") + "~+0123456789[]";
    const alien = element => !good.includes(element);
    if (placement.split('').some(alien))
        return false;
    // Brackets paired
    if (lc(placement, '[', false) !== lc(placement, ']', false))
        return false;
    // Split board part and pocket part
    const leftBracketPos = placement.indexOf('[');
    const board = (leftBracketPos === -1) ? placement : placement.slice(0, leftBracketPos);
    //const pocket = placement.slice(leftBracketPos);
    //const startLeftBracketPos = start.indexOf('[');
    //const startBoard = startPlacement.slice(0, startLeftBracketPos);
    //const startPocket = startPlacement.slice(startLeftBracketPos);
    // Convert FEN board to board array
    const toBoardArray = board => {
        const toRowArray = row => {
            const stuffedRow = row.replace('10', '_'.repeat(10)).replace(/\d/g, x => '_'.repeat(parseInt(x)));
            const rowArray = [];
            let promoted = false;
            for (const c of stuffedRow) {
                switch (c) {
                    case '+':
                        promoted = true;
                        break;
                    case '~':
                        rowArray[rowArray.length - 1] = rowArray[rowArray.length - 1] + '~';
                        break;
                    default:
                        if (promoted) {
                            rowArray.push('+' + c);
                            promoted = false;
                        }
                        else
                            rowArray.push(c);
                }
            }
            return rowArray;
        };
        return board.split('/').map(toRowArray);
    };
    const boardArray = toBoardArray(board);
    //const startBoardArray = toBoardArray(startBoard);
    // Correct board size
    const boardHeight = cg.dimensions[variant.geometry].height;
    const boardWidth = cg.dimensions[variant.geometry].width;
    if (boardArray.length !== boardHeight)
        return false;
    if (boardArray.some(row => row.length !== boardWidth))
        return false;
    // Starting colors
    if (parts[1] !== 'b' && parts[1] !== 'w')
        return false;
    // Castling rights (piece virginity)
    good = (variantName === 'seirawan' || variantName === 'shouse') ? 'KQABCDEFGHkqabcdefgh-' : start[2] + "-";
    const wrong = (element) => { good.indexOf(element) === -1; };
    if (parts.length > 2 && variantName !== 'dobutsu') {
        if (parts[2].split('').some(wrong))
            return false;
        // TODO: Checking S-chess960 FEN is tricky
        // Editor and Analysis board needs chess960 checkbox similar to new game dialog first
        if (variantName !== 'seirawan' && variantName !== 'shouse') {
            // Castling right need rooks and king placed in starting square
            // capablanca: "rnabqkbcnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNABQKBCNR w KQkq - 0 1",
            // shako: "c8c/ernbqkbnre/pppppppppp/10/10/10/10/PPPPPPPPPP/ERNBQKBNRE/C8C w KQkq - 0 1",
            const rookPos = {
                K: (variantName === 'shako') ? boardArray[boardHeight - 2][boardWidth - 2] : boardArray[boardHeight - 1][boardWidth - 1],
                Q: (variantName === 'shako') ? boardArray[boardHeight - 2][1] : boardArray[boardHeight - 1][0],
                k: (variantName === 'shako') ? boardArray[1][boardWidth - 2] : boardArray[0][boardWidth - 1],
                q: (variantName === 'shako') ? boardArray[1][1] : boardArray[0][0],
            };
            for (const c of parts[2]) {
                switch (c) {
                    case 'K':
                    case 'Q':
                        if (rookPos[c] !== 'R')
                            return false;
                        // TODO check king position
                        break;
                    case 'k':
                    case 'q':
                        if (rookPos[c] !== 'r')
                            return false;
                        // TODO check king position
                        break;
                    // TODO Column-based right
                }
            }
        }
    }
    // Number of kings
    const king = (variantName === "dobutsu") ? "l" : "k";
    if (lc(placement, king, false) !== 1 || lc(placement, king, true) !== 1)
        return false;
    // Touching kings
    const pieces = (0, fen_1.read)(parts[0]);
    if (variantName !== 'atomic' && touchingKings(pieces))
        return false;
    return true;
}
exports.validFen = validFen;
function diff(a, b) {
    return Math.abs(a - b);
}
function touchingKings(pieces) {
    let wk = 'xx', bk = 'zz';
    Object.keys(pieces).filter(key => pieces[key].role === "king").forEach(key => {
        if (pieces[key].color === 'white')
            wk = key;
        if (pieces[key].color === 'black')
            bk = key;
    });
    const touching = diff(wk.charCodeAt(0), bk.charCodeAt(0)) <= 1 && diff(wk.charCodeAt(1), bk.charCodeAt(1)) <= 1;
    return touching;
}
// pocket part of the FEN (including brackets)
function getPockets(fen) {
    const placement = fen.split(" ")[0];
    let pockets = "";
    const bracketPos = placement.indexOf("[");
    if (bracketPos !== -1)
        pockets = placement.slice(bracketPos);
    return pockets;
}
exports.getPockets = getPockets;
// Get counting information for makruk et al
function getCounting(fen) {
    const parts = fen.split(" ");
    let countingPly = Number(parts[4]);
    if (isNaN(countingPly))
        countingPly = 0;
    let countingLimit = Number(parts[3]);
    if (isNaN(countingLimit))
        countingLimit = 0;
    const board = parts[0];
    const whitePieces = (board.match(/[A-Z]/g) || []).length;
    const blackPieces = (board.match(/[a-z]/g) || []).length;
    const countingType = (countingLimit === 0) ? 'none' : ((whitePieces > 1 && blackPieces > 1) ? 'board' : 'piece');
    const sideToMove = parts[1];
    const opponent = (sideToMove === 'w') ? 'b' : 'w';
    const countingSide = (countingType === 'none' || countingPly === 0) ? '' : ((countingPly % 2 === 0) ? sideToMove : opponent);
    return [countingPly, countingLimit, countingSide, countingType];
}
exports.getCounting = getCounting;
// Get janggi material points
function getJanggiPoints(board) {
    let choPoint = 0;
    let hanPoint = 1.5;
    for (const c of board) {
        switch (c) {
            case 'P':
                choPoint += 2;
                break;
            case 'A':
            case 'B':
                choPoint += 3;
                break;
            case 'N':
                choPoint += 5;
                break;
            case 'C':
                choPoint += 7;
                break;
            case 'R':
                choPoint += 13;
                break;
            case 'p':
                hanPoint += 2;
                break;
            case 'a':
            case 'b':
                hanPoint += 3;
                break;
            case 'n':
                hanPoint += 5;
                break;
            case 'c':
                hanPoint += 7;
                break;
            case 'r':
                hanPoint += 13;
                break;
        }
    }
    return [choPoint, hanPoint];
}
exports.getJanggiPoints = getJanggiPoints;
function unpromotedRole(variant, piece) {
    if (piece.promoted) {
        switch (variant.promotion) {
            case 'shogi':
            case 'kyoto':
                return piece.role.slice(1);
            default:
                return 'p-piece';
        }
    }
    else {
        return piece.role;
    }
}
exports.unpromotedRole = unpromotedRole;
function dropIsValid(dests, role, key) {
    const drops = dests[role2san(role) + "@"];
    if (drops === undefined || drops === null)
        return false;
    return drops.includes(key);
}
exports.dropIsValid = dropIsValid;
// Convert a list of moves to chessground destination
function moveDests(legalMoves) {
    const dests = {};
    legalMoves.map(uci2cg).forEach(move => {
        const orig = move.split(0, 2);
        const dest = move.split(2, 4);
        if (orig in dests)
            dests[orig].push(dest);
        else
            dests[orig] = [dest];
    });
    return dests;
}
exports.moveDests = moveDests;
// Convert a move to array of squares for last move highlight
function uci2array(move) {
    const cgMove = uci2cg(move);
    return cgMove.includes('@') ? [cgMove.slice(2, 4)] : [cgMove.slice(0, 2), cgMove.slice(2, 4)];
}
exports.uci2array = uci2array;
function role2letter(role) {
    const letterPart = role.slice(0, role.indexOf('-'));
    return (letterPart.length > 1) ? letterPart.replace('p', '+') : letterPart;
}
exports.role2letter = role2letter;
function letter2role(letter) {
    return (letter.replace('+', 'p') + '-piece');
}
exports.letter2role = letter2role;
function role2san(role) {
    return role2letter(role).toUpperCase();
}
exports.role2san = role2san;
// Use cases
// 1. determine piece role from analysis suggested (SAN) drop moves
// 2. determine promotion piece roles from possible (UCI) promotion moves in grand, grandhouse, shako
function san2role(letter) {
    return letter2role(letter.toLowerCase());
}
exports.san2role = san2role;
// Count given letter occurences in a string
function lc(str, letter, uppercase) {
    if (uppercase)
        letter = letter.toUpperCase();
    else
        letter = letter.toLowerCase();
    let letterCount = 0;
    for (let position = 0; position < str.length; position++)
        if (str.charAt(position) === letter)
            letterCount += 1;
    return letterCount;
}
exports.lc = lc;

},{"./i18n":18,"chessgroundx/fen":62,"chessgroundx/types":68,"chessgroundx/util":69,"snabbdom/h":85}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyTextToClipboard = void 0;
// https://stackoverflow.com/questions/400212/how-do-i-copy-to-the-clipboard-in-javascript
function copyTextToClipboard(text) {
    const textArea = document.createElement("textarea");
    //
    // *** This styling is an extra step which is likely not required. ***
    //
    // Why is it here? To ensure:
    // 1. the element is able to have focus and selection.
    // 2. if element was to flash render it has minimal visual impact.
    // 3. less flakyness with selection and copying which **might** occur if
    //    the textarea element is not visible.
    //
    // The likelihood is the element won't even render, not even a
    // flash, so some of these are just precautions. However in
    // Internet Explorer the element is visible whilst the popup
    // box asking the user for permission for the web page to
    // copy to the clipboard.
    //
    // Place in top-left corner of screen regardless of scroll position.
    textArea.style.position = 'fixed';
    textArea.style.top = '0';
    textArea.style.left = '0';
    // Ensure it has a small width and height. Setting to 1px / 1em
    // doesn't work as this gives a negative w/h on some browsers.
    textArea.style.width = '2em';
    textArea.style.height = '2em';
    // We don't need padding, reducing the size if it does flash render.
    textArea.style.padding = '0';
    // Clean up any borders.
    textArea.style.border = 'none';
    textArea.style.outline = 'none';
    textArea.style.boxShadow = 'none';
    // Avoid flash of white box if rendered for any reason.
    textArea.style.background = 'transparent';
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
        const successful = document.execCommand('copy');
        const msg = successful ? 'successful' : 'unsuccessful';
        console.log('Copying text command was ' + msg);
    }
    catch (err) {
        console.log('Oops, unable to copy');
    }
    document.body.removeChild(textArea);
}
exports.copyTextToClipboard = copyTextToClipboard;

},{}],10:[function(require,module,exports){
"use strict";
// https://stackoverflow.com/questions/20618355/the-simplest-possible-javascript-countdown-timer
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Clock = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
const h_1 = require("snabbdom/h");
const sound_1 = require("./sound");
const HURRY = 10000;
class Clock {
    // game baseTime (min) and increment (sec)
    constructor(baseTime, increment, byoyomiPeriod, el, id) {
        this.duration = baseTime * 1000 * 60;
        this.increment = increment * 1000;
        this.granularity = 500;
        this.running = false;
        this.connecting = false;
        this.timeout = null;
        this.startTime = 0;
        this.tickCallbacks = [];
        this.flagCallback = null;
        this.byoyomiCallback = null;
        this.el = el;
        this.id = id;
        this.overtime = false;
        this.byoyomi = byoyomiPeriod > 0;
        this.byoyomiPeriod = byoyomiPeriod;
        this.hurry = false;
        this.ticks = [false, false, false, false, false, false, false, false, false, false];
        this.renderTime(this.duration);
    }
    start(duration = 0) {
        if (this.running)
            return;
        if (duration !== 0)
            this.duration = duration;
        this.running = true;
        this.startTime = Date.now();
        const timer = () => {
            const diff = this.duration - (Date.now() - this.startTime);
            if (diff <= HURRY && !this.hurry && !this.byoyomi) {
                this.hurry = true;
                sound_1.sound.lowTime();
            }
            if (this.byoyomi && this.byoyomiPeriod === 0) {
                for (let i = 0; i < 10; i++) {
                    if (diff <= 1000 * (i + 1) && !this.ticks[i]) {
                        this.ticks[i] = true;
                        sound_1.sound.tick();
                        break;
                    }
                }
            }
            if (diff <= 0) {
                if (this.byoyomi && this.byoyomiPeriod > 0) {
                    sound_1.sound.lowTime();
                    this.overtime = true;
                    this.byoyomiPeriod -= 1;
                    this.ticks = [false, false, false, false, false, false, false, false, false, false];
                    if (this.granularity === 100 && this.increment > HURRY)
                        this.granularity = 500;
                    this.duration = this.increment;
                    this.startTime = Date.now();
                    if (this.byoyomiCallback !== null)
                        this.byoyomiCallback();
                }
                else {
                    if (this.flagCallback !== null)
                        this.flagCallback();
                    this.pause(false);
                    return;
                }
            }
            this.timeout = setTimeout(timer, this.granularity);
            this.tickCallbacks.forEach(function (callback) {
                callback.call(this, diff);
            }, this);
        };
        timer();
    }
    onTick(callback) {
        if (typeof callback === 'function') {
            this.tickCallbacks.push(callback);
        }
        return this;
    }
    onFlag(callback) {
        if (typeof callback === 'function') {
            this.pause(false);
            this.flagCallback = callback;
        }
        return this;
    }
    onByoyomi(callback) {
        if (typeof callback === 'function') {
            this.byoyomiCallback = callback;
        }
        return this;
    }
    pause(withIncrement) {
        if (!this.running)
            return;
        this.running = false;
        if (this.timeout)
            clearTimeout(this.timeout);
        this.timeout = null;
        this.duration -= Date.now() - this.startTime;
        if (withIncrement && this.increment) {
            if (this.byoyomi) {
                if (this.overtime) {
                    this.duration = this.increment;
                    this.ticks = [false, false, false, false, false, false, false, false, false, false];
                }
            }
            else {
                this.duration += this.increment;
                this.hurry = (this.duration < HURRY);
            }
        }
        this.renderTime(this.duration);
    }
    setTime(millis) {
        this.duration = millis;
        this.renderTime(this.duration);
    }
    printTime(millis) {
        let minutes = Math.floor(millis / 60000);
        let seconds = (millis % 60000) / 1000;
        let secs, mins;
        if (Math.floor(seconds) == 60) {
            minutes++;
            seconds = 0;
        }
        minutes = Math.max(0, minutes);
        seconds = Math.max(0, seconds);
        if (millis < HURRY && this.byoyomiPeriod === 0)
            secs = seconds.toFixed(1);
        else
            secs = Math.floor(seconds).toString();
        mins = (minutes < 10 ? "0" : "") + minutes;
        secs = (seconds < 10 && secs.length < 4 ? "0" : "") + secs;
        return {
            minutes: mins,
            seconds: secs,
        };
    }
    view(time) {
        const printed = this.printTime(time);
        const millis = new Date(time).getUTCMilliseconds();
        return (0, h_1.h)('div#' + this.id, [
            (0, h_1.h)('div.clock', {
                class: {
                    running: this.running,
                    hurry: time < HURRY && this.byoyomiPeriod === 0,
                    connecting: this.connecting,
                    overtime: this.overtime,
                },
            }, [
                (0, h_1.h)('div.clock-time.min', printed.minutes),
                (0, h_1.h)('div.clock-sep', { class: { low: millis < 500 } }, ':'),
                (0, h_1.h)('div.clock-time.sec', printed.seconds),
                (0, h_1.h)('div.clock-time.byo', { class: { byoyomi: (this.byoyomiPeriod > 0 && this.increment > 0) } }, `+${this.increment / 1000}s` + ((this.byoyomiPeriod > 1) ? ` (x${this.byoyomiPeriod})` : "")),
            ]),
        ]);
    }
    renderTime(time) {
        if (this.granularity > 100 && time < HURRY)
            this.granularity = 100;
        this.el = patch(this.el, this.view(time));
    }
}
exports.Clock = Clock;

},{"./sound":45,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91}],11:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.crosstableView = void 0;
const h_1 = __importDefault(require("snabbdom/h"));
function crosstableView(ctable, gameId) {
    const s1 = ctable.s1, s2 = ctable.s2, games = ctable.r;
    let rows;
    if (games.length < 20) {
        rows = [(0, h_1.default)('fill')];
    }
    else {
        rows = [];
    }
    rows = rows.concat(games.map(game => {
        const ref = game.slice(0, -1);
        let r1, r2;
        switch (game.slice(-1)) {
            case '+':
                r1 = (0, h_1.default)('a.info-result.win', { attrs: { href: '/' + ref } }, '1');
                r2 = (0, h_1.default)('a.info-result.lose', { attrs: { href: '/' + ref } }, '0');
                break;
            case '-':
                r1 = (0, h_1.default)('a.info-result.lose', { attrs: { href: '/' + ref } }, '0');
                r2 = (0, h_1.default)('a.info-result.win', { attrs: { href: '/' + ref } }, '1');
                break;
            default:
                r1 = (0, h_1.default)('a.info-result.draw', { attrs: { href: '/' + ref } }, '½');
                r2 = (0, h_1.default)('a.info-result.draw', { attrs: { href: '/' + ref } }, '½');
        }
        return (0, h_1.default)('povs', { class: { current: gameId === ref } }, [r1, r2]);
    }));
    const names = ctable._id.split('/');
    const p1 = (0, h_1.default)('a', { attrs: { href: '/@/' + names[0] } }, names[0]);
    const p2 = (0, h_1.default)('a', { attrs: { href: '/@/' + names[1] } }, names[1]);
    rows.push((0, h_1.default)('div.ct-users', [p1, p2]));
    let lt1, lt2, half;
    half = (s1 % 10 === 5) ? '½' : '';
    lt1 = (s1 === 5) ? '' : Math.floor(s1 / 10);
    lt2 = (s2 === 5) ? '' : Math.floor(s2 / 10);
    if (s1 === s2) {
        lt1 = lt2 = (0, h_1.default)('span.info-result', lt1 + half);
    }
    else if (s1 > s2) {
        lt1 = (0, h_1.default)('span.info-result.win', lt1 + half);
        lt2 = (0, h_1.default)('span.info-result.lose', lt2 + half);
    }
    else {
        lt1 = (0, h_1.default)('span.info-result.lose', lt1 + half);
        lt2 = (0, h_1.default)('span.info-result.win', lt2 + half);
    }
    rows.push((0, h_1.default)('div.ct-score', [lt1, lt2]));
    return (0, h_1.default)('div#ctable-container', [(0, h_1.default)('div.crosstable', rows)]);
}
exports.crosstableView = crosstableView;

},{"snabbdom/h":85}],12:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeClock = exports.renderTimeago = exports.timeago = exports.localeOptions = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
const h_1 = __importDefault(require("snabbdom/h"));
const i18n_1 = require("./i18n");
exports.localeOptions = {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
};
function timeago(date) {
    const TZdate = (new Date(date)).getTime();
    const maxLength = { second: 60, minute: 60, hour: 24, day: 7, week: 4.35, month: 12, year: 10000 };
    let val, inTheFuture;
    if (Date.now() >= TZdate) {
        val = (Date.now() - TZdate) / 1000;
        inTheFuture = false;
    }
    else {
        val = (TZdate - Date.now()) / 1000;
        inTheFuture = true;
    }
    for (const unit in maxLength) {
        if (Math.floor(val / maxLength[unit]) === 0) {
            const result = Math.floor(val);
            switch (unit) {
                case "year":
                    return inTheFuture ? (0, i18n_1.ngettext)("in %1 year", "in %1 years", result) : (0, i18n_1.ngettext)("%1 year ago", "%1 years ago", result);
                case "month":
                    return inTheFuture ? (0, i18n_1.ngettext)("in %1 month", "in %1 months", result) : (0, i18n_1.ngettext)("%1 month ago", "%1 months ago", result);
                case "week":
                    return inTheFuture ? (0, i18n_1.ngettext)("in %1 week", "in %1 weeks", result) : (0, i18n_1.ngettext)("%1 week ago", "%1 weeks ago", result);
                case "day":
                    return inTheFuture ? (0, i18n_1.ngettext)("in %1 day", "in %1 days", result) : (0, i18n_1.ngettext)("%1 day ago", "%1 days ago", result);
                case "hour":
                    return inTheFuture ? (0, i18n_1.ngettext)("in %1 hour", "in %1 hours", result) : (0, i18n_1.ngettext)("%1 hour ago", "%1 hours ago", result);
                case "minute":
                    return inTheFuture ? (0, i18n_1.ngettext)("in %1 minute", "in %1 minutes", result) : (0, i18n_1.ngettext)("%1 minute ago", "%1 minutes ago", result);
                case "second":
                    return inTheFuture ? (0, i18n_1.ngettext)("in %1 second", "in %1 seconds", result) : (0, i18n_1.ngettext)("%1 second ago", "%1 seconds ago", result);
            }
        }
        val = val / maxLength[unit];
    }
    return '';
}
exports.timeago = timeago;
function renderTimeago() {
    const els = document.getElementsByTagName("info-date");
    Array.from(els).forEach((el) => { el.innerHTML = timeago(el.getAttribute('timestamp')); });
    setTimeout(renderTimeago, 1200);
}
exports.renderTimeago = renderTimeago;
function getTimeRemaining(endtime) {
    const totalSecs = endtime - Date.now();
    const seconds = Math.floor((totalSecs / 1000) % 60);
    const minutes = Math.floor((totalSecs / 1000 / 60) % 60);
    const hours = Math.floor((totalSecs / (1000 * 60 * 60)) % 24);
    const days = Math.floor(totalSecs / (1000 * 60 * 60 * 24));
    // console.log('getTimeRemaining()', endtime, '-', totalSecs, '-', days, hours, minutes, seconds);
    return { totalSecs, days, hours, minutes, seconds };
}
function initializeClock(ctrl) {
    // console.log('initializeClock', ctrl.tournamentStatus, ctrl.secondsToStart, ctrl.secondsToFinish);
    if ('finished|archived'.includes(ctrl.tournamentStatus))
        return;
    let endtime, timeinterval;
    if (ctrl.secondsToFinish > 0) {
        endtime = Date.now() + ctrl.secondsToFinish * 1000;
        ctrl.clockdiv = patch(ctrl.clockdiv, (0, h_1.default)('div#clockdiv', [(0, h_1.default)('span#clock')]));
    }
    else {
        endtime = Date.now() + ctrl.secondsToStart * 1000;
        const remaining = getTimeRemaining(endtime);
        if (remaining.days > 0) {
            const startDate = new Date(ctrl.model["date"]);
            ctrl.clockdiv = patch(ctrl.clockdiv, (0, h_1.default)('div#clockdiv', [(0, h_1.default)('info-date', { attrs: { 'timestamp': startDate.toLocaleString("default", exports.localeOptions) } })]));
        }
        else {
            ctrl.clockdiv = patch(ctrl.clockdiv, (0, h_1.default)('div#clockdiv', [(0, h_1.default)('span.shy', (0, i18n_1._)('STARTING IN')), (0, h_1.default)('span#clock')]));
        }
    }
    const clock = document.getElementById('clock');
    function updateClock() {
        const t = getTimeRemaining(endtime);
        clock.innerHTML = ('0' + t.hours).slice(-2) + ':' + ('0' + t.minutes).slice(-2) + ':' + ('0' + t.seconds).slice(-2);
        if (t.totalSecs <= 1000 && timeinterval !== undefined) {
            clearInterval(timeinterval);
            ctrl.clockdiv = patch(ctrl.clockdiv, (0, h_1.default)('div#clockdiv'));
        }
    }
    updateClock();
    timeinterval = setInterval(updateClock, 1000);
}
exports.initializeClock = initializeClock;

},{"./i18n":18,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bind = exports.changePieceCSS = exports.changeBoardCSS = exports.setCookie = exports.getCookie = exports.debounce = exports.getPieceImageUrl = exports.getDocumentData = void 0;
function getDocumentData(name) {
    const elm = document.getElementById('pychess-variants');
    if (elm) {
        return elm.getAttribute('data-' + name.toLowerCase());
    }
    else {
        return "";
    }
}
exports.getDocumentData = getDocumentData;
function getPieceImageUrl(role, color, side) {
    // Analysis drop move suggestion rendering needs piece images urls in chessground
    // We can use current variant .css to find appropriate images.
    const el = document.querySelector(`piece.${color}.${role}.${side}`);
    if (el) {
        const image = window.getComputedStyle(el, null).getPropertyValue("background-image");
        if (image) {
            const url = image.split('"')[1];
            if (url)
                return url.slice(url.indexOf('/static'));
        }
    }
    // In Kyoto Shogi not all droppable pieces are rendered in the pockets
    // because they may be dropped with flipped side as well. To solve this problem
    // we will construct piece image url from unprotmoted piece urls here.
    const kyotoPromotedPieceRoles = ['pp-piece', 'pl-piece', 'pn-piece', 'ps-piece'];
    const idx = kyotoPromotedPieceRoles.indexOf(role);
    if (idx !== -1) {
        const unpromoted = getPieceImageUrl(role.slice(1), color, side);
        const kyotoPromotedPieceNames = ['HI', 'TO', 'KI', 'KA'];
        return unpromoted.slice(0, unpromoted.lastIndexOf('/') + 2) + kyotoPromotedPieceNames[idx] + '.svg';
    }
    return '/static/images/pieces/merida/';
}
exports.getPieceImageUrl = getPieceImageUrl;
function debounce(callback, wait) {
    let timeout;
    return function () {
        const context = this, args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => callback.apply(context, args), wait);
    };
}
exports.debounce = debounce;
function getCookie(name) {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
        const pair = cookies[i].trim().split('=');
        if (pair[0] == name)
            return pair[1];
    }
    return "";
}
exports.getCookie = getCookie;
function setCookie(cname, cvalue, exdays) {
    const d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    const expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
}
exports.setCookie = setCookie;
function changeCSS(cssLinkIndex, cssFile) {
    document.getElementsByTagName("link").item(cssLinkIndex).setAttribute("href", cssFile);
}
// css file index in templates/base.html
const BOARD_CSS_IDX = 1;
const PIECE_CSS_IDX = 2;
function changeBoardCSS(assetUrl, family, cssFile) {
    const sheet = document.styleSheets[BOARD_CSS_IDX];
    const cssRules = sheet.cssRules;
    for (let i = 0; i < cssRules.length; i++) {
        const rule = cssRules[i];
        if (!(rule instanceof CSSStyleRule)) {
            continue;
        }
        if (rule.selectorText === `.${family} .cg-wrap`) {
            // console.log("changeBoardCSS", family, cssFile, i)
            sheet.deleteRule(i);
            const newRule = `.${family} .cg-wrap {background-image: url(${assetUrl}/images/board/${cssFile})}`;
            // console.log(newRule);
            sheet.insertRule(newRule, i);
            break;
        }
    }
}
exports.changeBoardCSS = changeBoardCSS;
function changePieceCSS(assetUrl, family, cssFile) {
    let cssLinkIndex = PIECE_CSS_IDX;
    switch (family) {
        case "standard": break;
        case "seirawan":
            cssLinkIndex += 1;
            break;
        case "makruk":
            cssLinkIndex += 2;
            break;
        case "sittuyin":
            cssLinkIndex += 3;
            break;
        case "shogi":
            cssLinkIndex += 4;
            break;
        case "kyoto":
            cssLinkIndex += 5;
            break;
        case "tori":
            cssLinkIndex += 6;
            break;
        case "xiangqi":
            cssLinkIndex += 7;
            break;
        case "capa":
            cssLinkIndex += 8;
            break;
        case "shako":
            cssLinkIndex += 9;
            break;
        case "shogun":
            cssLinkIndex += 10;
            break;
        case "janggi":
            cssLinkIndex += 11;
            break;
        case "orda":
            cssLinkIndex += 12;
            break;
        case "synochess":
            cssLinkIndex += 13;
            break;
        case "hoppel":
            cssLinkIndex += 14;
            break;
        case "dobutsu":
            cssLinkIndex += 15;
            break;
        case "shinobi":
            cssLinkIndex += 16;
            break;
        case "empire":
            cssLinkIndex += 17;
            break;
        case "ordamirror":
            cssLinkIndex += 18;
            break;
        default: throw "Unknown piece family " + family;
    }
    const newUrl = `${assetUrl}/piece/${family}/${cssFile}.css`;
    // console.log("changePieceCSS", family, cssFile, newUrl)
    changeCSS(cssLinkIndex, newUrl);
}
exports.changePieceCSS = changePieceCSS;
function bind(eventName, f, redraw) {
    return {
        insert(vnode) {
            vnode.elm.addEventListener(eventName, e => {
                const res = f(e);
                if (redraw)
                    redraw();
                return res;
            });
        }
    };
}
exports.bind = bind;

},{}],14:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.editorView = void 0;
const h_1 = __importDefault(require("snabbdom/h"));
const i18n_1 = require("./i18n");
const chess_1 = require("./chess");
const editorCtrl_1 = require("./editorCtrl");
function runEditor(vnode, model) {
    const el = vnode.elm;
    const ctrl = new editorCtrl_1.EditorController(el, model);
    const cg = ctrl.chessground;
    window['cg'] = cg;
}
function editorView(model) {
    const setVariant = (isInput) => {
        let e;
        e = document.getElementById('variant');
        const variant = e.options[e.selectedIndex].value;
        if (isInput)
            window.location.assign('/editor/' + variant);
    };
    const vVariant = model.variant || "chess";
    const variant = chess_1.VARIANTS[vVariant];
    return [
        (0, h_1.default)('div.editor-app', [
            (0, h_1.default)('aside.sidebar-first', [
                (0, h_1.default)('div.container', [
                    (0, h_1.default)('div', [
                        (0, h_1.default)('label', { attrs: { for: "variant" } }, (0, i18n_1._)("Variant")),
                        (0, chess_1.selectVariant)("variant", vVariant, () => setVariant(true), () => setVariant(false)),
                    ]),
                ])
            ]),
            (0, h_1.default)('div.pocket-wrapper.top', [
                (0, h_1.default)('div.' + variant.piece + '.' + model["variant"], [
                    (0, h_1.default)('div.cg-wrap.pocket', [
                        (0, h_1.default)('div#pieces0'),
                    ]),
                ]),
            ]),
            (0, h_1.default)('selection#mainboard.' + variant.board + '.' + variant.piece, [
                (0, h_1.default)('div.cg-wrap.' + variant.cg, { hook: { insert: (vnode) => runEditor(vnode, model) },
                }),
            ]),
            (0, h_1.default)('div.pocket-wrapper.bot', [
                (0, h_1.default)('div.' + variant.piece + '.' + model["variant"], [
                    (0, h_1.default)('div.cg-wrap.pocket', [
                        (0, h_1.default)('div#pieces1'),
                    ]),
                ]),
            ]),
            (0, h_1.default)('div.pocket-top', [
                (0, h_1.default)('div.' + variant.piece + '.' + model["variant"], [
                    (0, h_1.default)('div.cg-wrap.pocket', [
                        (0, h_1.default)('div#pocket0'),
                    ]),
                ]),
            ]),
            (0, h_1.default)('div#editor-button-container'),
            (0, h_1.default)('div.pocket-bot', [
                (0, h_1.default)('div.' + variant.piece + '.' + model["variant"], [
                    (0, h_1.default)('div.cg-wrap.pocket', [
                        (0, h_1.default)('div#pocket1'),
                    ]),
                ]),
            ]),
            (0, h_1.default)('under-board', [
                (0, h_1.default)('input#fen'),
            ]),
        ]),
    ];
}
exports.editorView = editorView;

},{"./chess":8,"./editorCtrl":15,"./i18n":18,"snabbdom/h":85}],15:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EditorController = void 0;
const ffish_js_1 = __importDefault(require("../static/ffish.js"));
const h_1 = __importDefault(require("snabbdom/h"));
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
const chessgroundx_1 = require("chessgroundx");
const i18n_1 = require("./i18n");
const chess_1 = require("./chess");
const boardSettings_1 = require("./boardSettings");
const pieces_1 = require("./pieces");
const pocket_1 = require("./pocket");
const png_1 = require("./png");
const profile_1 = require("./profile");
const variantsIni_1 = require("./variantsIni");
class EditorController {
    constructor(el, model) {
        this.onChangeTurn = (e) => {
            this.parts[1] = (e.target.value === 'white') ? 'w' : 'b';
            this.onChange();
        };
        this.onChangeCastl = () => {
            const castlings = {
                'wOO': 'K',
                'wOOO': 'Q',
                'bOO': 'k',
                'bOOO': 'q',
            };
            const castl = [];
            for (const key in castlings) {
                const el = document.getElementById(key);
                // There are no black castlings in asymmetric variants!
                if (el !== null && el.checked) {
                    castl.push(castlings[key]);
                }
            }
            let gatings = '';
            if (this.parts.length > 2) {
                const gatingLetters = this.parts[2].match(/[A-H,a-h]/g);
                if (gatingLetters !== null)
                    gatings = gatingLetters.join('');
            }
            this.parts[2] = castl.join('') + gatings;
            if (this.parts[2].length === 0)
                this.parts[2] = '-';
            this.onChange();
        };
        // Remove accidentally selected leading spaces from FEN (mostly may happen on mobile)
        this.onPasteFen = (e) => {
            const data = e.clipboardData.getData('text');
            e.target.value = data.trim();
            e.preventDefault();
            this.setFen(true);
        };
        this.validFen = () => {
            const fen = document.getElementById('fen').value;
            const valid = (0, chess_1.validFen)(this.variant, fen);
            const ff = this.ffish.validateFen(fen, this.variant.name);
            const ffValid = (ff === 1) || (this.variant.gate && ff === -5);
            return valid && ffValid;
        };
        this.setInvalid = (invalid) => {
            const analysis = document.getElementById('analysis');
            analysis.classList.toggle('disabled', invalid);
            const challenge = document.getElementById('challengeAI');
            challenge.classList.toggle('disabled', invalid || this.anon);
            const e = document.getElementById('fen');
            e.setCustomValidity(invalid ? (0, i18n_1._)('Invalid FEN') : '');
        };
        this.setStartFen = () => {
            const e = document.getElementById('fen');
            e.value = this.startfen;
            this.setFen(true);
        };
        this.setEmptyFen = () => {
            const w = this.variant.boardWidth;
            const h = this.variant.boardHeight;
            const empty_fen = (String(w) + '/').repeat(h);
            this.pocketsPart = (this.hasPockets) ? '[]' : '';
            this.parts[0] = empty_fen + this.pocketsPart;
            this.parts[1] = 'w';
            if (this.parts.length > 2)
                this.parts[2] = '-';
            const e = document.getElementById('fen');
            e.value = this.parts.join(' ');
            this.setFen(true);
        };
        this.setAnalysisFen = () => {
            const fen = this.parts.join('_').replace(/\+/g, '.');
            window.location.assign(this.model["home"] + '/analysis/' + this.model["variant"] + '?fen=' + fen);
        };
        this.setChallengeFen = () => {
            const fen = this.parts.join('_').replace(/\+/g, '.');
            window.location.assign(this.model["home"] + '/@/Fairy-Stockfish/challenge/' + this.model["variant"] + '?fen=' + fen);
        };
        this.setFen = (isInput) => {
            const fen = document.getElementById('fen');
            if (isInput) {
                this.parts = fen.value.split(' ');
                this.pocketsPart = (this.hasPockets) ? (0, chess_1.getPockets)(fen.value) : '';
                this.chessground.set({ fen: fen.value });
                this.setInvalid(!this.validFen());
                if (this.parts.length > 1) {
                    const turn = document.getElementById('turn');
                    turn.value = (this.parts[1] === 'w') ? 'white' : 'black';
                }
                this.fullfen = fen.value;
                if (this.hasPockets) {
                    (0, pocket_1.updatePockets)(this, this.vpocket0, this.vpocket1);
                }
                if ((0, chess_1.hasCastling)(this.variant, 'white')) {
                    if (this.parts.length >= 3) {
                        const castlings = {
                            'K': 'wOO',
                            'Q': 'wOOO',
                            'k': 'bOO',
                            'q': 'bOOO',
                        };
                        for (const key in castlings) {
                            const el = document.getElementById(castlings[key]);
                            // There are no black castlings in asymmetric variants!
                            if (el !== null)
                                el.checked = this.parts[2].includes(key);
                        }
                    }
                }
            }
            else {
                fen.value = this.startfen;
            }
        };
        this.onChange = () => {
            // onChange() will get then set and validate FEN from chessground pieces
            this.chessground.set({ lastMove: [] });
            this.pocketsPart = this.hasPockets ? (0, pocket_1.pockets2str)(this) : "";
            this.parts[0] = this.chessground.getFen() + this.pocketsPart;
            const e = document.getElementById('fen');
            e.value = this.parts.join(' ');
            this.setInvalid(!this.validFen());
        };
        this.model = model;
        this.variant = chess_1.VARIANTS[model["variant"]];
        this.startfen = model["fen"];
        this.flip = false;
        this.anon = model["anon"] === 'True';
        this.parts = this.startfen.split(" ");
        this.castling = this.parts.length > 2 ? this.parts[2] : '';
        this.fullfen = this.startfen;
        this.hasPockets = this.variant.pocket;
        // pocket part of the FEN (including brackets)
        this.pocketsPart = (this.hasPockets) ? (0, chess_1.getPockets)(this.startfen) : '';
        this.mycolor = 'white';
        this.oppcolor = 'black';
        this.chessground = (0, chessgroundx_1.Chessground)(el, {
            fen: this.parts[0],
            autoCastle: false,
            variant: this.variant.name,
            geometry: this.variant.geometry,
            notation: (this.variant.name === 'janggi') ? 6 /* JANGGI */ : 0 /* DEFAULT */,
            orientation: this.mycolor,
            movable: {
                free: true,
            },
            events: {
                change: this.onChange,
            },
            selectable: {
                enabled: false
            },
            draggable: {
                deleteOnDropOff: true,
            },
        });
        boardSettings_1.boardSettings.ctrl = this;
        const boardFamily = this.variant.board;
        const pieceFamily = this.variant.piece;
        boardSettings_1.boardSettings.updateBoardStyle(boardFamily);
        boardSettings_1.boardSettings.updatePieceStyle(pieceFamily);
        boardSettings_1.boardSettings.updateZoom(boardFamily);
        // initialize pieces
        const pieces0 = document.getElementById('pieces0');
        const pieces1 = document.getElementById('pieces1');
        (0, pieces_1.iniPieces)(this, pieces0, pieces1);
        // initialize pockets
        if (this.hasPockets) {
            const pocket0 = document.getElementById('pocket0');
            const pocket1 = document.getElementById('pocket1');
            (0, pocket_1.updatePockets)(this, pocket0, pocket1);
        }
        const e = document.getElementById('fen');
        this.vfen = patch(e, (0, h_1.default)('input#fen', {
            props: { name: 'fen', value: model["fen"] },
            on: { input: () => this.setFen(true), paste: (e) => this.onPasteFen(e) },
            hook: { insert: () => this.setFen(false) },
        }));
        //const dataIcon = VARIANTS[this.variant].icon(false);
        const dataIcon = 'icon-' + this.variant.name;
        const container = document.getElementById('editor-button-container');
        const firstColor = (0, profile_1.colorNames)(this.variant.firstColor);
        const secondColor = (0, profile_1.colorNames)(this.variant.secondColor);
        if (container !== null) {
            const buttons = [
                (0, h_1.default)('div#turn-block', [
                    (0, h_1.default)('select#turn', {
                        props: { name: "turn" },
                        on: { change: (e) => this.onChangeTurn(e) },
                    }, [
                        (0, h_1.default)('option', { props: { value: 'white' } }, (0, i18n_1._)('%1 to play', firstColor)),
                        (0, h_1.default)('option', { props: { value: 'black' } }, (0, i18n_1._)('%1 to play', secondColor)),
                    ]),
                    (!(0, chess_1.hasCastling)(this.variant, 'white')) ? '' :
                        (0, h_1.default)('strong', (0, i18n_1._)("Castling")),
                    (!(0, chess_1.hasCastling)(this.variant, 'white')) ? '' :
                        (0, h_1.default)('div.castling', [
                            (0, h_1.default)('label.OO', { attrs: { for: "wOO" } }, (0, i18n_1._)("White") + " O-O"),
                            (0, h_1.default)('input#wOO', {
                                props: { name: "wOO", type: "checkbox" },
                                attrs: { checked: this.parts[2].includes('K') },
                                on: { change: () => this.onChangeCastl() },
                            }),
                            (0, h_1.default)('label.OOO', { attrs: { for: "wOOO" } }, "O-O-O"),
                            (0, h_1.default)('input#wOOO', {
                                props: { name: "wOOO", type: "checkbox" },
                                attrs: { checked: this.parts[2].includes('Q') },
                                on: { change: () => this.onChangeCastl() },
                            }),
                        ]),
                    (!(0, chess_1.hasCastling)(this.variant, 'black')) ? '' :
                        (0, h_1.default)('div.castling', [
                            (0, h_1.default)('label.OO', { attrs: { for: "bOO" } }, (0, i18n_1._)("Black") + " O-O"),
                            (0, h_1.default)('input#bOO', {
                                props: { name: "bOO", type: "checkbox" },
                                attrs: { checked: this.parts[2].includes('k') },
                                on: { change: () => this.onChangeCastl() },
                            }),
                            (0, h_1.default)('label.OOO', { attrs: { for: "bOOO" } }, "O-O-O"),
                            (0, h_1.default)('input#bOOO', {
                                props: { name: "bOOO", type: "checkbox" },
                                attrs: { checked: this.parts[2].includes('q') },
                                on: { change: () => this.onChangeCastl() },
                            }),
                        ]),
                ]),
                (0, h_1.default)('a#clear.i-pgn', { on: { click: () => this.setEmptyFen() } }, [
                    (0, h_1.default)('div', { class: { "icon": true, "icon-trash-o": true } }, (0, i18n_1._)('CLEAR BOARD'))
                ]),
                (0, h_1.default)('a#start.i-pgn', { on: { click: () => this.setStartFen() } }, [
                    (0, h_1.default)('div', { class: { "icon": true, [dataIcon]: true } }, (0, i18n_1._)('STARTING POSITION'))
                ]),
                (0, h_1.default)('a#analysis.i-pgn', { on: { click: () => this.setAnalysisFen() } }, [
                    (0, h_1.default)('div', { class: { "icon": true, "icon-microscope": true } }, (0, i18n_1._)('ANALYSIS BOARD'))
                ]),
                (0, h_1.default)('a#challengeAI.i-pgn', { on: { click: () => this.setChallengeFen() } }, [
                    (0, h_1.default)('div', { class: { "icon": true, "icon-bot": true } }, (0, i18n_1._)('PLAY WITH MACHINE') + ((model["anon"] === 'True') ? (0, i18n_1._)(' (must be signed in)') : ''))
                ]),
                (0, h_1.default)('a#pgn.i-pgn', { on: { click: () => (0, png_1.copyBoardToPNG)(this.parts.join(' ')) } }, [
                    (0, h_1.default)('div', { class: { "icon": true, "icon-download": true } }, (0, i18n_1._)('EXPORT TO PNG'))
                ])
            ];
            patch(container, (0, h_1.default)('div.editor-button-container', buttons));
            new ffish_js_1.default().then(loadedModule => {
                this.ffish = loadedModule;
                if (this.ffish !== null) {
                    this.ffish.loadVariantConfig(variantsIni_1.variantsIni);
                    this.ffishBoard = new this.ffish.Board(this.variant.name, this.fullfen, this.model.chess960 === 'True');
                }
            });
        }
    }
}
exports.EditorController = EditorController;

},{"../static/ffish.js":98,"./boardSettings":5,"./chess":8,"./i18n":18,"./pieces":35,"./png":37,"./pocket":38,"./profile":39,"./variantsIni":48,"chessgroundx":55,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91}],16:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderGames = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
const h_1 = __importDefault(require("snabbdom/h"));
const chessgroundx_1 = require("chessgroundx");
const chess_1 = require("./chess");
const boardSettings_1 = require("./boardSettings");
const view_1 = require("./view");
function gameView(games, game, fen, lastMove) {
    const variant = chess_1.VARIANTS[game.variant];
    return (0, h_1.default)(`minigame#${game.gameId}.${variant.board}.${variant.piece}`, {
        on: { click: () => window.location.assign('/' + game.gameId) }
    }, (0, h_1.default)('div', [
        (0, h_1.default)('div.row', [
            (0, h_1.default)('div.variant-info', [
                (0, h_1.default)('div.icon', { props: { title: variant.displayName(game.chess960) }, attrs: { "data-icon": variant.icon(game.chess960) } }),
                (0, h_1.default)('div.tc', (0, view_1.timeControlStr)(game.base, game.inc, game.byoyomi)),
            ]),
            (0, h_1.default)('div.name', game.b),
        ]),
        (0, h_1.default)(`div.cg-wrap.${variant.cg}.mini`, {
            hook: {
                insert: vnode => {
                    const cg = (0, chessgroundx_1.Chessground)(vnode.elm, {
                        fen: fen,
                        lastMove: lastMove,
                        geometry: variant.geometry,
                        coordinates: false,
                        viewOnly: true
                    });
                    games[game.gameId] = cg;
                }
            }
        }),
        (0, h_1.default)('div.name', game.w),
    ]));
}
function renderGames() {
    boardSettings_1.boardSettings.updateBoardAndPieceStyles();
    const xmlhttp = new XMLHttpRequest();
    const url = "/api/games";
    xmlhttp.onreadystatechange = function () {
        if (this.readyState === 4 && this.status === 200) {
            const response = JSON.parse(this.responseText);
            const oldVNode = document.getElementById('games');
            const games = {};
            if (oldVNode instanceof Element) {
                patch(oldVNode, (0, h_1.default)('grid-container#games', response.map(game => gameView(games, game, game.fen, game.lastMove))));
                const evtSource = new EventSource("/api/ongoing");
                evtSource.onmessage = function (event) {
                    const message = JSON.parse(event.data);
                    const cg = games[message.gameId];
                    const parts = message.fen.split(" ");
                    let lastMove = message.lastMove;
                    if (lastMove !== null) {
                        lastMove = (0, chess_1.uci2cg)(lastMove);
                        lastMove = [lastMove.slice(0, 2), lastMove.slice(2, 4)];
                        if (lastMove[0][1] === '@')
                            lastMove = [lastMove[1]];
                    }
                    cg.set({
                        fen: parts[0],
                        lastMove: lastMove,
                    });
                };
            }
        }
    };
    xmlhttp.open("GET", url, true);
    xmlhttp.send();
    return [(0, h_1.default)('aside.sidebar-first'),
        (0, h_1.default)('main.games', [(0, h_1.default)('grid-container#games')]),
        (0, h_1.default)('aside.sidebar-second'),
    ];
}
exports.renderGames = renderGames;

},{"./boardSettings":5,"./chess":8,"./view":49,"chessgroundx":55,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91}],17:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Gating = void 0;
const snabbdom_1 = require("snabbdom");
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const h_1 = require("snabbdom/h");
const tovnode_1 = require("snabbdom/tovnode");
const util_1 = require("chessgroundx/util");
const chess_1 = require("./chess");
const document_1 = require("./document");
const pocket_1 = require("./pocket");
const patch = (0, snabbdom_1.init)([attributes_1.default, eventlisteners_1.default, style_1.default]);
class Gating {
    constructor(ctrl) {
        this.ctrl = ctrl;
        this.gating = null;
        this.choices = [];
    }
    start(fen, orig, dest) {
        var _a;
        const ground = this.ctrl.getGround();
        if (this.canGate(ground, fen, orig, dest)) {
            const pocket = (0, chess_1.getPockets)(fen);
            const color = this.ctrl.turnColor;
            this.choices = ['h', 'e', 'q', 'r', 'b', 'n'].filter(letter => (0, chess_1.lc)(pocket, letter, color === "white") > 0).map(chess_1.letter2role);
            // prevent empty only choices in s-house (when H and E dropped before any gating move)
            if (this.choices.length === 0)
                return false;
            // add (first) empty gating choice
            this.choices.unshift("");
            const orientation = ground.state.orientation;
            const moves = { "normal": [orig, dest] };
            let castling = false;
            let rookOrig = "";
            const moveLength = dest.charCodeAt(0) - orig.charCodeAt(0);
            const pieceMoved = ground.state.pieces[dest];
            const pieceMovedRole = (_a = pieceMoved === null || pieceMoved === void 0 ? void 0 : pieceMoved.role) !== null && _a !== void 0 ? _a : "k-piece";
            if (pieceMovedRole === "k-piece") {
                // King long move is always castling move
                if (Math.abs(moveLength) > 1) {
                    castling = true;
                    rookOrig = ((moveLength > 1) ? "h" : "a") + orig[1];
                }
                // King takes own Rook is always castling move in 960 games
                if (this.ctrl.chess960 && this.ctrl.prevPieces !== undefined) {
                    const prevPiece = this.ctrl.prevPieces[dest];
                    if (prevPiece !== undefined && prevPiece.role === "r-piece" && prevPiece.color === color) {
                        castling = true;
                        rookOrig = dest;
                        // remove gating possibility if king move orig is in castling destination squares 
                        if (this.inCastlingTargets(orig, color, moveLength)) {
                            delete moves["normal"];
                        }
                    }
                }
            }
            if (castling) {
                // UCI move castling + gating to rook vacant square is rook takes king!
                if (!this.inCastlingTargets(rookOrig, color, moveLength)) {
                    moves["special"] = [rookOrig, orig, dest];
                }
                const pieces = {};
                pieces[((moveLength > 0) ? "f" : "d") + orig[1]] = { color: color, role: 'r-piece' };
                pieces[((moveLength > 0) ? "g" : "c") + orig[1]] = { color: color, role: 'k-piece' };
                ground.setPieces(pieces);
            }
            // It is possible in 960 that we have no valid gating square finally
            if (Object.keys(moves).length === 0)
                return false;
            this.drawGating(moves, color, orientation);
            this.gating = {
                moves: moves,
                callback: this.ctrl.sendMove,
            };
            return true;
        }
        return false;
    }
    inCastlingTargets(key, color, moveLength) {
        if (color === "white") {
            if (moveLength > 0) {
                // O-O
                return (key === 'f1') || (key === 'g1');
            }
            else {
                // O-O-O
                return (key === 'c1') || (key === 'd1');
            }
        }
        else {
            if (moveLength > 0) {
                return (key === 'f8') || (key === 'g8');
            }
            else {
                return (key === 'c8') || (key === 'd8');
            }
        }
    }
    canGate(ground, fen, orig, dest) {
        // A move can be gating in two cases: 1. normal move of one virgin piece 2. castling
        // Determine that a move made was castling may be tricky in S-Chess960
        // because we use autocastle on in chessground and after castling
        // chessground pieces on dest square can be empty, rook or king.
        // But when castling with gating possible, inverse move (rook takes king) also have to be in dests.
        // So we will use this info to figure out wether castling+gating is possible or not.
        var _a;
        const parts = fen.split(" ");
        const castling = parts[2];
        const color = parts[1];
        // At the starting position, the virginities of both king AND rooks are encoded in KQkq
        // "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR[HEhe] w KQBCDFGkqbcdfg - 0 1"
        // but after the king moves, rook virginity is encoded in AHah
        // rnbq1bnr/ppppkppp/8/4p3/4P3/8/PPPPKPPP/RNBQ1BNR[HEhe] w ABCDFGHabcdfgh - 2 3
        // King virginity is encoded in Ee after either of the rooks move, but the king hasn't
        const pieceMoved = ground.state.pieces[dest];
        const pieceMovedRole = (_a = pieceMoved === null || pieceMoved === void 0 ? void 0 : pieceMoved.role) !== null && _a !== void 0 ? _a : 'k-piece';
        if (pieceMovedRole === 'k-piece' || pieceMovedRole === 'r-piece') {
            if ((color === 'w' && orig[1] === "1" && (castling.includes("K") || castling.includes("Q"))) ||
                (color === 'b' && orig[1] === "8" && (castling.includes("k") || castling.includes("q")))) {
                const inverseDests = this.ctrl.dests[dest];
                if (inverseDests !== undefined && inverseDests.includes(orig))
                    return true;
            }
        }
        if (color === 'w') {
            switch (orig) {
                case "a1": return castling.includes("A");
                case "b1": return castling.includes("B");
                case "c1": return castling.includes("C");
                case "d1": return castling.includes("D");
                case "e1": return castling.includes("E");
                case "f1": return castling.includes("F");
                case "g1": return castling.includes("G");
                case "h1": return castling.includes("H");
                default: return false;
            }
        }
        else {
            switch (orig) {
                case "a8": return castling.includes("a");
                case "b8": return castling.includes("b");
                case "c8": return castling.includes("c");
                case "d8": return castling.includes("d");
                case "e8": return castling.includes("e");
                case "f8": return castling.includes("f");
                case "g8": return castling.includes("g");
                case "h8": return castling.includes("h");
                default: return false;
            }
        }
    }
    gate(orig, color, role) {
        const g = this.ctrl.getGround();
        g.newPiece({ "role": role, "color": color }, orig);
        let position = (this.ctrl.turnColor === this.ctrl.mycolor) ? "bottom" : "top";
        if (this.ctrl.flip)
            position = (position === "top") ? "bottom" : "top";
        if (position === "bottom") {
            this.ctrl.pockets[1][role]--;
            this.ctrl.vpocket1 = patch(this.ctrl.vpocket1, (0, pocket_1.pocketView)(this.ctrl, color, "bottom"));
        }
        else {
            this.ctrl.pockets[0][role]--;
            this.ctrl.vpocket0 = patch(this.ctrl.vpocket0, (0, pocket_1.pocketView)(this.ctrl, color, "top"));
        }
    }
    drawGating(moves, color, orientation) {
        const container = (0, tovnode_1.toVNode)(document.querySelector('extension'));
        patch(container, this.view(moves, color, orientation));
    }
    drawNoGating() {
        const container = document.getElementById('extension_choice');
        patch(container, (0, h_1.h)('extension'));
    }
    finish(gatedPieceRole, moveType, color) {
        if (this.gating) {
            this.drawNoGating();
            const move = this.gating.moves[moveType];
            if (gatedPieceRole)
                this.gate(move[0], color, gatedPieceRole);
            const gatedPieceLetter = gatedPieceRole ? (0, chess_1.role2letter)(gatedPieceRole) : "";
            if (this.gating.callback) {
                if (moveType === "special") {
                    if (gatedPieceLetter === "") {
                        // empty gating was chosen on vacant rook square (simple castling)
                        this.gating.callback(move[1], move[2], gatedPieceLetter);
                    }
                    else {
                        // gating to rook square while castling need special UCI move (rook takes king)
                        this.gating.callback(move[0], move[1], gatedPieceLetter);
                    }
                }
                else {
                    this.gating.callback(move[0], move[1], gatedPieceLetter);
                }
            }
            this.gating = null;
        }
    }
    cancel() {
        this.drawNoGating();
        this.ctrl.goPly(this.ctrl.ply);
        return;
    }
    squareView(orig, color, orientation, moveType) {
        let left = (8 - (0, util_1.key2pos)(orig)[0]) * 12.5;
        if (orientation === "white")
            left = 87.5 - left;
        return this.choices.map((gatedPieceRole, i) => {
            const top = (color === orientation ? 7 - i : i) * 12.5;
            return (0, h_1.h)("square", {
                style: { top: top + "%", left: left + "%" },
                hook: (0, document_1.bind)("click", e => {
                    e.stopPropagation();
                    this.finish(gatedPieceRole, moveType, color);
                }, false)
            }, [
                (0, h_1.h)("piece." + gatedPieceRole + "." + color)
            ]);
        });
    }
    view(moves, color, orientation) {
        const direction = color === orientation ? "top" : "bottom";
        let squares = [];
        if ("normal" in moves)
            squares = this.squareView(moves["normal"][0], color, orientation, "normal");
        if ("special" in moves)
            squares = squares.concat(this.squareView(moves["special"][0], color, orientation, "special"));
        return (0, h_1.h)("div#extension_choice." + direction, {
            hook: {
                insert: vnode => {
                    const el = vnode.elm;
                    el.addEventListener("click", () => this.cancel());
                    el.addEventListener("contextmenu", e => {
                        e.preventDefault();
                        return false;
                    });
                }
            }
        }, squares);
    }
}
exports.Gating = Gating;

},{"./chess":8,"./document":13,"./pocket":38,"chessgroundx/util":69,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/style":92,"snabbdom/tovnode":95}],18:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.languageSettings = exports.translatedLanguage = exports.LANGUAGES = exports.pgettext = exports.ngettext = exports._ = exports.i18n = void 0;
const h_1 = require("snabbdom/h");
const gettext_js_1 = __importDefault(require("gettext.js"));
const settings_1 = require("./settings");
const view_1 = require("./view");
exports.i18n = new gettext_js_1.default();
function _(msgid, ...vars) { return exports.i18n.gettext(msgid, vars); }
exports._ = _;
function ngettext(msgid, plural, ...vars) { return exports.i18n.ngettext(msgid, plural, vars); }
exports.ngettext = ngettext;
function pgettext(msgctxt, msgid, ...vars) { return exports.i18n.pgettext(msgctxt, msgid, vars); }
exports.pgettext = pgettext;
exports.LANGUAGES = {
    en: "English",
    de: "Deutsch",
    es: "Español",
    fr: "Français",
    gl_ES: "Galego",
    hu: "Magyar",
    it: "Italiano",
    ja: "日本語",
    ko: "한국어",
    pl: "Polskie",
    pt: "Português",
    th: "ไทย",
    tr: "Türkçe",
    zh: "简体中文",
};
const LANGUAGETEXT = {
    en: "Language",
    de: "Sprache",
    es: "Idioma",
    fr: "Langue",
    gl_ES: "Lingua",
    hu: "Nyelv",
    it: "Lingua",
    ja: "言語",
    ko: "언어",
    pl: "Język ",
    pt: "Lingua",
    th: "ภาษา",
    tr: "Dil",
    zh: "语言",
};
const preferredLang = window.navigator.language.slice(0, 2);
exports.translatedLanguage = (_a = LANGUAGETEXT[preferredLang]) !== null && _a !== void 0 ? _a : 'Language';
class LanguageSettings extends settings_1.StringSettings {
    constructor() {
        super('lang', 'en');
    }
    update() {
    }
    view() {
        const langList = (0, view_1.radioList)(this, 'lang', exports.LANGUAGES, (evt, key) => {
            this.value = key;
            evt.target.form.submit();
        });
        return (0, h_1.h)('div#settings-lang', [
            (0, h_1.h)('form.radio-list', { props: { method: "post", action: "/translation/select" } }, langList),
        ]);
    }
}
exports.languageSettings = new LanguageSettings();

},{"./settings":43,"./view":49,"gettext.js":71,"snabbdom/h":85}],19:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updatePoint = exports.updateCount = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const h_1 = require("snabbdom/h");
const chess_1 = require("./chess");
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
// Counting for makruk, cambodian, sittuyin
function updateCount(fen, whiteContainer, blackContainer) {
    const [countingPly, countingLimit, countingSide,] = (0, chess_1.getCounting)(fen);
    whiteContainer = patch(whiteContainer, (0, h_1.h)('div#misc-infow', ''));
    blackContainer = patch(blackContainer, (0, h_1.h)('div#misc-infob', ''));
    if (countingLimit !== 0 && countingPly !== 0) {
        if (countingSide === 'w')
            whiteContainer = patch(whiteContainer, (0, h_1.h)('div#misc-infow', `${Math.floor((countingPly + 1) / 2)}/${countingLimit / 2}`));
        else
            blackContainer = patch(blackContainer, (0, h_1.h)('div#misc-infob', `${Math.floor((countingPly + 1) / 2)}/${countingLimit / 2}`));
    }
    return [whiteContainer, blackContainer];
}
exports.updateCount = updateCount;
// Point count for janggi
function updatePoint(fen, choContainer, hanContainer) {
    const board = fen.split(" ")[0];
    const [choPoint, hanPoint] = (0, chess_1.getJanggiPoints)(board);
    choContainer = patch(choContainer, (0, h_1.h)('div#misc-infow', { class: { 'text-color-blue': true } }, choPoint));
    hanContainer = patch(hanContainer, (0, h_1.h)('div#misc-infob', { class: { 'text-color-red': true } }, hanPoint));
    return [choContainer, hanContainer];
}
exports.updatePoint = updatePoint;

},{"./chess":8,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91}],20:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.inviteView = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default, style_1.default]);
const h_1 = __importDefault(require("snabbdom/h"));
const i18n_1 = require("./i18n");
const chess_1 = require("./chess");
const profile_1 = require("./profile");
const clipboard_1 = require("./clipboard");
const view_1 = require("./view");
function inviteView(model) {
    const gameId = model["gameId"];
    const variant = chess_1.VARIANTS[model.variant];
    const chess960 = model.chess960 === 'True';
    const gameURL = model["home"] + '/' + gameId;
    let title, formAction, buttonClass, buttonText;
    if (model["inviter"] === "") {
        title = (0, i18n_1._)('Challenge to a game');
        formAction = model["home"] + '/invite/cancel/' + gameId;
        buttonClass = { red: true };
        buttonText = (0, i18n_1._)('CANCEL');
    }
    else {
        title = model["inviter"];
        formAction = model["home"] + '/invite/accept/' + gameId;
        buttonClass = { join: true };
        buttonText = (0, i18n_1._)('JOIN THE GAME');
    }
    const evtSource = new EventSource("/api/invites");
    evtSource.onmessage = function (event) {
        const message = JSON.parse(event.data);
        if (message.gameId === gameId) {
            window.location.assign(gameURL);
        }
    };
    return [
        (0, h_1.default)('div.invite', [
            (0, h_1.default)('h1', { attrs: { align: 'center' } }, title),
            (0, h_1.default)('div.invitegame', [
                (0, h_1.default)('div.info0.games.icon', { attrs: { "data-icon": variant.icon(chess960) } }, [
                    (0, h_1.default)('div.info2', [
                        (0, h_1.default)('div', variant.displayName(chess960)),
                        (0, h_1.default)('div.tc', (0, view_1.timeControlStr)(model["base"], model["inc"], model["byo"])),
                    ]),
                    (0, h_1.default)('div.rated', (0, profile_1.gameType)(model["rated"])),
                ]),
            ]),
            (model["inviter"] == "") ?
                (0, h_1.default)('div.inviteinfo', [
                    (0, h_1.default)('div', (0, i18n_1._)('To invite someone to play, give this URL:')),
                    (0, h_1.default)('input#invite-url', { attrs: { readonly: true, spellcheck: false, value: gameURL } }),
                    (0, h_1.default)('button#paste-url', { on: { click: () => {
                                (0, clipboard_1.copyTextToClipboard)(gameURL);
                                patch(document.getElementById('paste-icon'), (0, h_1.default)('i#paste-icon', { props: { title: (0, i18n_1._)('Copy URL') }, class: { "icon": true, "icon-check": true } }));
                            } } }, [
                        (0, h_1.default)('i#paste-icon', { props: { title: (0, i18n_1._)('Copy URL') }, class: { "icon": true, "icon-clipboard": true } })
                    ]),
                    (0, h_1.default)('div', (0, i18n_1._)('The first person to come to this URL will play with you.')),
                ]) : (0, h_1.default)('div'),
            (0, h_1.default)('form', { props: { method: "post", action: formAction }, class: { invite: true } }, [
                (0, h_1.default)('button', { class: buttonClass }, buttonText),
            ]),
        ]),
    ];
}
exports.inviteView = inviteView;

},{"./chess":8,"./clipboard":9,"./i18n":18,"./profile":39,"./view":49,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92}],21:[function(require,module,exports){
"use strict";
// Translated from Python code https://github.com/takaki/kif2pgn
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseKif = exports.resultString = void 0;
// mirror letters to digits
function l2d(c) {
    switch (c) {
        case 'a': return '9';
        case 'b': return '8';
        case 'c': return '7';
        case 'd': return '6';
        case 'e': return '5';
        case 'f': return '4';
        case 'g': return '3';
        case 'h': return '2';
        case 'i': return '1';
        default: return '_';
    }
}
// mirror digits to letters
function d2l(c) {
    switch (c) {
        case '1': return 'i';
        case '2': return 'h';
        case '3': return 'g';
        case '4': return 'f';
        case '5': return 'e';
        case '6': return 'd';
        case '7': return 'c';
        case '8': return 'b';
        case '9': return 'a';
        default: return '_';
    }
}
function mirror(p) {
    return d2l(p[0]) + l2d(p[1]);
}
const dict = (keys, values) => keys.reduce((obj, key, index) => (Object.assign(Object.assign({}, obj), { [key]: values[index] })), {});
// TODO: add missing handicap types to chess.ts
// recognise more initial handicap positions
// see https://en.wikipedia.org/wiki/Handicap_(shogi)#Types_of_handicap_games
const HC_TYPES = ["香落ち", "右香落ち", "角落ち", "飛車落ち", "飛香落ち", "二枚落ち", "三枚落ち", "四枚落ち", "五枚落ち", "左五枚落ち", "六枚落ち", "八枚落ち", "十枚落ち", "その他"];
const HC_NAMES = ["Lance HC", "RLance HC", "Bishop HC", "Rook HC", "Rook+Lance HC", "2-Piece HC", "3-Piece HC", "4-Piece HC", "5-Piece HC", "LL 5-Piece HC", "6-Piece HC", "8-Piece HC", "10-Piece HC", "Other-HC"];
const hc_map = dict(HC_TYPES, HC_NAMES);
const alpha = 'abcdefghi'.split('');
const zensuji = '１２３４５６７８９'.split('');
const kansuji = '一二三四五六七八九'.split('');
const zen_map = dict(zensuji, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
const kan_map = dict(kansuji, alpha);
const pieces = '歩香桂銀金角飛玉と馬龍竜';
const piece_map = dict('歩香桂銀金角飛玉と馬龍竜'.split(''), 'PLNSGBRK'.split('').concat(['+P', '+B', '+R', '+R']));
const line_re = /(\d+) +([^ ]+)/u;
function resultString(movingPlayerWin, ply, isHandicap) {
    if (ply % 2 === ((movingPlayerWin) ? 1 : 0)) {
        return (!isHandicap) ? '1-0' : '0-1';
    }
    else {
        return (!isHandicap) ? '0-1' : '1-0';
    }
}
exports.resultString = resultString;
function parseKif(text) {
    let date, place, tc, sente, gote, handicap = '';
    let status = 11; // unknown
    let result = '*'; // unknown
    const move_list = [];
    let tagsProcessed = false;
    let isHandicap = false;
    let movesStartLineNumber, ply;
    const lines = text.split(/\r?\n/u);
    let piace_name, prev_position, next_position, rest;
    const WIN = true;
    const LOSS = false;
    for (let i = 0; i < lines.length; i++) {
        const firstChar = lines[i][0];
        if (firstChar === '#' || firstChar === '*')
            continue;
        if (!tagsProcessed) {
            const symbols = [...lines[i]];
            const idx = symbols.indexOf('：'); // Fullwidth Colon!
            if (idx > -1) {
                const tagPair = [symbols.slice(0, idx).join(''), symbols.slice(idx + 1).join('')];
                switch (tagPair[0]) {
                    case '開始日時':
                        date = tagPair[1];
                        break;
                    case '場所':
                        place = tagPair[1];
                        break;
                    case '持ち時間':
                        tc = tagPair[1];
                        break;
                    case '手合割':
                        handicap = tagPair[1];
                        isHandicap = HC_TYPES.includes(handicap);
                        handicap = (isHandicap) ? hc_map[handicap] : '';
                        break;
                    case '先手':
                        sente = tagPair[1];
                        break;
                    case '後手':
                        gote = tagPair[1];
                        break;
                }
            }
            else {
                tagsProcessed = true;
            }
        }
        if (!tagsProcessed) {
            movesStartLineNumber = i;
            continue;
        }
        const res = lines[i].match(line_re);
        if (res) {
            const s = res[2];
            ply = i - movesStartLineNumber - 1;
            if (zensuji.includes(s[0])) {
                next_position = zen_map[s[0]] + kan_map[s[1]];
            }
            else if (s[0] == '同') {
                // used when the destination coordinate is the same as that of the immediately preceding move
            }
            else if (s[0] == '反') {
                status = 10; // illegal move
                if (s == '反則勝ち') {
                    // indicates that the immediately preceding move was illegal
                    result = resultString(WIN, ply, isHandicap);
                }
                else {
                    // indicates that the player whose turn this was supposed to be somehow lost by illegality
                    result = resultString(LOSS, ply, isHandicap);
                }
                break;
            }
            else if (s[0] == '切') {
                status = 6; // time out/flag drop
                result = resultString(LOSS, ply, isHandicap);
                break;
            }
            else if (s[0] == '投') {
                status = 2; // resignation
                result = resultString(LOSS, ply, isHandicap);
                break;
            }
            else if (s[0] == '詰') {
                status = 1; // checkmate
                result = resultString(WIN, ply, isHandicap);
                break;
            }
            else if (s[0] == '入') {
                status = 12; // entering king (campmate)
                result = resultString(WIN, ply, isHandicap);
                break;
            }
            else if (s[0] == '千') {
                status = 13; // repetition
                result = '1/2-1/2';
                break;
            }
            else if (s[0] == '持') {
                status = 5; // impasse
                result = '1/2-1/2';
                break;
            }
            else if (s[0] == '中') {
                status = 0; // aborted
                break;
            }
            else {
                console.log('Unknown Move', s[0], lines[i], res);
                return [];
            }
            if (pieces.includes(s[2])) {
                piace_name = piece_map[s[2]];
                rest = s.slice(3);
            }
            else if (s[2] == '成') {
                piace_name = '+' + piece_map[s[3]];
                rest = s.slice(4);
            }
            else {
                console.log('Unknown Piece', s[2], lines[i], res);
                return [];
            }
            let promote = '';
            if (rest[0] == '成') {
                promote = '+';
                prev_position = rest[2] + alpha[parseInt(rest[3]) - 1];
            }
            else if (rest[0] == '打') {
                prev_position = '@';
            }
            else if (rest[0] == '(') {
                prev_position = rest[1] + alpha[parseInt(rest[2]) - 1];
            }
            else {
                console.log('Unknown ???', rest[0], lines[i], res);
                return [];
            }
            //const num = parseInt(res[1]);
            //console.log(num, ply, piace_name, prev_position, next_position, promote);
            let move;
            if (prev_position == '@') {
                move = piace_name + prev_position + mirror(next_position) + promote;
            }
            else {
                move = mirror(prev_position) + mirror(next_position) + promote;
            }
            //console.log(num, move);
            move_list.push(move);
        }
    }
    return { 'date': date, 'place': place, 'tc': tc, 'handicap': handicap, 'sente': sente, 'gote': gote, 'moves': move_list, 'status': status, 'result': result };
}
exports.parseKif = parseKif;

},{}],22:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lobbyView = exports.LobbyController = void 0;
const sockette_1 = __importDefault(require("sockette"));
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default, style_1.default]);
const h_1 = require("snabbdom/h");
const chessgroundx_1 = require("chessgroundx");
const i18n_1 = require("./i18n");
const chat_1 = require("./chat");
const chess_1 = require("./chess");
const sound_1 = require("./sound");
const boardSettings_1 = require("./boardSettings");
const view_1 = require("./view");
const notification_1 = require("./notification");
const layer1_1 = require("./lobby/layer1");
class LobbyController {
    constructor(el, model) {
        this.minutesValues = [
            0, 1 / 4, 1 / 2, 3 / 4, 1, 3 / 2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19, 20, 25, 30, 35, 40, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180
        ];
        this.incrementValues = [
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
            25, 30, 35, 40, 45, 60, 90, 120, 150, 180
        ];
        this.minutesStrings = ["0", "¼", "½", "¾"];
        console.log("LobbyController constructor", el, model);
        this.model = model;
        this.challengeAI = false;
        this.challengeRM = false;
        this.inviteFriend = false;
        this.validGameData = false;
        this.seeks = [];
        const onOpen = (evt) => {
            this._ws = evt.target;
            console.log('onOpen()');
            // console.log("---CONNECTED", evt);
            // prevent losing my seeks in case of websocket reconnections
            if (this.seeks !== undefined) {
                this.seeks.forEach(s => {
                    if (s.user === this.model["username"]) {
                        this.createSeekMsg(s.variant, s.color, s.fen, s.base, s.inc, s.byoyomi, s.chess960, s.rated, s.alternateStart);
                    }
                });
            }
            this.doSend({ type: "lobby_user_connected", username: this.model["username"] });
            this.doSend({ type: "get_seeks" });
        };
        this._ws = { "readyState": -1 };
        const opts = {
            maxAttempts: 20,
            onopen: e => onOpen(e),
            onmessage: e => this.onMessage(e),
            onreconnect: e => console.log('Reconnecting in lobby...', e),
            onmaximum: e => console.log('Stop Attempting!', e),
            onclose: e => { console.log('Closed!', e); },
            onerror: e => console.log('Error:', e),
        };
        const ws = location.host.includes('pychess') ? 'wss://' : 'ws://';
        this.sock = new sockette_1.default(ws + location.host + "/wsl", opts);
        // get seeks when we are coming back after a game
        if (this._ws.readyState === 1) {
            this.doSend({ type: "get_seeks" });
        }
        patch(document.getElementById('seekbuttons'), (0, h_1.h)('div#seekbuttons', this.renderSeekButtons()));
        patch(document.getElementById('lobbychat'), (0, chat_1.chatView)(this, "lobbychat"));
        patch(document.getElementById('variants-catalog'), (0, layer1_1.variantPanels)(this));
        this.streams = document.getElementById('streams');
        this.spotlights = document.getElementById('spotlights');
        // challenge!
        const anon = this.model.anon === 'True';
        if (model.profileid !== "") {
            this.challengeAI = model.profileid === 'Fairy-Stockfish';
            this.inviteFriend = model.profileid === 'Invite-friend';
            document.getElementById('game-mode').style.display = (anon || this.challengeAI) ? 'none' : 'inline-flex';
            document.getElementById('challenge-block').style.display = 'inline-flex';
            document.getElementById('ailevel').style.display = this.challengeAI ? 'block' : 'none';
            document.getElementById('id01').style.display = 'block';
        }
        const e = document.getElementById("fen");
        if (this.model.fen !== "")
            e.value = this.model.fen;
        if (anon)
            e.disabled = true;
    }
    doSend(message) {
        // console.log("---> lobby doSend():", message);
        this.sock.send(JSON.stringify(message));
    }
    createSeekMsg(variant, color, fen, minutes, increment, byoyomiPeriod, chess960, rated, alternateStart) {
        this.doSend({
            type: "create_seek",
            user: this.model.username,
            target: this.model.profileid,
            variant: variant,
            fen: fen,
            minutes: minutes,
            increment: increment,
            byoyomiPeriod: byoyomiPeriod,
            rated: rated,
            alternateStart: alternateStart,
            chess960: chess960,
            color: color
        });
    }
    createInviteFriendMsg(variant, color, fen, minutes, increment, byoyomiPeriod, chess960, rated, alternateStart) {
        this.doSend({
            type: "create_invite",
            user: this.model.username,
            target: 'Invite-friend',
            variant: variant,
            fen: fen,
            minutes: minutes,
            increment: increment,
            byoyomiPeriod: byoyomiPeriod,
            rated: rated,
            alternateStart: alternateStart,
            chess960: chess960,
            color: color
        });
    }
    createBotChallengeMsg(variant, color, fen, minutes, increment, byoyomiPeriod, level, chess960, rated, alternateStart) {
        this.doSend({
            type: "create_ai_challenge",
            rm: this.challengeRM,
            user: this.model.username,
            variant: variant,
            fen: fen,
            minutes: minutes,
            increment: increment,
            byoyomiPeriod: byoyomiPeriod,
            rated: rated,
            alternateStart: alternateStart,
            level: level,
            chess960: chess960,
            color: color
        });
    }
    isNewSeek(variant, color, fen, minutes, increment, byoyomiPeriod, chess960, rated) {
        // console.log("isNewSeek()?", variant, color, fen, minutes, increment, byoyomiPeriod, chess960, rated);
        // console.log(this.seeks);
        return !this.seeks.some(seek => seek.user === this.model["username"] &&
            seek.variant === variant &&
            seek.fen === fen &&
            seek.color === color &&
            seek.base === minutes &&
            seek.inc === increment &&
            seek.byoyomi === byoyomiPeriod &&
            seek.chess960 === chess960 &&
            seek.rated === rated);
    }
    createSeek(color) {
        document.getElementById('id01').style.display = 'none';
        if (!this.validGameData)
            return;
        let e;
        e = document.getElementById('variant');
        const variant = chess_1.VARIANTS[e.options[e.selectedIndex].value];
        localStorage.seek_variant = variant.name;
        // TODO Standardize seek color
        let seekColor;
        if (variant.name.endsWith('shogi') && color !== 'r')
            seekColor = (color === 'w') ? 'b' : 'w';
        else
            seekColor = color;
        e = document.getElementById('fen');
        const fen = e.value;
        let alternateStart = "";
        if (variant.alternateStart) {
            e = document.getElementById('alternate-start');
            alternateStart = e.options[e.selectedIndex].value;
        }
        e = document.getElementById('min');
        const minutes = this.minutesValues[Number(e.value)];
        localStorage.seek_min = e.value;
        e = document.getElementById('inc');
        const increment = this.incrementValues[Number(e.value)];
        localStorage.seek_inc = e.value;
        e = document.getElementById('byo');
        const byoyomi = variant.timeControl === "byoyomi";
        const byoyomiPeriod = (byoyomi && increment > 0) ? Number(e.value) : 0;
        localStorage.seek_byo = e.value;
        e = document.querySelector('input[name="mode"]:checked');
        let rated;
        if (this.challengeAI ||
            this.model.anon === "True" ||
            this.model.title === "BOT" ||
            fen !== "" ||
            (minutes < 1 && increment === 0) ||
            (minutes === 0 && increment === 1))
            rated = false;
        else
            rated = e.value === "1";
        localStorage.seek_rated = e.value;
        e = document.getElementById('chess960');
        const chess960 = (variant.chess960 && alternateStart === "") ? e.checked : false;
        localStorage.seek_chess960 = e.checked;
        // console.log("CREATE SEEK variant, color, fen, minutes, increment, hide, chess960", variant, color, fen, minutes, increment, chess960, rated);
        if (this.challengeAI) {
            e = document.querySelector('input[name="level"]:checked');
            const level = Number(e.value);
            localStorage.seek_level = e.value;
            // console.log(level, e.value, localStorage.getItem("seek_level"));
            this.createBotChallengeMsg(variant.name, seekColor, fen, minutes, increment, byoyomiPeriod, level, chess960, rated, alternateStart);
        }
        else if (this.inviteFriend) {
            this.createInviteFriendMsg(variant.name, seekColor, fen, minutes, increment, byoyomiPeriod, chess960, rated, alternateStart);
        }
        else {
            if (this.isNewSeek(variant.name, seekColor, fen, minutes, increment, byoyomiPeriod, chess960, rated))
                this.createSeekMsg(variant.name, seekColor, fen, minutes, increment, byoyomiPeriod, chess960, rated, alternateStart);
        }
        // prevent to create challenges continuously
        this.model.profileid = '';
        window.history.replaceState({}, this.model.title, '/');
        // We need to ask the user for permission
        (0, notification_1.notify)(null, null);
    }
    renderSeekButtons() {
        var _a, _b, _c, _d, _e, _f;
        const vVariant = this.model.variant || localStorage.seek_variant || "chess";
        const vMin = (_a = localStorage.seek_min) !== null && _a !== void 0 ? _a : "5";
        const vInc = (_b = localStorage.seek_inc) !== null && _b !== void 0 ? _b : "3";
        const vByoIdx = ((_c = localStorage.seek_byo) !== null && _c !== void 0 ? _c : 1) - 1;
        const vRated = (_d = localStorage.seek_rated) !== null && _d !== void 0 ? _d : "0";
        const vLevel = Number((_e = localStorage.seek_level) !== null && _e !== void 0 ? _e : "1");
        const vChess960 = (_f = localStorage.seek_chess960) !== null && _f !== void 0 ? _f : "false";
        const anon = this.model.anon === 'True';
        return [
            (0, h_1.h)('div#id01.modal', [
                (0, h_1.h)('form.modal-content', [
                    (0, h_1.h)('div#closecontainer', [
                        (0, h_1.h)('span.close', {
                            on: {
                                click: () => {
                                    document.getElementById('id01').style.display = 'none';
                                    // prevent creating challenges continuously
                                    this.model.profileid = '';
                                    window.history.replaceState({}, this.model.title, '/');
                                }
                            },
                            attrs: { 'data-icon': 'j' }, props: { title: (0, i18n_1._)("Cancel") }
                        }),
                    ]),
                    (0, h_1.h)('div.container', [
                        (0, h_1.h)('div#challenge-block', [
                            (0, h_1.h)('h3', (0, i18n_1._)('Challenge %1 to a game', this.model.profileid)),
                        ]),
                        (0, h_1.h)('div', [
                            (0, h_1.h)('label', { attrs: { for: "variant" } }, (0, i18n_1._)("Variant")),
                            (0, chess_1.selectVariant)("variant", vVariant, () => this.setVariant(), () => this.setVariant()),
                        ]),
                        (0, h_1.h)('input#fen', {
                            props: { name: 'fen', placeholder: (0, i18n_1._)('Paste the FEN text here') + (anon ? (0, i18n_1._)(' (must be signed in)') : ''), autocomplete: "off" },
                            on: { input: () => this.setFen() },
                        }),
                        (0, h_1.h)('div#alternate-start-block'),
                        (0, h_1.h)('div#chess960-block', [
                            (0, h_1.h)('label', { attrs: { for: "chess960" } }, "Chess960"),
                            (0, h_1.h)('input#chess960', {
                                props: {
                                    name: "chess960",
                                    type: "checkbox",
                                },
                                attrs: {
                                    checked: vChess960 === "true"
                                },
                            }),
                        ]),
                        (0, h_1.h)('label', { attrs: { for: "min" } }, (0, i18n_1._)("Minutes per side:")),
                        (0, h_1.h)('span#minutes'),
                        (0, h_1.h)('input#min.slider', {
                            props: { name: "min", type: "range", min: 0, max: this.minutesValues.length - 1, value: vMin },
                            on: { input: e => this.setMinutes(e.target.value) },
                            hook: { insert: vnode => this.setMinutes(vnode.elm.value) },
                        }),
                        (0, h_1.h)('label#incrementlabel', { attrs: { for: "inc" } }, ''),
                        (0, h_1.h)('span#increment'),
                        (0, h_1.h)('input#inc.slider', {
                            props: { name: "inc", type: "range", min: 0, max: this.incrementValues.length - 1, value: vInc },
                            on: { input: e => this.setIncrement(this.incrementValues[e.target.value]) },
                            hook: { insert: vnode => this.setIncrement(this.incrementValues[vnode.elm.value]) },
                        }),
                        (0, h_1.h)('div#byoyomi-period', [
                            (0, h_1.h)('label#byoyomiLabel', { attrs: { for: "byo" } }, (0, i18n_1._)('Periods')),
                            (0, h_1.h)('select#byo', {
                                props: { name: "byo" },
                            }, [1, 2, 3].map((n, idx) => (0, h_1.h)('option', { props: { value: n }, attrs: { selected: (idx === vByoIdx) } }, n))),
                        ]),
                        (0, h_1.h)('form#game-mode', [
                            (0, h_1.h)('div.radio-group', [
                                (0, h_1.h)('input#casual', {
                                    props: { type: "radio", name: "mode", value: "0" },
                                    attrs: { checked: vRated === "0" },
                                    on: { input: e => this.setCasual(e.target.value) },
                                    hook: { insert: vnode => this.setCasual(vnode.elm.value) },
                                }),
                                (0, h_1.h)('label', { attrs: { for: "casual" } }, (0, i18n_1._)("Casual")),
                                (0, h_1.h)('input#rated', {
                                    props: { type: "radio", name: "mode", value: "1" },
                                    attrs: { checked: vRated === "1" },
                                    on: { input: e => this.setRated(e.target.value) },
                                    hook: { insert: vnode => this.setRated(vnode.elm.value) },
                                }),
                                (0, h_1.h)('label', { attrs: { for: "rated" } }, (0, i18n_1._)("Rated")),
                            ]),
                        ]),
                        // if play with the machine
                        // A.I.Level (1-8 buttons)
                        (0, h_1.h)('form#ailevel', [
                            (0, h_1.h)('h4', (0, i18n_1._)("A.I. Level")),
                            (0, h_1.h)('div.radio-group', [0, 1, 2, 3, 4, 5, 6, 7, 8].map(level => [
                                (0, h_1.h)('input#ai' + level, { props: { type: "radio", name: "level", value: level }, attrs: { checked: vLevel === level } }),
                                (0, h_1.h)('label.level-ai.ai' + level, { attrs: { for: "ai" + level } }, level),
                            ]).reduce((arr, v) => (arr.push(...v), arr), []) // flatmap
                            ),
                        ]),
                        (0, h_1.h)('div#color-button-group', [
                            (0, h_1.h)('button.icon.icon-black', { props: { type: "button", title: (0, i18n_1._)("Black") }, on: { click: () => this.createSeek('b') } }),
                            (0, h_1.h)('button.icon.icon-adjust', { props: { type: "button", title: (0, i18n_1._)("Random") }, on: { click: () => this.createSeek('r') } }),
                            (0, h_1.h)('button.icon.icon-white', { props: { type: "button", title: (0, i18n_1._)("White") }, on: { click: () => this.createSeek('w') } }),
                        ]),
                    ]),
                ]),
            ]),
            (0, h_1.h)('button.lobby-button', { on: { click: () => this.createGame() } }, (0, i18n_1._)("Create a game")),
            (0, h_1.h)('button.lobby-button', { on: { click: () => this.playFriend() } }, (0, i18n_1._)("Play with a friend")),
            (0, h_1.h)('button.lobby-button', { on: { click: () => this.playAI() } }, (0, i18n_1._)("Play with AI")),
            (0, h_1.h)('button.lobby-button', { on: { click: () => this.playRM() } }, (0, i18n_1._)("Practice with Random-Mover")),
        ];
    }
    preSelectVariant(variantName, chess960 = false) {
        if (variantName !== '') {
            const select = document.getElementById("variant");
            const options = Array.from(select.options).map(o => o.value);
            if (select)
                select.selectedIndex = options.indexOf(variantName);
            this.setVariant();
            const check = document.getElementById("chess960");
            if (check)
                check.checked = chess960;
        }
    }
    createGame(variantName = '', chess960 = false) {
        this.preSelectVariant(variantName, chess960);
        const anon = this.model.anon === 'True';
        this.challengeAI = false;
        this.challengeRM = false;
        this.inviteFriend = false;
        document.getElementById('game-mode').style.display = anon ? 'none' : 'inline-flex';
        document.getElementById('challenge-block').style.display = 'none';
        document.getElementById('ailevel').style.display = 'none';
        document.getElementById('id01').style.display = 'block';
    }
    playFriend(variantName = '', chess960 = false) {
        this.preSelectVariant(variantName, chess960);
        const anon = this.model.anon === 'True';
        this.challengeAI = false;
        this.challengeRM = false;
        this.inviteFriend = true;
        document.getElementById('game-mode').style.display = anon ? 'none' : 'inline-flex';
        document.getElementById('challenge-block').style.display = 'none';
        document.getElementById('ailevel').style.display = 'none';
        document.getElementById('id01').style.display = 'block';
    }
    playAI(variantName = '', chess960 = false) {
        this.preSelectVariant(variantName, chess960);
        this.challengeAI = true;
        this.challengeRM = false;
        this.inviteFriend = false;
        document.getElementById('game-mode').style.display = 'none';
        document.getElementById('challenge-block').style.display = 'none';
        document.getElementById('ailevel').style.display = 'inline-block';
        document.getElementById('id01').style.display = 'block';
    }
    playRM(variantName = '', chess960 = false) {
        this.preSelectVariant(variantName, chess960);
        this.challengeAI = true;
        this.challengeRM = true;
        this.inviteFriend = false;
        document.getElementById('game-mode').style.display = 'none';
        document.getElementById('challenge-block').style.display = 'none';
        document.getElementById('ailevel').style.display = 'none';
        document.getElementById('id01').style.display = 'block';
    }
    setVariant() {
        let e;
        e = document.getElementById('variant');
        const variant = chess_1.VARIANTS[e.options[e.selectedIndex].value];
        const byoyomi = variant.timeControl === "byoyomi";
        // TODO use toggle class instead of setting style directly
        document.getElementById('chess960-block').style.display = variant.chess960 ? 'block' : 'none';
        document.getElementById('byoyomi-period').style.display = byoyomi ? 'block' : 'none';
        e = document.getElementById('fen');
        e.value = "";
        e = document.getElementById('incrementlabel');
        patch(e, (0, h_1.h)('label#incrementlabel', { attrs: { for: "inc" } }, (byoyomi ? (0, i18n_1._)('Byoyomi in seconds:') : (0, i18n_1._)('Increment in seconds:'))));
        e = document.getElementById('alternate-start-block');
        e.innerHTML = "";
        if (variant.alternateStart) {
            patch(e, (0, h_1.h)('div#alternate-start-block', [
                (0, h_1.h)('label', { attrs: { for: "alternate-start" } }, (0, i18n_1._)("Alternate Start")),
                (0, h_1.h)('select#alternate-start', {
                    props: { name: "alternate-start" },
                    on: { input: () => this.setAlternateStart(variant) },
                    hook: { insert: () => this.setAlternateStart(variant) },
                }, Object.keys(variant.alternateStart).map(alt => (0, h_1.h)('option', { props: { value: alt } }, (0, i18n_1._)(alt)))),
            ]));
        }
        this.setStartButtons();
    }
    setAlternateStart(variant) {
        let e;
        e = document.getElementById('alternate-start');
        const alt = e.options[e.selectedIndex].value;
        e = document.getElementById('fen');
        e.value = variant.alternateStart[alt];
        document.getElementById('chess960').disabled = alt !== "";
        this.setFen();
    }
    setMinutes(val) {
        const minutes = val < this.minutesStrings.length ? this.minutesStrings[val] : String(this.minutesValues[val]);
        document.getElementById("minutes").innerHTML = minutes;
        this.setStartButtons();
    }
    setIncrement(increment) {
        document.getElementById("increment").innerHTML = increment;
        this.setStartButtons();
    }
    setFen() {
        const e = document.getElementById('fen');
        e.setCustomValidity(this.validateFen() ? '' : (0, i18n_1._)('Invalid FEN'));
        this.setStartButtons();
    }
    setCasual(casual) {
        console.log("setCasual", casual);
        this.setStartButtons();
    }
    setRated(rated) {
        console.log("setRated", rated);
        this.setStartButtons();
    }
    setStartButtons() {
        this.validGameData = this.validateTimeControl() && this.validateFen();
        const e = document.getElementById('color-button-group');
        e.classList.toggle("disabled", !this.validGameData);
    }
    validateTimeControl() {
        const min = Number(document.getElementById('min').value);
        const inc = Number(document.getElementById('inc').value);
        const minutes = this.minutesValues[min];
        const e = document.querySelector('input[name="mode"]:checked');
        const rated = e.value === "1";
        const atLeast = (this.challengeAI) ? 4 : min + inc > 0;
        const tooFast = (minutes < 1 && inc === 0) || (minutes === 0 && inc === 1);
        return atLeast && !(tooFast && rated);
    }
    validateFen() {
        const e = document.getElementById('variant');
        const variant = e.options[e.selectedIndex].value;
        const fen = document.getElementById('fen').value;
        return fen === "" || (0, chess_1.validFen)(chess_1.VARIANTS[variant], fen);
    }
    renderSeeks(seeks) {
        seeks.sort((a, b) => (a.bot && !b.bot) ? 1 : -1);
        const rows = seeks.map(seek => this.seekView(seek));
        return [seekHeader(), (0, h_1.h)('tbody', rows)];
    }
    seekView(seek) {
        const variant = chess_1.VARIANTS[seek.variant];
        const chess960 = seek.chess960;
        return this.hide(seek) ? "" : (0, h_1.h)('tr', { on: { click: () => this.onClickSeek(seek) } }, [
            (0, h_1.h)('td', [this.colorIcon(seek.color)]),
            (0, h_1.h)('td', [this.challengeIcon(seek), this.title(seek), this.user(seek)]),
            (0, h_1.h)('td', seek.rating),
            (0, h_1.h)('td', (0, view_1.timeControlStr)(seek.base, seek.inc, seek.byoyomi)),
            (0, h_1.h)('td.icon', { attrs: { "data-icon": variant.icon(chess960) } }, [(0, h_1.h)('variant-name', " " + variant.displayName(chess960))]),
            (0, h_1.h)('td', { class: { tooltip: seek.fen } }, [
                this.tooltip(seek, variant),
                this.mode(seek),
            ]),
        ]);
    }
    onClickSeek(seek) {
        if (seek["user"] === this.model["username"]) {
            this.doSend({ type: "delete_seek", seekID: seek["seekID"], player: this.model["username"] });
        }
        else {
            this.doSend({ type: "accept_seek", seekID: seek["seekID"], player: this.model["username"] });
        }
    }
    colorIcon(color) {
        return (0, h_1.h)('i-side.icon', {
            class: {
                "icon-adjust": color === "r",
                "icon-white": color === "w",
                "icon-black": color === "b",
            }
        });
    }
    challengeIcon(seek) {
        const swords = (seek["user"] === this.model['username']) ? 'vs-swords.lobby.icon' : 'vs-swords.lobby.opp.icon';
        return (seek['target'] === '') ? null : (0, h_1.h)(swords, { attrs: { "data-icon": '"' } });
    }
    title(seek) {
        return (seek['target'] === '') ? (0, h_1.h)('player-title', " " + seek["title"] + " ") : null;
    }
    user(seek) {
        if (seek["target"] === '' || seek["target"] === this.model["username"])
            return seek["user"];
        else
            return seek["target"];
    }
    hide(seek) {
        return ((this.model["anon"] === 'True' || this.model["title"] === 'BOT') && seek["rated"]) ||
            (seek['target'] !== '' && this.model['username'] !== seek['user'] && this.model['username'] !== seek['target']);
    }
    tooltip(seek, variant) {
        let tooltipImage;
        if (seek.fen) {
            tooltipImage = (0, h_1.h)('minigame.' + variant.board + '.' + variant.piece, [
                (0, h_1.h)('div.cg-wrap.' + variant.cg + '.mini', { hook: { insert: (vnode) => (0, chessgroundx_1.Chessground)(vnode.elm, { coordinates: false, fen: seek.fen, geometry: variant.geometry }) } }),
            ]);
        }
        else {
            tooltipImage = '';
        }
        return (0, h_1.h)('span.tooltiptext', [tooltipImage]);
    }
    mode(seek) {
        if (seek.alternateStart)
            return seek.alternateStart;
        else if (seek.fen)
            return (0, i18n_1._)("Custom");
        else if (seek.rated)
            return (0, i18n_1._)("Rated");
        else
            return (0, i18n_1._)("Casual");
    }
    streamView(stream) {
        const url = (stream.site === 'twitch') ? 'https://www.twitch.tv/' : 'https://www.youtube.com/channel/';
        return (0, h_1.h)('a.stream', { attrs: { "href": url + stream.streamer, "rel": "noopener nofollow", "target": "_blank" } }, [
            (0, h_1.h)('strong.text', { class: { "icon": true, "icon-mic": true } }, stream.username),
            stream.title,
        ]);
    }
    spotlightView(spotlight) {
        const variant = chess_1.VARIANTS[spotlight.variant];
        const chess960 = spotlight.chess960;
        const dataIcon = variant.icon(chess960);
        return (0, h_1.h)('a.tour-spotlight', { attrs: { "href": "/tournament/" + spotlight.tid } }, [
            (0, h_1.h)('i.icon', { attrs: { "data-icon": dataIcon } }),
            (0, h_1.h)('span.content', [
                (0, h_1.h)('span.name', spotlight.name),
                (0, h_1.h)('span.more', [
                    (0, h_1.h)('nb', spotlight.nbPlayers + ' players • '),
                    (0, h_1.h)('info-date', { attrs: { "timestamp": spotlight.startsAt } })
                ])
            ])
        ]);
    }
    onMessage(evt) {
        // console.log("<+++ lobby onMessage():", evt.data);
        const msg = JSON.parse(evt.data);
        switch (msg.type) {
            case "get_seeks":
                this.onMsgGetSeeks(msg);
                break;
            case "new_game":
                this.onMsgNewGame(msg);
                break;
            case "game_in_progress":
                this.onMsgGameInProgress(msg);
                break;
            case "lobby_user_connected":
                this.onMsgUserConnected(msg);
                break;
            case "lobbychat":
                this.onMsgChat(msg);
                break;
            case "fullchat":
                this.onMsgFullChat(msg);
                break;
            case "ping":
                this.onMsgPing(msg);
                break;
            case "g_cnt":
                this.onMsgGameCounter(msg);
                break;
            case "u_cnt":
                this.onMsgUserCounter(msg);
                break;
            case "streams":
                this.onMsgStreams(msg);
                break;
            case "spotlights":
                this.onMsgSpotlights(msg);
                break;
            case "invite_created":
                this.onMsgInviteCreated(msg);
                break;
            case "shutdown":
                this.onMsgShutdown(msg);
                break;
            case "error":
                this.onMsgError(msg);
                break;
            case "logout":
                this.doSend({ type: "logout" });
                break;
        }
    }
    onMsgInviteCreated(msg) {
        window.location.assign('/' + msg.gameId);
    }
    onMsgGetSeeks(msg) {
        this.seeks = msg.seeks;
        // console.log("!!!! got get_seeks msg:", msg);
        const oldSeeks = document.getElementById('seeks');
        oldSeeks.innerHTML = "";
        patch(oldSeeks, (0, h_1.h)('table#seeks', this.renderSeeks(msg.seeks)));
    }
    onMsgNewGame(msg) {
        // console.log("LobbyController.onMsgNewGame()", this.model["gameId"])
        window.location.assign('/' + msg.gameId);
    }
    onMsgGameInProgress(msg) {
        const response = confirm((0, i18n_1._)("You have an unfinished game!\nPress OK to continue."));
        if (response)
            window.location.assign('/' + msg.gameId);
    }
    onMsgUserConnected(msg) {
        this.model.username = msg.username;
    }
    onMsgChat(msg) {
        (0, chat_1.chatMessage)(msg.user, msg.message, "lobbychat");
        // seems this is annoying for most of the users
        //if (msg.user.length !== 0 && msg.user !== '_server')
        //    sound.socialNotify();
    }
    onMsgFullChat(msg) {
        // To prevent multiplication of messages we have to remove old messages div first
        patch(document.getElementById('messages'), (0, h_1.h)('div#messages-clear'));
        // then create a new one
        patch(document.getElementById('messages-clear'), (0, h_1.h)('div#messages'));
        // console.log("NEW FULL MESSAGES");
        msg.lines.forEach(line => (0, chat_1.chatMessage)(line.user, line.message, "lobbychat"));
    }
    onMsgPing(msg) {
        this.doSend({ type: "pong", timestamp: msg.timestamp });
    }
    onMsgError(msg) {
        alert(msg.message);
    }
    onMsgShutdown(msg) {
        alert(msg.message);
    }
    onMsgGameCounter(msg) {
        // console.log("Gcnt=", msg.cnt);
        const gameCount = document.getElementById('g_cnt');
        patch(gameCount, (0, h_1.h)('counter#g_cnt', (0, i18n_1.ngettext)('%1 game in play', '%1 games in play', msg.cnt)));
    }
    onMsgUserCounter(msg) {
        // console.log("Ucnt=", msg.cnt);
        const userCount = document.getElementById('u_cnt');
        patch(userCount, (0, h_1.h)('counter#u_cnt', (0, i18n_1.ngettext)('%1 player', '%1 players', msg.cnt)));
    }
    onMsgStreams(msg) {
        this.streams = patch(this.streams, (0, h_1.h)('div#streams', msg.items.map(stream => this.streamView(stream))));
    }
    onMsgSpotlights(msg) {
        this.spotlights = patch(this.spotlights, (0, h_1.h)('div#spotlights', msg.items.map(spotlight => this.spotlightView(spotlight))));
    }
}
exports.LobbyController = LobbyController;
function seekHeader() {
    return (0, h_1.h)('thead', [
        (0, h_1.h)('tr', [
            (0, h_1.h)('th', [(0, h_1.h)('div#santa')]),
            (0, h_1.h)('th', (0, i18n_1._)('Player')),
            (0, h_1.h)('th', (0, i18n_1._)('Rating')),
            (0, h_1.h)('th', (0, i18n_1._)('Time')),
            (0, h_1.h)('th', (0, i18n_1._)('Variant')),
            (0, h_1.h)('th', (0, i18n_1._)('Mode'))
        ])
    ]);
}
function runSeeks(vnode, model) {
    const el = vnode.elm;
    new LobbyController(el, model);
    // console.log("lobbyView() -> runSeeks()", el, model, ctrl);
}
function lobbyView(model) {
    /* TODO move this to appropriate place
    // Get the modal
    const modal = document.getElementById('id01')!;

    // When the user clicks anywhere outside of the modal, close it
    document.addEventListener("click", function(event) {
        if (!modal.contains(event.target as Node))
            modal.style.display = "none";
    });
    */
    boardSettings_1.boardSettings.updateBoardAndPieceStyles();
    if (model['anon'] === 'False') {
        const evtSource = new EventSource(model["home"] + "/api/notify");
        // console.log("new EventSource" + model["home"] + "/api/notify");
        evtSource.onmessage = e => {
            const message = JSON.parse(e.data);
            console.log(message);
            sound_1.sound.socialNotify();
        };
    }
    return [
        (0, h_1.h)('aside.sidebar-first', [
            (0, h_1.h)('div#streams'),
            (0, h_1.h)('div#spotlights'),
            (0, h_1.h)('div#lobbychat')
        ]),
        (0, h_1.h)('div.seeks', [
            (0, h_1.h)('div#seeks-table', [
                (0, h_1.h)('div#seeks-wrapper', (0, h_1.h)('table#seeks', { hook: { insert: vnode => runSeeks(vnode, model) } })),
            ]),
        ]),
        (0, h_1.h)('div#variants-catalog'),
        (0, h_1.h)('aside.sidebar-second', [(0, h_1.h)('div#seekbuttons')]),
        (0, h_1.h)('under-left', [
            (0, h_1.h)('a.reflist', { attrs: { href: 'https://discord.gg/aPs8RKr' } }, 'Discord'),
            (0, h_1.h)('a.reflist', { attrs: { href: 'https://github.com/gbtami/pychess-variants' } }, 'Github'),
            (0, h_1.h)('a.reflist', { attrs: { href: '/patron' } }, (0, i18n_1._)("Donate")),
            (0, h_1.h)('a.reflist', { attrs: { href: '/faq' } }, (0, i18n_1._)("FAQ")),
            (0, h_1.h)('a.reflist', { attrs: { href: '/stats' } }, (0, i18n_1._)("Stats")),
            (0, h_1.h)('a.reflist', { attrs: { href: '/about' } }, (0, i18n_1._)("About")),
        ]),
        (0, h_1.h)('under-lobby', [
            (0, h_1.h)('news-latest', [
                (0, h_1.h)('icon', { attrs: { "data-icon": '2' } }),
                (0, h_1.h)('a.reflist', { attrs: { href: '/news' } }, (0, i18n_1._)("Latest updates")),
            ]),
            (0, h_1.h)('posts', [
                // TODO: create news documents in mongodb and load latest 3 dinamically here
                (0, h_1.h)('a.post', { attrs: { href: '/news/Hot_Summer' } }, [
                    (0, h_1.h)('img', { attrs: { src: model["asset-url"] + '/images/AngryBirds.png' } }),
                    (0, h_1.h)('span.text', [
                        (0, h_1.h)('strong', "New variant, new engine and more"),
                        (0, h_1.h)('span', 'Hot summer'),
                    ]),
                    (0, h_1.h)('time', '2021.09.02'),
                ]),
                (0, h_1.h)('a.post', { attrs: { href: '/news/Empire_Chess_and_Orda_Mirror_Have_Arrived' } }, [
                    (0, h_1.h)('img', { attrs: { src: model["asset-url"] + '/images/Darth-Vader-Comic.jpg' } }),
                    (0, h_1.h)('span.text', [
                        (0, h_1.h)('strong', "Empire Chess and Orda Mirror Have Arrived!"),
                        (0, h_1.h)('span', 'New variants'),
                    ]),
                    (0, h_1.h)('time', '2021.07.30'),
                ]),
                (0, h_1.h)('a.post', { attrs: { href: '/news/Shinobi_Arrives_in_Time_For_the_Sakura_Blossoms' } }, [
                    (0, h_1.h)('img', { attrs: { src: model["asset-url"] + '/icons/shinobi.svg' } }),
                    (0, h_1.h)('span.text', [
                        (0, h_1.h)('strong', "Shinobi Arrives in Time For the Sakura Blossoms"),
                        (0, h_1.h)('span', 'Shinobi Chess has arrived!'),
                    ]),
                    (0, h_1.h)('time', '2021.04.21'),
                ]),
                /*
                h('a.post', { attrs: {href: '/news/The_Winner_Is_Tasshaq'} }, [
                    h('img', { attrs: {src: model["asset-url"] + '/icons/Dobutsu.svg'} }),
                    h('span.text', [
                        h('strong', "And the winner is Tasshaq"),
                        h('span', 'Subjective report on 1st Dōbutsu Tournament'),
                    ]),
                    h('time', '2021.03.28'),
                ]),
                h('a.post', { attrs: {href: '/news/New_Weapons_Arrived'} }, [
                    h('img', { attrs: {src: model["asset-url"] + '/images/RS-24.jpg'} }),
                    h('span.text', [
                        h('strong', "Atomic chess and Atomic960 are here"),
                        h('span', 'New Weapons Arrived'),
                    ]),
                    h('time', '2021.03.03'),
                ]),
                h('a.post', { attrs: {href: '/news/Short_History_Of_Pychess'} }, [
                    h('img', { attrs: {src: model["asset-url"] + '/images/TomatoPlasticSet.svg'} }),
                    h('span.text', [
                        h('strong', "And Now for Something Completely Different"),
                        h('span', 'Short History Of Pychess'),
                    ]),
                    h('time', '2021.02.27'),
                ]),
                h('a.post', { attrs: {href: '/news/Dobutsu_Tournament'} }, [
                    h('img', { attrs: {src: model["asset-url"] + '/icons/Dobutsu.svg'} }),
                    h('span.text', [
                        h('strong', "PyChess tournament announcement"),
                        h('span', 'The 1st Dōbutsu Tournament on PyChess'),
                    ]),
                    h('time', '2021.02.04'),
                ]),
                */
            ]),
        ]),
        (0, h_1.h)('under-right', [
            (0, h_1.h)('a', { attrs: { href: '/players' } }, [(0, h_1.h)('counter#u_cnt')]),
            (0, h_1.h)('a', { attrs: { href: '/games' } }, [(0, h_1.h)('counter#g_cnt')]),
        ]),
    ];
}
exports.lobbyView = lobbyView;

},{"./boardSettings":5,"./chat":7,"./chess":8,"./i18n":18,"./lobby/layer1":23,"./notification":33,"./sound":45,"./view":49,"chessgroundx":55,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92,"sockette":97}],23:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.variantBoard = exports.goBackToLayer1 = exports.variantPanels = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default, style_1.default]);
const h_1 = require("snabbdom/h");
const chessgroundx_1 = require("chessgroundx");
const i18n_1 = require("../i18n");
const document_1 = require("../document");
const chess_1 = require("../chess");
const layer2chess_1 = require("./layer2chess");
const layer2fairy_1 = require("./layer2fairy");
const layer2army_1 = require("./layer2army");
const layer2makruk_1 = require("./layer2makruk");
const layer2shogi_1 = require("./layer2shogi");
const layer2xiangqi_1 = require("./layer2xiangqi");
function variantPanels(lobbyCtrl) {
    const assetUrl = lobbyCtrl.model['asset-url'];
    for (const family of Object.keys(chess_1.BOARD_FAMILIES)) {
        let css;
        switch (family) {
            case 'makruk8x8':
                css = 'makruk.jpg';
                break;
            case 'shogi9x9':
                css = 'ShogiOak.png';
                break;
            case 'shogi7x7':
                css = 'ToriWood.svg';
                break;
            case 'shogi5x5':
                css = 'MiniboardWood1.png';
                break;
            case 'shogi5x6':
                css = 'GorogoroWood.png';
                break;
            case 'xiangqi9x10':
                css = 'xiangqiWood.png';
                break;
            case 'xiangqi7x7':
                css = 'minixiangqiw.png';
                break;
            case 'janggi9x10':
                css = 'JanggiWood.png';
                break;
            default:
                css = chess_1.BOARD_FAMILIES[family].boardCSS[0];
                break;
        }
        ;
        (0, document_1.changeBoardCSS)(assetUrl, family, css);
    }
    for (const family of Object.keys(chess_1.PIECE_FAMILIES)) {
        let css;
        switch (family) {
            case 'standard':
                css = 'green';
                break;
            case 'makruk':
                css = 'makrukwb';
                break;
            case 'shogi':
                css = 'shogikw3d';
                break;
            case 'kyoto':
                css = 'kyotok';
                break;
            case 'xiangqi':
                css = 'xiangqihnzw';
                break;
            case 'xiangqi':
                css = 'xiangqihnzw';
                break;
            case 'janggi':
                css = 'janggikaw';
                break;
            default:
                css = chess_1.PIECE_FAMILIES[family].pieceCSS[0];
                break;
        }
        ;
        (0, document_1.changePieceCSS)(assetUrl, family, css);
    }
    return (0, h_1.h)('div#panel-container.panel-container', [
        (0, h_1.h)('div#variantcont.variants-container', [
            (0, h_1.h)('button#layer1chess.variant-category.chess', { on: { click: () => (0, layer2chess_1.layer2chess)(lobbyCtrl, 'panel-container') } }, [
                (0, h_1.h)('div.variant-title', [(0, h_1.h)('h3', (0, i18n_1._)('Chess Variants'))]),
                (0, h_1.h)('div.piece-container', [
                    (0, h_1.h)('img.sliding-pieces.wR', { attrs: { src: assetUrl + '/images/pieces/merida/wR.svg' } }),
                    (0, h_1.h)('img.wK', { attrs: { src: assetUrl + '/images/pieces/merida/wK.svg' } }),
                    (0, h_1.h)('img.sliding-pieces.wB', { attrs: { src: assetUrl + '/images/pieces/merida/wB.svg' } }),
                ]),
            ]),
            (0, h_1.h)('button#layer1fairy.variant-category.fairy', { on: { click: () => (0, layer2fairy_1.layer2fairy)(lobbyCtrl, 'panel-container') } }, [
                (0, h_1.h)('div.variant-title', [(0, h_1.h)('h3', (0, i18n_1._)('Fairy Piece Variants'))]),
                (0, h_1.h)('div.piece-container', [
                    (0, h_1.h)('img.sliding-pieces.wE', { attrs: { src: assetUrl + '/images/pieces/merida/shako/wE.svg' } }),
                    (0, h_1.h)('img.wC', { attrs: { src: assetUrl + '/images/pieces/merida/wC.svg' } }),
                    (0, h_1.h)('img.sliding-pieces.wH', { attrs: { src: assetUrl + '/images/pieces/merida/wH.svg' } }),
                ]),
            ]),
            (0, h_1.h)('button#layer1army.variant-category.army', { on: { click: () => (0, layer2army_1.layer2army)(lobbyCtrl, 'panel-container') } }, [
                (0, h_1.h)('div.variant-title', [(0, h_1.h)('h3', (0, i18n_1._)('New Army Variants'))]),
                (0, h_1.h)('div.piece-container', [
                    (0, h_1.h)('img.sliding-pieces.wJ', { attrs: { src: assetUrl + '/images/pieces/shinobi/merida/wJ.svg' } }),
                    (0, h_1.h)('img.bK', { attrs: { src: assetUrl + '/images/pieces/orda/merida/bK.svg' } }),
                    (0, h_1.h)('img.sliding-pieces.wD', { attrs: { src: assetUrl + '/images/pieces/empire/merida/wD.svg' } }),
                ]),
            ]),
            (0, h_1.h)('button#layer1makruk.variant-category.makruk', { on: { click: () => (0, layer2makruk_1.layer2makruk)(lobbyCtrl, 'panel-container') } }, [
                (0, h_1.h)('div.variant-title', [(0, h_1.h)('h3', (0, i18n_1._)('Makruk Variants'))]),
                (0, h_1.h)('div.piece-container', [
                    (0, h_1.h)('img.sliding-pieces.mN', { attrs: { src: assetUrl + '/images/pieces/makruk/cambodian/wP.svg' } }),
                    (0, h_1.h)('img.mK', { attrs: { src: assetUrl + '/images/pieces/makruk/ada/wK.svg' } }),
                    (0, h_1.h)('img.sliding-pieces.sQ', { attrs: { src: assetUrl + '/images/pieces/sittuyin/Ka_blackred/wP.svg' } }),
                ]),
            ]),
            (0, h_1.h)('button#layer1shogi.variant-category.shogi', { on: { click: () => (0, layer2shogi_1.layer2shogi)(lobbyCtrl, 'panel-container') } }, [
                (0, h_1.h)('div.variant-title', [(0, h_1.h)('h3', (0, i18n_1._)('Shogi Variants'))]),
                (0, h_1.h)('div.piece-container', [
                    (0, h_1.h)('img.sliding-pieces.ONG', { attrs: { src: assetUrl + '/images/pieces/shogi/ctk/0KI.svg' } }),
                    (0, h_1.h)('img.OGY', { attrs: { src: assetUrl + '/images/pieces/shogi/2kanji/0GY.svg' } }),
                    (0, h_1.h)('img.sliding-pieces.OKI', { attrs: { src: assetUrl + '/images/pieces/shogi/ctp/0KI.svg' } }),
                ]),
            ]),
            (0, h_1.h)('button#layer1xiangqi.variant-category.xiangqi', { on: { click: () => (0, layer2xiangqi_1.layer2xiangqi)(lobbyCtrl, 'panel-container') } }, [
                (0, h_1.h)('div.variant-title', [(0, h_1.h)('h3', (0, i18n_1._)('Xiangqi Variants'))]),
                (0, h_1.h)('div.piece-container', [
                    (0, h_1.h)('img.sliding-pieces.xC', { attrs: { src: assetUrl + '/images/pieces/xiangqi/ct2/black_cannon2.svg' } }),
                    (0, h_1.h)('img.xK', { attrs: { src: assetUrl + '/images/pieces/xiangqi/hnz/black_king.svg' } }),
                    (0, h_1.h)('img.sliding-pieces.jK', { attrs: { src: assetUrl + '/images/pieces/janggi/hanjablue/blue_king.svg' } }),
                ]),
            ]),
        ]),
    ]);
}
exports.variantPanels = variantPanels;
function goBackToLayer1(lobbyCtrl, containerId) {
    const container = document.getElementById(containerId);
    if (container)
        patch(container, variantPanels(lobbyCtrl));
}
exports.goBackToLayer1 = goBackToLayer1;
function variantBoard(variant, fen, check = false, lastMove = undefined) {
    return (0, h_1.h)(`selection#mainboard.${variant.board}.${variant.piece}`, [
        (0, h_1.h)(`div.cg-wrap.${variant.cg}`, {
            hook: {
                insert: vnode => {
                    (0, chessgroundx_1.Chessground)(vnode.elm, {
                        fen: fen,
                        turnColor: fen.split(" ")[1] === "b" ? "white" : "black",
                        check: check,
                        lastMove: lastMove,
                        geometry: variant.geometry,
                        coordinates: false,
                        viewOnly: true
                    });
                }
            }
        }),
    ]);
}
exports.variantBoard = variantBoard;

},{"../chess":8,"../document":13,"../i18n":18,"./layer2army":24,"./layer2chess":25,"./layer2fairy":26,"./layer2makruk":27,"./layer2shogi":28,"./layer2xiangqi":29,"chessgroundx":55,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92}],24:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.layer2army = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default, style_1.default]);
const h_1 = require("snabbdom/h");
const i18n_1 = require("../i18n");
const chess_1 = require("../chess");
const layer1_1 = require("./layer1");
const layer3_1 = require("./layer3");
function layer2army(lobbyCtrl, containerId) {
    const assetUrl = lobbyCtrl.model['asset-url'];
    const layer2cont = (0, h_1.h)('div#layer2armycont.layer-2-container.fairy-grid', [
        (0, h_1.h)('button.layer-2-category generic-variant-info.generic-fairy', [
            (0, h_1.h)('div.layer-two-category-info', [
                (0, h_1.h)('h4', (0, i18n_1._)('New Army Variants')),
                (0, h_1.h)('div.generic-image-container.fourarmykings', [(0, h_1.h)('img', { attrs: { src: assetUrl + "/images/4ArmyKings.svg" } })]),
                (0, h_1.h)('p.variant-category-description', (0, i18n_1._)('These variants have new armies with completely new pieces! Most of these variants pit these armies against the standard Chess army.')),
                (0, h_1.h)('h5#armyl2back', { class: { "icon": true, "icon-reply": true }, on: { click: () => (0, layer1_1.goBackToLayer1)(lobbyCtrl, 'layer2armycont') } }, (0, i18n_1._)('Go Back')),
            ]),
        ]),
        (0, h_1.h)('button.layer-2-category.capablanca', { on: { click: () => (0, layer3_1.layer3variant)('layer2armycont', lobbyCtrl, 'orda', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['orda'].icon(false) } }),
                (0, h_1.h)('h3', 'Orda'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Horde: Horse-based army')),
        ]),
        (0, h_1.h)('button.layer-2-category.schess', { on: { click: () => (0, layer3_1.layer3variant)('layer2armycont', lobbyCtrl, 'empire', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['empire'].icon(false) } }),
                (0, h_1.h)('h3', 'Empire'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Empire: Queen-based army')),
        ]),
        (0, h_1.h)('button.layer-2-category.shako', { on: { click: () => (0, layer3_1.layer3variant)('layer2armycont', lobbyCtrl, 'ordamirror', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['ordamirror'].icon(false) } }),
                (0, h_1.h)('h3', 'Orda Mirror'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Horde vs Horde')),
        ]),
        (0, h_1.h)('button.layer-2-category.grand', { on: { click: () => (0, layer3_1.layer3variant)('layer2armycont', lobbyCtrl, 'shinobi', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['shinobi'].icon(false) } }),
                (0, h_1.h)('h3', 'Shinobi'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Clan: Drop-based army')),
        ]),
        (0, h_1.h)('button.layer-2-category.shogun', { on: { click: () => (0, layer3_1.layer3variant)('layer2armycont', lobbyCtrl, 'synochess', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['synochess'].icon(false) } }),
                (0, h_1.h)('h3', 'Synochess'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Dynasty: Xiangqi-based army')),
        ]),
    ]);
    const container = document.getElementById(containerId);
    if (container)
        patch(container, layer2cont);
}
exports.layer2army = layer2army;

},{"../chess":8,"../i18n":18,"./layer1":23,"./layer3":30,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92}],25:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.layer2chess = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default, style_1.default]);
const h_1 = require("snabbdom/h");
const i18n_1 = require("../i18n");
const chess_1 = require("../chess");
const layer1_1 = require("./layer1");
const layer3_1 = require("./layer3");
function layer2chess(lobbyCtrl, containerId) {
    const chess = chess_1.VARIANTS['chess'];
    const placement = chess_1.VARIANTS['placement'];
    const crazyhouse = chess_1.VARIANTS['crazyhouse'];
    const atomic = chess_1.VARIANTS['atomic'];
    const layer2cont = (0, h_1.h)('div#layer2chesscont.layer-2-container', [
        (0, h_1.h)('button.layer-2-category generic-variant-info.generic', [
            (0, h_1.h)('div.layer-two-category-info', [
                (0, h_1.h)('h4', (0, i18n_1._)('Chess Variants')),
                (0, layer1_1.variantBoard)(chess, chess.startFen),
                (0, h_1.h)('p.variant-category-description', (0, i18n_1._)('Variants using a basic chess set but with different rules.')),
                (0, h_1.h)('h5#chessl2back', { class: { "icon": true, "icon-reply": true }, on: { click: () => (0, layer1_1.goBackToLayer1)(lobbyCtrl, 'layer2chesscont') } }, (0, i18n_1._)('Go Back')),
            ]),
        ]),
        (0, h_1.h)('button.layer-2-category.chess-l2', { on: { click: () => (0, layer3_1.layer3variant)('layer2chesscont', lobbyCtrl, 'chess', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess.icon(false) } }),
                (0, h_1.h)('h3', 'Chess')
            ]),
        ]),
        (0, h_1.h)('button.layer-2-category.chess960', { on: { click: () => (0, layer3_1.layer3variant)('layer2chesscont', lobbyCtrl, 'chess', true) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess.icon(true) } }),
                (0, h_1.h)('h3', 'Chess960')
            ]),
        ]),
        (0, h_1.h)('button.layer-2-category.placement', { on: { click: () => (0, layer3_1.layer3variant)('layer2chesscont', lobbyCtrl, 'placement', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': placement.icon(false) } }),
                (0, h_1.h)('h3', 'Placement')
            ]),
        ]),
        (0, h_1.h)('button.layer-2-category.crazyhouse', { on: { click: () => (0, layer3_1.layer3variant)('layer2chesscont', lobbyCtrl, 'crazyhouse', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': crazyhouse.icon(false) } }),
                (0, h_1.h)('h3', 'Crazyhouse')
            ]),
        ]),
        (0, h_1.h)('button.layer-2-category.crazyhouse960', { on: { click: () => (0, layer3_1.layer3variant)('layer2chesscont', lobbyCtrl, 'crazyhouse', true) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': crazyhouse.icon(true) } }),
                (0, h_1.h)('h3', 'Crazyhouse960')
            ]),
        ]),
        (0, h_1.h)('button.layer-2-category.atomic', { on: { click: () => (0, layer3_1.layer3variant)('layer2chesscont', lobbyCtrl, 'atomic', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': atomic.icon(false) } }),
                (0, h_1.h)('h3', 'Atomic')
            ]),
        ]),
        (0, h_1.h)('button.layer-2-category.atomic960', { on: { click: () => (0, layer3_1.layer3variant)('layer2chesscont', lobbyCtrl, 'atomic', true) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': atomic.icon(true) } }),
                (0, h_1.h)('h3', 'Atomic960')
            ]),
        ]),
    ]);
    const container = document.getElementById(containerId);
    if (container)
        patch(container, layer2cont);
}
exports.layer2chess = layer2chess;

},{"../chess":8,"../i18n":18,"./layer1":23,"./layer3":30,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92}],26:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.layer2fairy = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default, style_1.default]);
const h_1 = require("snabbdom/h");
const i18n_1 = require("../i18n");
const chess_1 = require("../chess");
const layer1_1 = require("./layer1");
const layer3_1 = require("./layer3");
function layer2fairy(lobbyCtrl, containerId) {
    const assetUrl = lobbyCtrl.model['asset-url'];
    const layer2cont = (0, h_1.h)('div#layer2fairycont.layer-2-container.fairy-grid', [
        (0, h_1.h)('button.layer-2-category generic-variant-info.generic-fairy', [
            (0, h_1.h)('div.layer-two-category-info', [
                (0, h_1.h)('h4', (0, i18n_1._)('Fairy Piece Variants')),
                (0, h_1.h)('div.generic-image-container.fourarmykings', [(0, h_1.h)('img', { attrs: { src: assetUrl + "/images/4FairyPieces.svg" } })]),
                (0, h_1.h)('p.variant-category-description', (0, i18n_1._)('These variants have new pieces to try! Many of them have larger boards, and some also have new rules.')),
                (0, h_1.h)('p.variant-category-description', [
                    (0, h_1.h)('img', { attrs: { src: assetUrl + '/icons/960.svg' } }),
                    (0, h_1.h)('span', (0, i18n_1._)(' = Random (960) variant available. ')),
                    (0, h_1.h)('br'),
                    (0, h_1.h)('img', { attrs: { src: assetUrl + '/icons/Crazyhouse.svg' } }),
                    (0, h_1.h)('span', (0, i18n_1._)(' = Drop variant available.')),
                ]),
                (0, h_1.h)('h5#fairyl2back', { class: { "icon": true, "icon-reply": true }, on: { click: () => (0, layer1_1.goBackToLayer1)(lobbyCtrl, 'layer2fairycont') } }, (0, i18n_1._)('Go Back')),
            ]),
        ]),
        (0, h_1.h)('button.layer-2-category.capablanca', { on: { click: () => (0, layer3_1.layer3variant)('layer2fairycont', lobbyCtrl, 'capablanca', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['capablanca'].icon(false) } }),
                (0, h_1.h)('h3', 'Capablanca'),
            ]),
            (0, h_1.h)('div.option-icon-container', [
                (0, h_1.h)('img', { attrs: { src: assetUrl + '/icons/Crazyhouse.svg' } }),
                (0, h_1.h)('img', { attrs: { src: assetUrl + '/icons/960.svg' } }),
                (0, h_1.h)('img', { attrs: { src: assetUrl + '/icons/Crazyhouse960.svg' } }),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Knight hybrid pieces')),
        ]),
        (0, h_1.h)('button.layer-2-category.schess', { on: { click: () => (0, layer3_1.layer3variant)('layer2fairycont', lobbyCtrl, 'seirawan', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['seirawan'].icon(false) } }),
                (0, h_1.h)('h3', 'S-Chess'),
            ]),
            (0, h_1.h)('div.option-icon-container', [
                (0, h_1.h)('img', { attrs: { src: assetUrl + '/icons/Crazyhouse.svg' } }),
                (0, h_1.h)('img', { attrs: { src: assetUrl + '/icons/960.svg' } }),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('8x8 with new pieces')),
        ]),
        (0, h_1.h)('button.layer-2-category.shako', { on: { click: () => (0, layer3_1.layer3variant)('layer2fairycont', lobbyCtrl, 'shako', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['shako'].icon(false) } }),
                (0, h_1.h)('h3', 'Shako'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Cannon and Elephant from Xiangqi')),
        ]),
        (0, h_1.h)('button.layer-2-category.grand', { on: { click: () => (0, layer3_1.layer3variant)('layer2fairycont', lobbyCtrl, 'grand', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['grand'].icon(false) } }),
                (0, h_1.h)('h3', 'Grand'),
            ]),
            (0, h_1.h)('div.option-icon-container', [
                (0, h_1.h)('img', { attrs: { src: assetUrl + '/icons/Crazyhouse.svg' } }),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('10x10 with new pieces')),
        ]),
        (0, h_1.h)('button.layer-2-category.shogun', { on: { click: () => (0, layer3_1.layer3variant)('layer2fairycont', lobbyCtrl, 'shogun', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['shogun'].icon(false) } }),
                (0, h_1.h)('h3', 'Shogun'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Crazyhouse with promotions')),
        ]),
        (0, h_1.h)('button.layer-2-category.hoppelpoppel', { on: { click: () => (0, layer3_1.layer3variant)('layer2fairycont', lobbyCtrl, 'hoppelpoppel', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['hoppelpoppel'].icon(false) } }),
                (0, h_1.h)('h3', 'Hoppel-poppel'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Bishops and Knights swap their capture moves')),
        ]),
    ]);
    const container = document.getElementById(containerId);
    if (container)
        patch(container, layer2cont);
}
exports.layer2fairy = layer2fairy;

},{"../chess":8,"../i18n":18,"./layer1":23,"./layer3":30,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92}],27:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.layer2makruk = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default, style_1.default]);
const h_1 = require("snabbdom/h");
const i18n_1 = require("../i18n");
const chess_1 = require("../chess");
const layer1_1 = require("./layer1");
const layer3_1 = require("./layer3");
function layer2makruk(lobbyCtrl, containerId) {
    const variant = chess_1.VARIANTS['makruk'];
    const layer2cont = (0, h_1.h)('div#layer2makrukcont.layer-2-container.fairy-grid.two-grid', [
        (0, h_1.h)('button.layer-2-category generic-variant-info.generic-makruk', [
            (0, h_1.h)('div.layer-two-category-info', [
                (0, h_1.h)('h4', (0, i18n_1._)('Makruk Variants')),
                (0, layer1_1.variantBoard)(variant, variant.startFen),
                (0, h_1.h)('p.variant-category-description.makruk-desc', (0, i18n_1._)('Southeast Asian variants, closely related to Western Chess.')),
                (0, h_1.h)('h5#makrukl2back', { class: { "icon": true, "icon-reply": true }, on: { click: () => (0, layer1_1.goBackToLayer1)(lobbyCtrl, 'layer2makrukcont') } }, (0, i18n_1._)('Go Back')),
            ]),
        ]),
        (0, h_1.h)('button.layer-2-category.makrukl2', { on: { click: () => (0, layer3_1.layer3variant)('layer2makrukcont', lobbyCtrl, 'makruk', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['makruk'].icon(false) } }),
                (0, h_1.h)('h3', 'Makruk'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Thai Chess. Similar to Chess but with a different queen and bishop.')),
        ]),
        (0, h_1.h)('button.layer-2-category.makpong', { on: { click: () => (0, layer3_1.layer3variant)('layer2makrukcont', lobbyCtrl, 'makpong', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['makpong'].icon(false) } }),
                (0, h_1.h)('h3', 'Makpong'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Makruk variant. Kings cannot move when checked.')),
        ]),
        (0, h_1.h)('button.layer-2-category.chatrang', { on: { click: () => (0, layer3_1.layer3variant)('layer2makrukcont', lobbyCtrl, 'cambodian', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['cambodian'].icon(false) } }),
                (0, h_1.h)('h3', 'Ouk Chatrang'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Cambodian Chess. Makruk with extra starting moves.')),
        ]),
        (0, h_1.h)('button.layer-2-category.sittuyin', { on: { click: () => (0, layer3_1.layer3variant)('layer2makrukcont', lobbyCtrl, 'sittuyin', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['sittuyin'].icon(false) } }),
                (0, h_1.h)('h3', 'Sittuyin'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Burmese Chess. You may place your starting pieces.')),
        ]),
    ]);
    const container = document.getElementById(containerId);
    if (container)
        patch(container, layer2cont);
}
exports.layer2makruk = layer2makruk;

},{"../chess":8,"../i18n":18,"./layer1":23,"./layer3":30,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92}],28:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.layer2shogi = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default, style_1.default]);
const h_1 = require("snabbdom/h");
const i18n_1 = require("../i18n");
const chess_1 = require("../chess");
const layer1_1 = require("./layer1");
const layer3_1 = require("./layer3");
function layer2shogi(lobbyCtrl, containerId) {
    const variant = chess_1.VARIANTS['shogi'];
    const layer2cont = (0, h_1.h)('div#layer2shogicont.layer-2-container.fairy-grid', [
        (0, h_1.h)('button.layer-2-category generic-variant-info.generic-fairy', [
            (0, h_1.h)('div.layer-two-category-info', [
                (0, h_1.h)('h4', (0, i18n_1._)('Shogi Variants')),
                (0, layer1_1.variantBoard)(variant, variant.startFen),
                (0, h_1.h)('p.variant-category-description.shogi-desc', (0, i18n_1._)('The Japanese version of chess, which involves drops and promotions.')),
                (0, h_1.h)('h5#shogil2back', { class: { "icon": true, "icon-reply": true }, on: { click: () => (0, layer1_1.goBackToLayer1)(lobbyCtrl, 'layer2shogicont') } }, (0, i18n_1._)('Go Back')),
            ]),
        ]),
        (0, h_1.h)('button.layer-2-category.capablanca', { on: { click: () => (0, layer3_1.layer3variant)('layer2shogicont', lobbyCtrl, 'shogi', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['shogi'].icon(false) } }),
                (0, h_1.h)('h3', 'Shogi'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Original Shogi')),
        ]),
        (0, h_1.h)('button.layer-2-category.schess', { on: { click: () => (0, layer3_1.layer3variant)('layer2shogicont', lobbyCtrl, 'minishogi', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['minishogi'].icon(false) } }),
                (0, h_1.h)('h3', 'Minishogi'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('5x5 Shogi')),
        ]),
        (0, h_1.h)('button.layer-2-category.shako', { on: { click: () => (0, layer3_1.layer3variant)('layer2shogicont', lobbyCtrl, 'kyotoshogi', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['kyotoshogi'].icon(false) } }),
                (0, h_1.h)('h3', 'Kyoto Shogi'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('5x5, pieces flip each turn')),
        ]),
        (0, h_1.h)('button.layer-2-category.grand', { on: { click: () => (0, layer3_1.layer3variant)('layer2shogicont', lobbyCtrl, 'dobutsu', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['dobutsu'].icon(false) } }),
                (0, h_1.h)('h3', 'Dobutsu'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('3x4 game to teach Shogi')),
        ]),
        (0, h_1.h)('button.layer-2-category.shogun', { on: { click: () => (0, layer3_1.layer3variant)('layer2shogicont', lobbyCtrl, 'gorogoro', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['gorogoro'].icon(false) } }),
                (0, h_1.h)('h3', 'Gorogoro'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('5x6 with Generals')),
        ]),
        (0, h_1.h)('button.layer-2-category.hoppelpoppel', { on: { click: () => (0, layer3_1.layer3variant)('layer2shogicont', lobbyCtrl, 'torishogi', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['torishogi'].icon(false) } }),
                (0, h_1.h)('h3', 'Tori Shogi'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('7x7, Bird Shogi')),
        ]),
    ]);
    const container = document.getElementById(containerId);
    if (container)
        patch(container, layer2cont);
}
exports.layer2shogi = layer2shogi;

},{"../chess":8,"../i18n":18,"./layer1":23,"./layer3":30,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92}],29:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.layer2xiangqi = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default, style_1.default]);
const h_1 = require("snabbdom/h");
const i18n_1 = require("../i18n");
const chess_1 = require("../chess");
const layer1_1 = require("./layer1");
const layer3_1 = require("./layer3");
function layer2xiangqi(lobbyCtrl, containerId) {
    const variant = chess_1.VARIANTS['xiangqi'];
    const layer2cont = (0, h_1.h)('div#layer2xiangqicont.layer-2-container.fairy-grid.two-grid', [
        (0, h_1.h)('button.layer-2-category generic-variant-info.generic-makruk', [
            (0, h_1.h)('div.layer-two-category-info', [
                (0, h_1.h)('h4', (0, i18n_1._)('Xiangqi Variants')),
                (0, layer1_1.variantBoard)(variant, variant.startFen),
                (0, h_1.h)('p.variant-category-description.makruk-desc', (0, i18n_1._)('The ancient game of Chinese Chess and its variants.')),
                (0, h_1.h)('h5#xiangqil2back', { class: { "icon": true, "icon-reply": true }, on: { click: () => (0, layer1_1.goBackToLayer1)(lobbyCtrl, 'layer2xiangqicont') } }, (0, i18n_1._)('Go Back')),
            ]),
        ]),
        (0, h_1.h)('button.layer-2-category.makrukl2', { on: { click: () => (0, layer3_1.layer3variant)('layer2xiangqicont', lobbyCtrl, 'xiangqi', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['xiangqi'].icon(false) } }),
                (0, h_1.h)('h3', 'Xiangqi'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Chinese Chess, one of the most played games in the world')),
        ]),
        (0, h_1.h)('button.layer-2-category.chatrang', { on: { click: () => (0, layer3_1.layer3variant)('layer2xiangqicont', lobbyCtrl, 'janggi', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['janggi'].icon(false) } }),
                (0, h_1.h)('h3', 'Janggi'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Korean Chess, based on Xiangqi but very different')),
        ]),
        (0, h_1.h)('button.layer-2-category.makpong', { on: { click: () => (0, layer3_1.layer3variant)('layer2xiangqicont', lobbyCtrl, 'minixiangqi', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['minixiangqi'].icon(false) } }),
                (0, h_1.h)('h3', 'Minixiangqi'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Compact Xiangqi on a 7x7 board')),
        ]),
        (0, h_1.h)('button.layer-2-category.sittuyin', { on: { click: () => (0, layer3_1.layer3variant)('layer2xiangqicont', lobbyCtrl, 'manchu', false) } }, [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': chess_1.VARIANTS['manchu'].icon(false) } }),
                (0, h_1.h)('h3', 'Manchu'),
            ]),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Asymmetric variant with one side having a super piece')),
        ]),
    ]);
    const container = document.getElementById(containerId);
    if (container)
        patch(container, layer2cont);
}
exports.layer2xiangqi = layer2xiangqi;

},{"../chess":8,"../i18n":18,"./layer1":23,"./layer3":30,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92}],30:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.layer3variant = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default, style_1.default]);
const h_1 = require("snabbdom/h");
const i18n_1 = require("../i18n");
const chess_1 = require("../chess");
const layer1_1 = require("./layer1");
const layer2chess_1 = require("./layer2chess");
const layer2fairy_1 = require("./layer2fairy");
const layer2army_1 = require("./layer2army");
const layer2makruk_1 = require("./layer2makruk");
const layer2shogi_1 = require("./layer2shogi");
const layer2xiangqi_1 = require("./layer2xiangqi");
function layer3variant(container2Id, lobbyCtrl, variantName, chess960) {
    const variant = chess_1.VARIANTS[variantName];
    let leve2func, container3Id;
    switch (container2Id) {
        case 'layer2chesscont':
            leve2func = layer2chess_1.layer2chess;
            container3Id = 'chessl3cont';
            break;
        case 'layer2fairycont':
            leve2func = layer2fairy_1.layer2fairy;
            container3Id = 'fairyl3cont';
            break;
        case 'layer2armycont':
            leve2func = layer2army_1.layer2army;
            container3Id = 'armyl3cont';
            break;
        case 'layer2makrukcont':
            leve2func = layer2makruk_1.layer2makruk;
            container3Id = 'makrukl3cont';
            break;
        case 'layer2shogicont':
            leve2func = layer2shogi_1.layer2shogi;
            container3Id = 'shogil3cont';
            break;
        case 'layer2xiangqicont':
            leve2func = layer2xiangqi_1.layer2xiangqi;
            container3Id = 'xiangqil3cont';
            break;
    }
    const layer3cont = (0, h_1.h)(`div#${container3Id}.layer-3-container.chess-l3`, [
        (0, h_1.h)('button.layer-2-category l3v', [
            (0, h_1.h)('div.variant-title-l2', [
                (0, h_1.h)('div.icon', { attrs: { 'data-icon': variant.icon(chess960) } }, variant.displayName(chess960)),
            ]),
            (0, h_1.h)('ul.l3links-cont', [
                (0, h_1.h)('li.l3links', { class: { "icon": true, "icon-crossedswords": true }, on: { click: () => lobbyCtrl.createGame(variantName, chess960) } }, (0, i18n_1._)('Create a game')),
                (0, h_1.h)('li.l3links', { class: { "icon": true, "icon-crossedswords": true }, on: { click: () => lobbyCtrl.playFriend(variantName, chess960) } }, (0, i18n_1._)('Challenge a friend')),
                (0, h_1.h)('li.l3links', { class: { "icon": true, "icon-bot": true }, on: { click: () => lobbyCtrl.playAI(variantName, chess960) } }, (0, i18n_1._)('Play with AI')),
                (0, h_1.h)('li.l3links', { class: { "icon": true, "icon-droid": true }, on: { click: () => lobbyCtrl.playRM(variantName, chess960) } }, (0, i18n_1._)('Practice with Random-Mover')),
            ]),
            (0, h_1.h)('h5#chessl3back', { class: { "icon": true, "icon-reply": true }, on: { click: () => leve2func(lobbyCtrl, container3Id) } }, (0, i18n_1._)('Go Back')),
        ]),
        (0, h_1.h)('button.layer-2-category l3img', [
            (0, layer1_1.variantBoard)(variant, variant.startFen),
        ]),
        (0, h_1.h)('button.layer-2-category l3t', [
            (0, h_1.h)('p.variant-extra-info', (chess960) ? chess960Tooltip(variant.name) : variant.tooltip()),
            (0, h_1.h)('a.variant-extra-info', { class: { "icon": true, "icon-book": true }, attrs: { href: lobbyCtrl.model['home'] + '/variants/' + variant.name, target: '_blank' } }, (0, i18n_1._)('Rules')),
            (0, h_1.h)('p.variant-extra-info', (0, i18n_1._)('Tip: ') + proTip(variant.name, chess960)),
        ]),
    ]);
    const container = document.getElementById(container2Id);
    if (container)
        patch(container, layer3cont);
}
exports.layer3variant = layer3variant;
function chess960Tooltip(variant) {
    switch (variant) {
        case 'chess':
            return (0, i18n_1._)('Fischer\'s random chess where the back row are randomized.');
        case 'crazyhouse':
            return (0, i18n_1._)('Crazyhouse with random back row.');
        case 'atomic':
            return (0, i18n_1._)('Atomic Chess with random back row.');
        default:
            return '';
    }
}
function proTip(variant, chess960) {
    switch (variant) {
        // chess
        case 'chess':
        case 'crazyhouse':
        case 'atomic':
            if (chess960) {
                return (0, i18n_1._)('Move the king on top of the rook to castle.');
            }
            else {
                return (0, i18n_1._)('You can play more at www.lichess.org.');
            }
        case 'placement':
            return (0, i18n_1._)('Castling is only possible if the king and rook are dropped to their usual places like in standard Chess.');
        // fairy
        case 'capablanca':
            return (0, i18n_1._)('You can choose different starting setups including Embassy Chess and Gothic Chess.');
        case 'grand':
            return (0, i18n_1._)('For a drop version, choose GRANDHOUSE from the dropdown menu.');
        case 'seirawan':
            return (0, i18n_1._)('For a drop version, choose S-HOUSE from the dropdown menu.');
        case 'shogun':
            return (0, i18n_1._)('The queen actually demotes upon capture, so it is not worth as much.');
        case 'shako':
            return (0, i18n_1._)('The cannon is a tricky piece that needs to be closely followed.');
        case 'hoppelpoppel':
            return (0, i18n_1._)('Other piece sets are available, which may help avoid confusion.');
        // army
        case 'orda':
        case 'shinobi':
        case 'empire':
        case 'synochess':
        case 'ordamirror':
            return (0, i18n_1._)('Be aware of campmate - victory by moving your king into the 8th rank.');
        // makruk
        case 'makruk':
            return (0, i18n_1._)('It is important to know the counting rules in endgames.');
        case 'makpong':
            return (0, i18n_1._)('Watch out for knight checks, since they cannot be blocked.');
        case 'sittuyin':
            return (0, i18n_1._)('Be sure to review the nuances of pawn promotion rules.');
        case 'cambodian':
            return (0, i18n_1._)('King safety is important. Use the king leap move to save time.');
        // shogi
        case 'shogi':
        case 'minishogi':
        case 'gorogoro':
            return (0, i18n_1._)('Internationalized sets are available by going to settings.');
        case 'dobutsu':
            return (0, i18n_1._)('Despite the simple appearance, there is still quite a bit of depth underlying this game.');
        case 'kyotoshogi':
            return (0, i18n_1._)('Sets that show both sides are available by going to settings.');
        case 'torishogi':
            return (0, i18n_1._)('Reading the rules are a necessity to understand the movements before playing.');
        // xiangqi
        case 'xiangqi':
        case 'janggi':
        case 'minixiangqi':
        case 'manchu':
            return (0, i18n_1._)('Internationalized sets are available by going to settings.');
        default:
            return '';
    }
}

},{"../chess":8,"../i18n":18,"./layer1":23,"./layer2army":24,"./layer2chess":25,"./layer2fairy":26,"./layer2makruk":27,"./layer2shogi":28,"./layer2xiangqi":29,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92}],31:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.view = exports.model = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const h_1 = __importDefault(require("snabbdom/h"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
const i18n_1 = require("./i18n");
const about_1 = require("./about");
const settingsView_1 = require("./settingsView");
const lobby_1 = require("./lobby");
const round_1 = require("./round");
const invite_1 = require("./invite");
const games_1 = require("./games");
const editor_1 = require("./editor");
const analysis_1 = require("./analysis");
const profile_1 = require("./profile");
const tournament_1 = require("./tournament");
const paste_1 = require("./paste");
const stats_1 = require("./stats");
const sound_1 = require("./sound");
const document_1 = require("./document");
const background_1 = require("./background");
const datetime_1 = require("./datetime");
const zen_1 = require("./zen");
// redirect to correct URL except Heroku preview apps
//~ if (window.location.href.includes('heroku') && !window.location.href.includes('-pr-')) {
//~ window.location.assign('https://www.pychess.org/');
//~ }
exports.model = {};
function view(el, model) {
    const user = (0, document_1.getCookie)("user");
    if (user !== "")
        model["username"] = user;
    model["home"] = el.getAttribute("data-home");
    model["anon"] = el.getAttribute("data-anon");
    model["profileid"] = el.getAttribute("data-profile");
    model["title"] = el.getAttribute("data-title");
    model["variant"] = el.getAttribute("data-variant");
    model["chess960"] = el.getAttribute("data-chess960");
    model["rated"] = el.getAttribute("data-rated");
    model["level"] = el.getAttribute("data-level");
    model["username"] = user !== "" ? user : el.getAttribute("data-user");
    model["gameId"] = el.getAttribute("data-gameid");
    model["tournamentId"] = el.getAttribute("data-tournamentid");
    model["tournamentname"] = el.getAttribute("data-tournamentname");
    model["inviter"] = el.getAttribute("data-inviter");
    model["ply"] = el.getAttribute("data-ply");
    model["wplayer"] = el.getAttribute("data-wplayer");
    model["wtitle"] = el.getAttribute("data-wtitle");
    model["wrating"] = el.getAttribute("data-wrating");
    model["wrdiff"] = el.getAttribute("data-wrdiff");
    model["bplayer"] = el.getAttribute("data-bplayer");
    model["btitle"] = el.getAttribute("data-btitle");
    model["brating"] = el.getAttribute("data-brating");
    model["brdiff"] = el.getAttribute("data-brdiff");
    model["fen"] = el.getAttribute("data-fen");
    model["base"] = el.getAttribute("data-base");
    model["inc"] = el.getAttribute("data-inc");
    model["byo"] = el.getAttribute("data-byo");
    model["result"] = el.getAttribute("data-result");
    model["status"] = parseInt(el.getAttribute("data-status"));
    model["date"] = el.getAttribute("data-date");
    model["tv"] = el.getAttribute("data-view") === 'tv';
    model["embed"] = el.getAttribute("data-view") === 'embed';
    switch (el.getAttribute("data-view")) {
        case 'about':
            return (0, h_1.default)('div#main-wrap', (0, about_1.aboutView)());
        case 'level8win':
        case 'profile':
            return (0, h_1.default)('div#profile', (0, profile_1.profileView)(model));
        case 'tv':
        case 'round':
            return (0, h_1.default)('div#main-wrap', [(0, h_1.default)('main.round', (0, round_1.roundView)(model))]);
        case 'embed':
            return (0, h_1.default)('div', (0, analysis_1.embedView)(model));
        case 'analysis':
            return (0, h_1.default)('div#main-wrap', (0, analysis_1.analysisView)(model));
        case 'invite':
            return (0, h_1.default)('div#main-wrap', (0, invite_1.inviteView)(model));
        case 'editor':
            return (0, h_1.default)('div#main-wrap', (0, editor_1.editorView)(model));
        case 'tournament':
            return (0, h_1.default)('div#main-wrap', [(0, h_1.default)('main.tour', (0, tournament_1.tournamentView)(model))]);
        case 'games':
            return (0, h_1.default)('div', (0, games_1.renderGames)());
        case 'paste':
            return (0, h_1.default)('div#main-wrap', (0, paste_1.pasteView)(model));
        case 'stats':
            return (0, h_1.default)('div#stats', (0, stats_1.statsView)());
        case 'thanks':
            return (0, h_1.default)('div#main-wrap', (0, h_1.default)('h2', (0, i18n_1._)('Thank you for your support!')));
        default:
            return (0, h_1.default)('div#main-wrap', [(0, h_1.default)('main.lobby', (0, lobby_1.lobbyView)(model))]);
    }
}
exports.view = view;
function start() {
    const placeholder = document.getElementById('placeholder');
    if (placeholder)
        patch(placeholder, view(el, exports.model));
    if (exports.model["embed"])
        return;
    document.querySelector('.hamburger').addEventListener('click', () => {
        document.querySelectorAll('.topnav a').forEach(nav => nav.classList.toggle('navbar-show'));
        document.querySelector('.hamburger').classList.toggle('is-active');
    });
    (0, datetime_1.renderTimeago)();
    // Clicking outside settings panel closes it
    const settingsPanel = patch(document.getElementById('settings-panel'), (0, settingsView_1.settingsView)()).elm;
    const settings = document.getElementById('settings');
    document.addEventListener("click", function (event) {
        if (!settingsPanel.contains(event.target))
            settings.style.display = 'none';
    });
    patch(document.getElementById('zen-button'), (0, zen_1.zenButtonView)()).elm;
}
window.addEventListener('resize', () => document.body.dispatchEvent(new Event('chessground.resize')));
background_1.backgroundSettings.update();
zen_1.zenModeSettings.update();
const el = document.getElementById('pychess-variants');
if (el instanceof Element) {
    exports.model["asset-url"] = el.getAttribute("data-asset-url");
    // Always update sound theme before volume
    // Updating sound theme requires reloading sound files,
    // while updating volume does not
    sound_1.soundThemeSettings.update();
    sound_1.volumeSettings.update();
    const lang = el.getAttribute("data-lang");
    fetch(exports.model["asset-url"] + '/lang/' + lang + '/LC_MESSAGES/client.json')
        .then(res => res.json())
        .then(translation => {
        i18n_1.i18n.loadJSON(translation, 'messages');
        i18n_1.i18n.setLocale(lang);
        // console.log('Loaded translations for lang', lang);
        start();
    })
        .catch(() => {
        console.error('Could not load translations for lang', lang);
        i18n_1.i18n.setLocale('');
        start();
    });
}

},{"./about":1,"./analysis":2,"./background":4,"./datetime":12,"./document":13,"./editor":14,"./games":16,"./i18n":18,"./invite":20,"./lobby":22,"./paste":34,"./profile":39,"./round":41,"./settingsView":44,"./sound":45,"./stats":46,"./tournament":47,"./zen":51,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91}],32:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateResult = exports.updateMovelist = exports.createMovelistButtons = exports.activatePlyVari = exports.selectMove = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
const h_1 = __importDefault(require("snabbdom/h"));
const boardSettings_1 = require("./boardSettings");
const profile_1 = require("./profile");
function selectMove(ctrl, ply, plyVari = 0) {
    ctrl.goPly(ply, plyVari);
    if (plyVari == 0) {
        activatePly(ctrl);
        scrollToPly(ctrl);
    }
    else {
        activatePlyVari(ply + plyVari);
    }
}
exports.selectMove = selectMove;
function activatePly(ctrl) {
    const active = document.querySelector('move.active');
    if (active)
        active.classList.remove('active');
    const elPly = document.querySelector(`move[ply="${ctrl.ply}"]`);
    if (elPly)
        elPly.classList.add('active');
}
function scrollToPly(ctrl) {
    if (ctrl.steps.length < 9)
        return;
    const movelistEl = document.getElementById('movelist');
    const plyEl = movelistEl.querySelector('move.active');
    let st = undefined;
    if (ctrl.ply == 0)
        st = 0;
    else if (ctrl.ply == ctrl.steps.length - 1)
        st = 99999;
    else if (plyEl)
        st = plyEl.offsetTop - movelistEl.offsetHeight / 2 + plyEl.offsetHeight / 2;
    if (st !== undefined)
        movelistEl.scrollTop = st;
}
function activatePlyVari(ply) {
    console.log('activatePlyVari()', ply);
    const active = document.querySelector('vari-move.active');
    if (active)
        active.classList.remove('active');
    const elPly = document.querySelector(`vari-move[ply="${ply}"]`);
    if (elPly)
        elPly.classList.add('active');
}
exports.activatePlyVari = activatePlyVari;
function createMovelistButtons(ctrl) {
    const container = document.getElementById('move-controls');
    ctrl.moveControls = patch(container, (0, h_1.default)('div#btn-controls-top.btn-controls', [
        (0, h_1.default)('button#flip', { on: { click: () => boardSettings_1.boardSettings.toggleOrientation() } }, [(0, h_1.default)('i.icon.icon-refresh', { props: { title: 'Flip board' } })]),
        (0, h_1.default)('button', { on: { click: () => selectMove(ctrl, 0) } }, [(0, h_1.default)('i.icon.icon-fast-backward')]),
        (0, h_1.default)('button', { on: { click: () => {
                    // this line is necessary, but I don't understand why
                    ctrl.ply = Math.min(ctrl.ply, ctrl.plyVari > 0 ? ctrl.steps[ctrl.plyVari]['vari'].length - 1 : Number.MAX_VALUE);
                    selectMove(ctrl, (ctrl.ply == 0 && ctrl.plyVari > 0) ? ctrl.plyVari : Math.max(ctrl.ply - 1, 0), (ctrl.ply == 0 && ctrl.plyVari > 0) ? 0 : ctrl.plyVari);
                }
            } }, [(0, h_1.default)('i.icon.icon-step-backward')]),
        (0, h_1.default)('button', { on: { click: () => selectMove(ctrl, Math.min(ctrl.ply + 1, (ctrl.plyVari > 0 ? ctrl.steps[ctrl.plyVari]['vari'].length : ctrl.steps.length) - 1), ctrl.plyVari) } }, [(0, h_1.default)('i.icon.icon-step-forward')]),
        (0, h_1.default)('button', { on: { click: () => selectMove(ctrl, ctrl.steps.length - 1) } }, [(0, h_1.default)('i.icon.icon-fast-forward')]),
    ]));
}
exports.createMovelistButtons = createMovelistButtons;
function updateMovelist(ctrl, full = true, activate = true, needResult = true) {
    var _a;
    const plyFrom = (full) ? 1 : ctrl.steps.length - 1;
    const plyTo = ctrl.steps.length;
    const moves = [];
    for (let ply = plyFrom; ply < plyTo; ply++) {
        const move = ctrl.steps[ply]['san'];
        if (move === null)
            continue;
        const moveEl = [(0, h_1.default)('san', move)];
        const scoreStr = (_a = ctrl.steps[ply]['scoreStr']) !== null && _a !== void 0 ? _a : '';
        moveEl.push((0, h_1.default)('eval#ply' + ply, scoreStr));
        if (ply % 2 !== 0)
            moves.push((0, h_1.default)('move.counter', (ply + 1) / 2));
        const el = (0, h_1.default)('move', {
            class: { active: ((ply === plyTo - 1) && activate) },
            attrs: { ply: ply },
            on: { click: () => selectMove(ctrl, ply) },
        }, moveEl);
        moves.push(el);
        if (ctrl.steps[ply]['vari'] !== undefined) {
            const variMoves = ctrl.steps[ply]['vari'];
            if (ply % 2 !== 0)
                moves.push((0, h_1.default)('move', '...'));
            moves.push((0, h_1.default)('vari#vari' + ctrl.plyVari, variMoves.map((x, idx) => {
                const currPly = ctrl.plyVari + idx;
                const moveCounter = (currPly % 2 !== 0) ? (currPly + 1) / 2 + '. ' : (idx === 0) ? Math.floor((currPly + 1) / 2) + '...' : ' ';
                return (0, h_1.default)('vari-move', {
                    attrs: { ply: currPly },
                    on: { click: () => selectMove(ctrl, idx, ctrl.plyVari) },
                }, [(0, h_1.default)('san', moveCounter + x['san'])]);
            })));
            if (ply % 2 !== 0) {
                moves.push((0, h_1.default)('move.counter', (ply + 1) / 2));
                moves.push((0, h_1.default)('move', '...'));
            }
        }
    }
    if (ctrl.status >= 0 && needResult) {
        moves.push((0, h_1.default)('div#result', (0, profile_1.result)(ctrl.variant, ctrl.status, ctrl.result)));
    }
    const container = document.getElementById('movelist');
    if (full) {
        while (container.lastChild) {
            container.removeChild(container.lastChild);
        }
    }
    ctrl.vmovelist = patch(container, (0, h_1.default)('div#movelist', moves));
    if (activate) {
        activatePly(ctrl);
        scrollToPly(ctrl);
    }
}
exports.updateMovelist = updateMovelist;
function updateResult(ctrl) {
    if (ctrl.status < 0)
        return;
    // Prevent to render it twice
    const resultEl = document.getElementById('result');
    if (resultEl)
        return;
    const container = document.getElementById('movelist');
    ctrl.vmovelist = patch(container, (0, h_1.default)('div#movelist', [(0, h_1.default)('div#result', (0, profile_1.result)(ctrl.variant, ctrl.status, ctrl.result))]));
    container.scrollTop = 99999;
}
exports.updateResult = updateResult;

},{"./boardSettings":5,"./profile":39,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.notify = void 0;
function notify(title, options) {
    // Let's check whether notification permissions have already been granted
    if (title && Notification.permission === "granted") {
        // If it's okay let's create a notification
        const notification = new Notification(title, options);
        notification.onclick = () => window.focus();
        // Otherwise, we need to ask the user for permission
    }
    else if (Notification.permission !== "denied") {
        Notification.requestPermission().then(function (permission) {
            // If the user accepts, let's create a notification
            if (title && permission === "granted") {
                const notification = new Notification(title, options);
                notification.onclick = () => window.focus();
            }
        });
    }
}
exports.notify = notify;

},{}],34:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pasteView = void 0;
const ffish_js_1 = __importDefault(require("../static/ffish.js"));
const h_1 = __importDefault(require("snabbdom/h"));
const i18n_1 = require("./i18n");
const variantsIni_1 = require("./variantsIni");
const chess_1 = require("./chess");
const kif_1 = require("../client/kif");
const BRAINKING_SITE = '[Site "BrainKing.com (Prague, Czech Republic)"]';
const EMBASSY_FEN = '[FEN "rnbqkmcbnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNBQKMCBNR w KQkq - 0 1"]';
function pasteView(model) {
    let ffish = null;
    new ffish_js_1.default().then(loadedModule => {
        ffish = loadedModule;
    });
    const importGame = (model, ffish) => {
        const e = document.getElementById("pgnpaste");
        //console.log('PGN:', e.value);
        let pgn = e.value;
        // Add missing Variant tag and switch short/long castling notations
        if (pgn.indexOf(BRAINKING_SITE) != -1 && pgn.indexOf(EMBASSY_FEN) != -1) {
            const lines = pgn.split(/\n/);
            const fenIndex = lines.findIndex((elem) => { return elem.startsWith('[FEN '); });
            lines[fenIndex] = `[FEN "${chess_1.VARIANTS['embassy'].startFen}"]`;
            lines.splice(fenIndex, 0, '[Variant "Embassy"]');
            lines.forEach((line, idx) => { if (idx > fenIndex)
                lines[idx] = line.replace(/(O-O-O|O-O)/g, (match) => { return match === 'O-O' ? 'O-O-O' : 'O-O'; }); });
            pgn = lines.join('\n');
        }
        if (ffish !== null) {
            ffish.loadVariantConfig(variantsIni_1.variantsIni);
            const XHR = new XMLHttpRequest();
            const FD = new FormData();
            let variant, initialFen, board;
            let mainlineMoves = [];
            try {
                const firstLine = pgn.slice(0, pgn.indexOf('\n'));
                // Fullwidth Colon(!) is used to separate game tag key-value pairs in Shogi KIF files :
                if (firstLine.includes('：') || firstLine.toUpperCase().includes('KIF')) {
                    const kif = (0, kif_1.parseKif)(pgn);
                    //console.log(kif['moves'].join(', '));
                    const handicap = kif['handicap'];
                    const moves = kif['moves'];
                    let status = kif['status'];
                    let result = kif['result'];
                    const as = chess_1.VARIANTS['shogi'].alternateStart;
                    const isHandicap = (handicap !== '' && as[handicap] !== undefined);
                    if (isHandicap) {
                        FD.append('FEN', as[handicap]);
                    }
                    const fen = (isHandicap) ? as[handicap] : chess_1.VARIANTS['shogi'].startFen;
                    board = new ffish.Board('shogi', fen);
                    let move;
                    for (let idx = 0; idx < moves.length; ++idx) {
                        move = moves[idx];
                        try {
                            board.push(move);
                            mainlineMoves.push(move);
                        }
                        catch (err) {
                            alert('Illegal move ' + move);
                            status = 10;
                            // LOSS for the moving player
                            result = (0, kif_1.resultString)(false, idx + 1, isHandicap);
                            break;
                        }
                    }
                    FD.append('Variant', 'shogi');
                    FD.append('Date', kif['date']);
                    FD.append('White', kif['sente']);
                    FD.append('Black', kif['gote']);
                    FD.append('TimeControl', kif['tc']);
                    FD.append('moves', mainlineMoves.join(' '));
                    FD.append('Result', result);
                    FD.append('Status', status);
                    FD.append('final_fen', board.fen());
                    FD.append('username', model['username']);
                    board.delete();
                }
                else {
                    const game = ffish.readGamePGN(pgn);
                    variant = "chess";
                    const v = game.headers("Variant");
                    //console.log("Variant:", v);
                    if (v)
                        variant = v.toLowerCase();
                    initialFen = chess_1.VARIANTS[variant].startFen;
                    const f = game.headers("FEN");
                    if (f)
                        initialFen = f;
                    // TODO: crazyhouse960 but without 960? (export to lichess hack)
                    const is960 = variant.includes("960") || variant.includes('random');
                    board = new ffish.Board(variant, initialFen, is960);
                    mainlineMoves = game.mainlineMoves().split(" ");
                    for (let idx = 0; idx < mainlineMoves.length; ++idx) {
                        board.push(mainlineMoves[idx]);
                    }
                    const tags = game.headerKeys().split(' ');
                    tags.forEach((tag) => {
                        FD.append(tag, game.headers(tag));
                    });
                    FD.append('moves', game.mainlineMoves());
                    FD.append('final_fen', board.fen());
                    FD.append('username', model["username"]);
                    board.delete();
                    game.delete();
                }
            }
            catch (err) {
                e.setCustomValidity(err.message ? (0, i18n_1._)('Invalid PGN') : '');
                alert(err);
                return;
            }
            XHR.onreadystatechange = function () {
                if (this.readyState == 4 && this.status == 200) {
                    const response = JSON.parse(this.responseText);
                    if (response['gameId'] !== undefined) {
                        window.location.assign(model["home"] + '/' + response['gameId']);
                    }
                    else if (response['error'] !== undefined) {
                        alert(response['error']);
                    }
                }
            };
            XHR.open("POST", "/import", true);
            XHR.send(FD);
        }
    };
    return [(0, h_1.default)('div.paste', [
            (0, h_1.default)('div.container', [
                (0, h_1.default)('strong', (0, i18n_1._)('Paste the PGN text here')),
                (0, h_1.default)('textarea#pgnpaste', { attrs: { spellcheck: "false" } }),
                (0, h_1.default)('div.import', [
                    (0, h_1.default)('button#import', { on: { click: () => importGame(model, ffish) } }, [
                        (0, h_1.default)('i', { class: { "icon": true, "icon-cloud-upload": true } }, (0, i18n_1._)('IMPORT GAME'))
                    ])
                ])
            ])
        ])];
}
exports.pasteView = pasteView;

},{"../client/kif":21,"../static/ffish.js":98,"./chess":8,"./i18n":18,"./variantsIni":48,"snabbdom/h":85}],35:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.iniPieces = exports.drag = exports.piecesView = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const drag_1 = require("chessgroundx/drag");
const chess_1 = require("./chess");
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, style_1.default, eventlisteners_1.default]);
const eventNames = ['mousedown', 'touchstart'];
function piecesView(ctrl, color, position) {
    const width = ctrl.variant.boardWidth;
    const height = ctrl.variant.boardHeight;
    const roles = ctrl.variant.pieceRoles(color);
    return (0, snabbdom_1.h)('div.pocket.' + position + '.editor.usable', {
        style: {
            '--editorLength': String(roles.length),
            '--piecerows': String((roles.length > width) ? 2 : 1),
            '--files': String(width),
            '--ranks': String(height),
        },
        hook: {
            insert: vnode => {
                eventNames.forEach(name => {
                    vnode.elm.addEventListener(name, (e) => {
                        drag(ctrl, e);
                    });
                });
            }
        }
    }, roles.map(r => {
        const promoted = r.length > 1;
        if (r.endsWith('~')) {
            r = r.slice(0, -1);
        }
        const role = (0, chess_1.letter2role)(r);
        const orientation = ctrl.flip ? ctrl.oppcolor : ctrl.mycolor;
        const side = color === orientation ? "ally" : "enemy";
        return (0, snabbdom_1.h)(`piece.${role}.${promoted ? "promoted." : ""}${color}.${side}`, {
            attrs: {
                'data-role': role,
                'data-color': color,
                'data-promoted': promoted ? 'true' : 'false',
                'data-nb': -1,
            }
        });
    }));
}
exports.piecesView = piecesView;
function drag(ctrl, e) {
    if (e.button !== undefined && e.button !== 0)
        return; // only touch or left click
    const el = e.target, role = el.getAttribute('data-role'), color = el.getAttribute('data-color'), promoted = el.getAttribute('data-promoted') === 'true';
    e.stopPropagation();
    e.preventDefault();
    (0, drag_1.dragNewPiece)(ctrl.chessground.state, { color, role, promoted }, e);
}
exports.drag = drag;
function iniPieces(ctrl, vpieces0, vpieces1) {
    ctrl.vpieces0 = patch(vpieces0, piecesView(ctrl, ctrl.flip ? ctrl.mycolor : ctrl.oppcolor, "top"));
    ctrl.vpieces1 = patch(vpieces1, piecesView(ctrl, ctrl.flip ? ctrl.oppcolor : ctrl.mycolor, "bottom"));
}
exports.iniPieces = iniPieces;

},{"./chess":8,"chessgroundx/drag":57,"snabbdom":93,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92}],36:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.player = void 0;
const h_1 = __importDefault(require("snabbdom/h"));
const profile_1 = require("./profile");
function player(id, title, name, rating, level) {
    return (0, h_1.default)('round-' + id, [
        (0, h_1.default)('div.player-data', [
            (0, h_1.default)('i-side#' + id + '.online.icon', { class: { "icon-online": false, "icon-offline": true } }),
            (0, h_1.default)('player', [
                (0, h_1.default)('a.user-link', { attrs: { href: '/@/' + name } }, [
                    (0, h_1.default)('player-title', " " + title + " "),
                    name + (0, profile_1.aiLevel)(title, level),
                ]),
                (0, h_1.default)('rating', title !== 'BOT' ? rating : ''),
            ]),
        ]),
    ]);
}
exports.player = player;

},{"./profile":39,"snabbdom/h":85}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyBoardToPNG = void 0;
const html_to_image_1 = require("html-to-image");
function copyBoardToPNG(fen) {
    const el = document.getElementById('mainboard');
    const style = getComputedStyle(document.body);
    const width = parseInt(style.getPropertyValue('--cgwrapwidth'));
    const height = parseInt(style.getPropertyValue('--cgwrapheight'));
    (0, html_to_image_1.toPng)(el, { width: width, height: height })
        .then(dataUrl => {
        const link = document.createElement('a');
        link.download = fen.split(' ')[0].replace(/\+/g, '.') + '.png';
        link.href = dataUrl;
        link.click();
    });
}
exports.copyBoardToPNG = copyBoardToPNG;

},{"html-to-image":82}],38:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pockets2str = exports.updatePockets = exports.refreshPockets = exports.drop = exports.drag = exports.click = exports.pocketView = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const drag_1 = require("chessgroundx/drag");
const drop_1 = require("chessgroundx/drop");
const chess_1 = require("./chess");
const roundCtrl_1 = __importDefault(require("./roundCtrl"));
const analysisCtrl_1 = __importDefault(require("./analysisCtrl"));
const editorCtrl_1 = require("./editorCtrl");
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, style_1.default, eventlisteners_1.default]);
// There are 2 kind of mechanics for moving a piece from pocket to the board - 1.dragging it and 2.click to select and click to drop on target square
const eventsDragging = ['mousedown', 'touchmove'];
const eventsClicking = ['click'];
const eventsDropping = ['mouseup', 'touchend'];
/**
 *
 */
function pocketView(ctrl, color, position) {
    const pocket = ctrl.pockets[position === 'top' ? 0 : 1];
    const roles = Object.keys(pocket); // contains the list of possible pieces/roles (i.e. for crazyhouse p-piece, n-piece, b-piece, r-piece, q-piece) in the order they will be displayed in the pocket
    let insertHook;
    // TODO Checking for type here is a mess. Should probably move to their respective classes
    if (ctrl instanceof editorCtrl_1.EditorController) {
        insertHook = {
            insert: vnode => {
                eventsDragging.forEach(name => vnode.elm.addEventListener(name, (e) => {
                    drag(ctrl, e);
                }));
                eventsDropping.forEach(name => vnode.elm.addEventListener(name, (e) => {
                    drop(ctrl, e);
                }));
                /* TODO editor clickdrop
                eventsClicking.forEach(name =>
                    (vnode.elm as HTMLElement).addEventListener(name, (e: cg.MouchEvent) => {
                        click(ctrl, e);
                    })
                );
                */
            }
        };
    }
    else if (ctrl instanceof analysisCtrl_1.default) { // enabling both the pocket whose turn it is
        insertHook = {
            insert: vnode => {
                eventsDragging.forEach(name => vnode.elm.addEventListener(name, (e) => {
                    if (color === ctrl.turnColor)
                        drag(ctrl, e);
                }));
                eventsClicking.forEach(name => vnode.elm.addEventListener(name, (e) => {
                    if (color === ctrl.turnColor)
                        click(ctrl, e);
                }));
            }
        };
    }
    else { // RoundController
        insertHook = {
            insert: vnode => {
                eventsDragging.forEach(name => vnode.elm.addEventListener(name, (e) => {
                    if (position === (ctrl.flip ? 'top' : 'bottom'))
                        drag(ctrl, e);
                }));
                eventsClicking.forEach(name => vnode.elm.addEventListener(name, (e) => {
                    if (position === (ctrl.flip ? 'top' : 'bottom'))
                        click(ctrl, e);
                }));
            }
        };
    }
    return (0, snabbdom_1.h)('div.pocket.' + position, {
        class: { usable: true },
        style: {
            '--pocketLength': String(roles.length),
            '--files': String(ctrl.variant.boardWidth),
            '--ranks': String(ctrl.variant.boardHeight),
        },
        hook: insertHook
    }, roles.map(role => {
        var _a, _b, _c;
        const nb = pocket[role] || 0;
        let clazz;
        const orientation = ctrl.flip ? ctrl.oppcolor : ctrl.mycolor;
        const side = color === orientation ? "ally" : "enemy";
        const dropMode = (_a = ctrl.chessground) === null || _a === void 0 ? void 0 : _a.state.dropmode;
        const dropPiece = (_b = ctrl.chessground) === null || _b === void 0 ? void 0 : _b.state.dropmode.piece;
        const selectedSquare = (dropMode === null || dropMode === void 0 ? void 0 : dropMode.active) && (dropPiece === null || dropPiece === void 0 ? void 0 : dropPiece.role) == role && (dropPiece === null || dropPiece === void 0 ? void 0 : dropPiece.color) == color;
        if (ctrl instanceof roundCtrl_1.default) {
            const preDropRole = (_c = ctrl.predrop) === null || _c === void 0 ? void 0 : _c.role;
            const activeColor = color === ctrl.turnColor;
            clazz = {
                premove: activeColor && preDropRole === role,
                'selected-square': selectedSquare,
            };
        }
        else {
            clazz = {
                premove: false,
                'selected-square': selectedSquare,
            };
        }
        return (0, snabbdom_1.h)(`piece.${role}.${color}.${side}`, {
            class: clazz,
            attrs: {
                'data-role': role,
                'data-color': color,
                'data-nb': nb,
            }
        });
    }));
}
exports.pocketView = pocketView;
function click(ctrl, e) {
    var _a, _b;
    if (e.button !== undefined && e.button !== 0)
        return; // only touch or left click
    const el = e.target, role = el.getAttribute('data-role'), color = el.getAttribute('data-color'), number = el.getAttribute('data-nb');
    if (!role || !color || number === '0')
        return;
    const dropMode = (_a = ctrl.chessground) === null || _a === void 0 ? void 0 : _a.state.dropmode;
    const dropPiece = (_b = ctrl.chessground) === null || _b === void 0 ? void 0 : _b.state.dropmode.piece;
    const canceledDropMode = el.getAttribute("canceledDropMode");
    el.setAttribute("canceledDropMode", "");
    if ((!dropMode.active || (dropPiece === null || dropPiece === void 0 ? void 0 : dropPiece.role) !== role) && canceledDropMode !== "true") {
        (0, drop_1.setDropMode)(ctrl.chessground.state, { color, role });
        // TODO:move below lines to drop.ts -> setDropMode
        if (ctrl instanceof roundCtrl_1.default || ctrl instanceof analysisCtrl_1.default) {
            if (ctrl.dests /*very first move with white might be undef*/) {
                const dropDests = new Map([[role, ctrl.dests[(0, chess_1.role2san)(role) + "@"]]]); // TODO:ideally pocket.ts should move to chessgroundx so dests must be set directly in the controller
                ctrl.chessground.set({
                    dropmode: {
                        active: true,
                        dropDests: dropDests
                    }
                });
            }
        }
    }
    else {
        (0, drop_1.cancelDropMode)(ctrl.chessground.state);
    }
    e.stopPropagation();
    e.preventDefault();
    refreshPockets(ctrl);
}
exports.click = click;
/**
 *
 */
function drag(ctrl, e) {
    var _a;
    if (e.button !== undefined && e.button !== 0)
        return; // only touch or left click
    if (ctrl instanceof roundCtrl_1.default && ctrl.spectator)
        return;
    const el = e.target, role = el.getAttribute('data-role'), color = el.getAttribute('data-color'), n = Number(el.getAttribute('data-nb'));
    el.setAttribute("canceledDropMode", ""); // We want to know if later in this method cancelDropMode was called,
    // so right after mouse button is up and dragging is over if a click event is triggered
    // (which annoyingly does happen if mouse is still over same pocket element)
    // then we know not to call setDropMode selecting the piece we have just unselected.
    // Alternatively we might not cancelDropMode on drag of same piece but then after drag is over
    // the selected piece remains selected which is not how board pieces behave and more importantly is counter intuitive
    if (!role || !color || n === 0)
        return;
    // always cancel drop mode if it is active
    if (ctrl.chessground.state.dropmode.active) {
        (0, drop_1.cancelDropMode)(ctrl.chessground.state);
        if (((_a = ctrl.chessground.state.dropmode.piece) === null || _a === void 0 ? void 0 : _a.role) == role) {
            // we mark it with this only if we are cancelling the same piece we "drag"
            el.setAttribute("canceledDropMode", "true");
        }
    }
    if (ctrl instanceof editorCtrl_1.EditorController) { // immediately decrease piece count for editor
        let index = color === 'white' ? 1 : 0;
        if (ctrl.flip)
            index = 1 - index;
        ctrl.pockets[index][role]--;
        refreshPockets(ctrl);
        ctrl.onChange();
    }
    if (ctrl instanceof roundCtrl_1.default || ctrl instanceof analysisCtrl_1.default) {
        if (ctrl.dests /*very first move with white might be undef*/) {
            const dropDests = new Map([[role, ctrl.dests[(0, chess_1.role2san)(role) + "@"]]]); // TODO:imho ideally pocket.ts should move to chessgroundx - this (ctrl.dests) then might not be accessible - is it?
            ctrl.chessground.set({
                dropmode: {
                    dropDests: dropDests,
                }
            });
        }
    }
    e.stopPropagation();
    e.preventDefault();
    (0, drag_1.dragNewPiece)(ctrl.chessground.state, { color, role }, e);
}
exports.drag = drag;
function drop(ctrl, e) {
    var _a;
    console.log("pocket drop()");
    const el = e.target;
    const piece = (_a = ctrl.chessground.state.draggable.current) === null || _a === void 0 ? void 0 : _a.piece;
    console.log(piece);
    if (piece) {
        const role = (0, chess_1.unpromotedRole)(ctrl.variant, piece);
        const color = el.getAttribute('data-color');
        let index = color === 'white' ? 1 : 0;
        if (ctrl.flip)
            index = 1 - index;
        const pocket = ctrl.pockets[index];
        console.log(role);
        console.log(color);
        console.log(index);
        console.log(pocket);
        if (role in pocket) {
            pocket[role]++;
            refreshPockets(ctrl);
            ctrl.onChange();
        }
    }
}
exports.drop = drop;
// TODO: after 1 move made only 1 pocket update needed at once, no need to update both
function refreshPockets(ctrl, vpocket0, vpocket1) {
    // update pockets from FEN
    if (ctrl.hasPockets) {
        // console.log(o,c,po,pc);
        ctrl.vpocket0 = patch(vpocket0 ? vpocket0 : ctrl.vpocket0, pocketView(ctrl, (ctrl.flip) ? ctrl.mycolor : ctrl.oppcolor, "top"));
        ctrl.vpocket1 = patch(vpocket1 ? vpocket1 : ctrl.vpocket1, pocketView(ctrl, (ctrl.flip) ? ctrl.oppcolor : ctrl.mycolor, "bottom"));
    }
}
exports.refreshPockets = refreshPockets;
function updatePockets(ctrl, vpocket0, vpocket1) {
    var _a, _b;
    // update pockets from FEN
    if (ctrl.hasPockets) {
        const parts = ctrl.fullfen.split(" ");
        const fen_placement = parts[0];
        let pockets = "";
        const bracketPos = fen_placement.indexOf("[");
        if (bracketPos !== -1) {
            pockets = fen_placement.slice(bracketPos);
        }
        const c = ctrl.mycolor;
        const o = ctrl.oppcolor;
        const rc = (_a = ctrl.variant.pocketRoles(c)) !== null && _a !== void 0 ? _a : [];
        const ro = (_b = ctrl.variant.pocketRoles(o)) !== null && _b !== void 0 ? _b : [];
        const pc = {};
        const po = {};
        rc.forEach(r => pc[(0, chess_1.letter2role)(r)] = (0, chess_1.lc)(pockets, r, c === 'white'));
        ro.forEach(r => po[(0, chess_1.letter2role)(r)] = (0, chess_1.lc)(pockets, r, o === 'white'));
        if (ctrl.flip) {
            ctrl.pockets = [pc, po];
        }
        else {
            ctrl.pockets = [po, pc];
        }
        // console.log(o,c,po,pc);
        refreshPockets(ctrl, vpocket0, vpocket1);
    }
}
exports.updatePockets = updatePockets;
function pocket2str(pocket) {
    const letters = [];
    for (const role in pocket) {
        letters.push((0, chess_1.role2san)(role).repeat(pocket[role]));
    }
    return letters.join('');
}
function pockets2str(ctrl) {
    return '[' + pocket2str(ctrl.pockets[1]) + pocket2str(ctrl.pockets[0]).toLowerCase() + ']';
}
exports.pockets2str = pockets2str;

},{"./analysisCtrl":3,"./chess":8,"./editorCtrl":15,"./roundCtrl":42,"chessgroundx/drag":57,"chessgroundx/drop":59,"snabbdom":93,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92}],39:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.profileView = exports.renderRdiff = exports.result = exports.aiLevel = exports.gameType = exports.colorNames = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
const h_1 = __importDefault(require("snabbdom/h"));
const chessgroundx_1 = require("chessgroundx");
const i18n_1 = require("./i18n");
const chess_1 = require("./chess");
const datetime_1 = require("./datetime");
const boardSettings_1 = require("./boardSettings");
const view_1 = require("./view");
function colorNames(color) {
    // We need color name tranlations in run time
    switch (color) {
        case "White":
            return (0, i18n_1._)("White");
        case "Black":
            return (0, i18n_1._)("Black");
        case "Red":
            return (0, i18n_1._)("Red");
        case "Blue":
            return (0, i18n_1._)("Blue");
        case "Gold":
            return (0, i18n_1._)("Gold");
        case "Pink":
            return (0, i18n_1._)("Pink");
        default:
            return color;
    }
}
exports.colorNames = colorNames;
function gameType(rated) {
    switch (rated) {
        case "True":
        case "1":
        case 1:
            return (0, i18n_1._)("Rated");
        case "2":
        case 2:
            return (0, i18n_1._)("IMPORT");
        default:
            return (0, i18n_1._)("Casual");
    }
}
exports.gameType = gameType;
function aiLevel(title, level) {
    return (title === 'BOT' && level >= 0) ? ' ' + (0, i18n_1._)('level %1', level) : '';
}
exports.aiLevel = aiLevel;
function result(variant, status, result) {
    let text = '';
    const variantName = variant.name;
    console.log("result()", variantName, status, result);
    const first = colorNames(variant.firstColor);
    const second = colorNames(variant.secondColor);
    switch (status) {
        case -2:
        case -1:
            text = (0, i18n_1._)('Playing right now');
            break;
        case 0:
            text = (0, i18n_1._)('Game aborted');
            break;
        case 1:
            text = (0, i18n_1._)('Checkmate');
            break;
        case 2:
            text = (0, i18n_1._)('%1 resigned', (result === '1-0') ? second : first);
            break;
        case 3:
            text = (0, i18n_1._)('Stalemate');
            break;
        case 4:
            text = (0, i18n_1._)('Time out');
            break;
        case 5:
            text = (0, i18n_1._)('Draw');
            break;
        case 6:
            text = (0, i18n_1._)('Time out');
            break;
        case 7:
            text = (0, i18n_1._)('%1 abandoned the game', (result === '1-0') ? second : first);
            break;
        case 8:
            text = (0, i18n_1._)('Cheat detected');
            break;
        case 9:
            text = (0, i18n_1._)('Not started');
            break;
        case 10:
            text = (0, i18n_1._)('Invalid move');
            break;
        case 11:
            text = (0, i18n_1._)('Unknown reason');
            break;
        case 12:
            switch (variantName) {
                case 'orda':
                case 'synochess':
                case 'dobutsu':
                case 'shinobi':
                case 'empire':
                case 'ordamirror':
                    text = (0, i18n_1._)('Campmate');
                    break;
                case 'atomic':
                    text = (0, i18n_1._)('Explosion of king');
                    break;
                default:
                    text = (0, i18n_1._)('Point counting');
                    break;
            }
            break;
        case 13:
            switch (variantName) {
                case 'janggi':
                    text = (0, i18n_1._)('Point counting');
                    break;
                default:
                    text = (0, i18n_1._)('Repetition');
                    break;
            }
            break;
        default:
            text = '*';
            break;
    }
    return (status <= 0) ? text : text + ', ' + result;
}
exports.result = result;
function renderRdiff(rdiff) {
    if (rdiff === undefined) {
        return (0, h_1.default)('span');
    }
    else if (rdiff === 0) {
        return (0, h_1.default)('span', '±0');
    }
    else if (rdiff < 0) {
        return (0, h_1.default)('bad', rdiff);
    }
    else if (rdiff > 0) {
        return (0, h_1.default)('good', '+' + rdiff);
    }
    else {
        return (0, h_1.default)('span');
    }
}
exports.renderRdiff = renderRdiff;
function renderGames(model, games) {
    const rows = games.map(game => {
        const variant = chess_1.VARIANTS[game.v];
        const chess960 = game.z === 1;
        return (0, h_1.default)('tr', [(0, h_1.default)('a', { attrs: { href: '/' + game["_id"] } }, [
                (0, h_1.default)('td.board', [
                    (0, h_1.default)(`selection.${variant.board}.${variant.piece}`, [
                        (0, h_1.default)(`div.cg-wrap.${variant.cg}.mini`, {
                            hook: {
                                insert: vnode => (0, chessgroundx_1.Chessground)(vnode.elm, {
                                    coordinates: false,
                                    viewOnly: true,
                                    fen: game["f"],
                                    geometry: variant.geometry,
                                })
                            }
                        }),
                    ]),
                ]),
                (0, h_1.default)('td.games-info', [
                    (0, h_1.default)('div.info0.games.icon', { attrs: { "data-icon": variant.icon(chess960) } }, [
                        // h('div.info1.icon', { attrs: { "data-icon": (game["z"] === 1) ? "V" : "" } }),
                        (0, h_1.default)('div.info2', [
                            (0, h_1.default)('div.tc', (0, view_1.timeControlStr)(game["b"], game["i"], game["bp"]) + " • " + gameType(game["y"]) + " • " + variant.displayName(chess960)),
                            (0, h_1.default)('info-date', { attrs: { timestamp: game["d"] } }),
                        ]),
                    ]),
                    (0, h_1.default)('div.info-middle', [
                        (0, h_1.default)('div.versus', [
                            (0, h_1.default)('player', [
                                (0, h_1.default)('a.user-link', { attrs: { href: '/@/' + game["us"][0] } }, [
                                    (0, h_1.default)('player-title', " " + game["wt"] + " "),
                                    game["us"][0] + aiLevel(game["wt"], game['x']),
                                    (0, h_1.default)('br'),
                                    (game["p0"] === undefined) ? "" : game["p0"]["e"] + " ",
                                    (game["p0"] === undefined) ? "" : renderRdiff(game["p0"]["d"]),
                                ]),
                            ]),
                            (0, h_1.default)('vs-swords.icon', { attrs: { "data-icon": '"' } }),
                            (0, h_1.default)('player', [
                                (0, h_1.default)('a.user-link', { attrs: { href: '/@/' + game["us"][1] } }, [
                                    (0, h_1.default)('player-title', " " + game["bt"] + " "),
                                    game["us"][1] + aiLevel(game["bt"], game['x']),
                                    (0, h_1.default)('br'),
                                    (game["p1"] === undefined) ? "" : game["p1"]["e"] + " ",
                                    (game["p1"] === undefined) ? "" : renderRdiff(game["p1"]["d"]),
                                ]),
                            ]),
                        ]),
                        (0, h_1.default)('div.info-result', {
                            class: {
                                "win": (game["r"] === '1-0' && game["us"][0] === model["profileid"]) || (game["r"] === '0-1' && game["us"][1] === model["profileid"]),
                                "lose": (game["r"] === '0-1' && game["us"][0] === model["profileid"]) || (game["r"] === '1-0' && game["us"][1] === model["profileid"]),
                            }
                        }, result(variant, game["s"], game["r"])),
                    ]),
                    (0, h_1.default)('div.info0.games', [
                        (0, h_1.default)('div', [
                            (0, h_1.default)('div.info0', game["m"] === undefined ? "" : (0, i18n_1.ngettext)("%1 move", "%1 moves", game["m"].length)),
                            (0, h_1.default)('div.info0', game["a"] === undefined ? "" : [(0, h_1.default)('span.icon', { attrs: { "data-icon": "3" } }), (0, i18n_1._)("Computer analysis available")]),
                        ])
                    ])
                ])
            ])
        ]);
    });
    return [(0, h_1.default)('tbody', rows)];
}
function loadGames(model, page) {
    const xmlhttp = new XMLHttpRequest();
    let url = "/api/" + model["profileid"];
    if (model.level) {
        url = url + "/loss?x=8&p=";
    }
    else if (model.variant) {
        url = url + "/perf/" + model.variant + "?p=";
    }
    else if (model.rated === "1") {
        url = url + "/rated" + "?p=";
    }
    else if (model.rated === "2") {
        url = url + "/import" + "?p=";
    }
    else {
        url = url + "/all?p=";
    }
    xmlhttp.onreadystatechange = function () {
        if (this.readyState == 4 && this.status == 200) {
            const response = JSON.parse(this.responseText);
            // If empty JSON, exit the function
            if (!response.length) {
                return;
            }
            const oldVNode = document.getElementById('games');
            if (oldVNode instanceof Element)
                patch(oldVNode, (0, h_1.default)('table#games', renderGames(model, response)));
            (0, datetime_1.renderTimeago)();
        }
    };
    xmlhttp.open("GET", url + page, true);
    xmlhttp.send();
}
function observeSentinel(vnode, model) {
    const sentinel = vnode.elm;
    let page = 0;
    const options = { root: null, rootMargin: '44px', threshold: 1.0 };
    const intersectionObserver = new IntersectionObserver(entries => {
        if (entries.some(entry => entry.intersectionRatio > 0)) {
            loadGames(model, page);
            page += 1;
        }
    }, options);
    intersectionObserver.observe(sentinel);
}
function profileView(model) {
    boardSettings_1.boardSettings.updateBoardAndPieceStyles();
    return [
        (0, h_1.default)('div.filter-tabs', [
            (0, h_1.default)('div.sub-ratings', [(0, h_1.default)('a', { attrs: { href: '/@/' + model["profileid"] }, class: { "active": model["rated"] === "None" } }, (0, i18n_1._)('Games'))]),
            (0, h_1.default)('div.sub-ratings', [(0, h_1.default)('a', { attrs: { href: '/@/' + model["profileid"] + '/rated' }, class: { "active": model["rated"] === "1" } }, (0, i18n_1.pgettext)('UsePluralFormIfNeeded', 'Rated'))]),
            (0, h_1.default)('div.sub-ratings', [(0, h_1.default)('a', { attrs: { href: '/@/' + model["profileid"] + '/import' }, class: { "active": model["rated"] === "2" } }, (0, i18n_1._)('Imported'))]),
        ]),
        (0, h_1.default)('table#games'),
        (0, h_1.default)('div#sentinel', { hook: { insert: (vnode) => observeSentinel(vnode, model) } }),
    ];
}
exports.profileView = profileView;

},{"./boardSettings":5,"./chess":8,"./datetime":12,"./i18n":18,"./view":49,"chessgroundx":55,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91}],40:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Promotion = void 0;
const snabbdom_1 = require("snabbdom");
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const h_1 = require("snabbdom/h");
const tovnode_1 = require("snabbdom/tovnode");
const util_1 = require("chessgroundx/util");
const chess_1 = require("./chess");
const document_1 = require("./document");
const roundCtrl_1 = __importDefault(require("./roundCtrl"));
const patch = (0, snabbdom_1.init)([eventlisteners_1.default, style_1.default]);
class Promotion {
    constructor(ctrl) {
        this.ctrl = ctrl;
        this.promoting = null;
        this.choices = {};
    }
    start(movingRole, orig, dest, disableAutoqueen = false) {
        const ground = this.ctrl.getGround();
        // in 960 castling case (king takes rook) dest piece may be undefined
        if (ground.state.pieces[dest] === undefined)
            return false;
        if (this.canPromote(movingRole, orig, dest)) {
            const color = this.ctrl.turnColor;
            const orientation = ground.state.orientation;
            const pchoices = this.promotionChoices(movingRole, orig, dest);
            if (this.ctrl instanceof roundCtrl_1.default && this.ctrl.autoqueen && !disableAutoqueen && this.ctrl.variant.autoQueenable && 'q-piece' in pchoices)
                this.choices = { 'q-piece': 'q' };
            else
                this.choices = pchoices;
            if (Object.keys(this.choices).length === 1) {
                const role = Object.keys(this.choices)[0];
                const promo = this.choices[role];
                this.promote(ground, dest, role);
                this.ctrl.sendMove(orig, dest, promo);
            }
            else {
                this.drawPromo(dest, color, orientation);
                this.promoting = {
                    orig: orig,
                    dest: dest,
                    callback: this.ctrl.sendMove,
                };
            }
            return true;
        }
        return false;
    }
    promotionFilter(move, role, orig, dest) {
        if (this.ctrl.variant.promotion === 'kyoto')
            if (orig === "a0")
                return move.startsWith("+" + (0, chess_1.role2san)(role));
        return move.slice(0, -1) === orig + dest;
    }
    canPromote(role, orig, dest) {
        return this.ctrl.promotions.some(move => this.promotionFilter(move, role, orig, dest));
    }
    promotionChoices(role, orig, dest) {
        const variant = this.ctrl.variant;
        const possiblePromotions = this.ctrl.promotions.filter(move => this.promotionFilter(move, role, orig, dest));
        const choice = {};
        switch (variant.promotion) {
            case 'shogi':
                choice["p" + role] = "+";
                break;
            case 'kyoto':
                if (orig === "a0" || possiblePromotions[0].slice(-1) === "+")
                    choice["p" + role] = "+";
                else
                    choice[role.slice(1)] = "-";
                break;
            case 'grand':
            default:
                possiblePromotions.forEach(move => {
                    const r = move.slice(-1);
                    choice[(0, chess_1.san2role)(r)] = r;
                });
        }
        if (!this.isMandatoryPromotion(role, orig, dest))
            choice[role] = "";
        return choice;
    }
    isMandatoryPromotion(role, orig, dest) {
        return this.ctrl.variant.isMandatoryPromotion(role, orig, dest, this.ctrl.mycolor);
    }
    promote(g, key, role) {
        const pieces = {};
        const piece = g.state.pieces[key];
        if (g.state.pieces[key].role !== role) {
            pieces[key] = {
                color: piece.color,
                role: role,
                promoted: true
            };
            g.setPieces(pieces);
        }
    }
    drawPromo(dest, color, orientation) {
        const container = (0, tovnode_1.toVNode)(document.querySelector('extension'));
        patch(container, this.view(dest, color, orientation));
    }
    drawNoPromo() {
        const container = document.getElementById('extension_choice');
        patch(container, (0, h_1.h)('extension'));
    }
    finish(role) {
        if (this.promoting) {
            this.drawNoPromo();
            this.promote(this.ctrl.getGround(), this.promoting.dest, role);
            const promo = this.choices[role];
            if (this.ctrl.variant.promotion === 'kyoto') {
                const droppedPiece = promo ? (0, chess_1.role2san)(role.slice(1)) : (0, chess_1.role2san)(role);
                if (this.promoting.callback)
                    this.promoting.callback(promo + droppedPiece, "@", this.promoting.dest);
            }
            else {
                if (this.promoting.callback)
                    this.promoting.callback(this.promoting.orig, this.promoting.dest, promo);
            }
            this.promoting = null;
        }
    }
    cancel() {
        this.drawNoPromo();
        this.ctrl.goPly(this.ctrl.ply);
        return;
    }
    view(dest, color, orientation) {
        const dim = this.ctrl.getGround().state.dimensions;
        const pos = (0, util_1.key2pos)(dest);
        const leftFile = (orientation === "white") ? pos[0] - 1 : dim.width - pos[0];
        const left = leftFile * (100 / dim.width);
        const direction = color === orientation ? "top" : "bottom";
        const side = color === orientation ? "ally" : "enemy";
        const choices = Object.keys(this.choices);
        const topRank = Math.max(0, (color === "white") ? dim.height - pos[1] + 1 - choices.length : pos[1] - choices.length);
        return (0, h_1.h)("div#extension_choice." + direction, {
            hook: {
                insert: vnode => {
                    const el = vnode.elm;
                    el.addEventListener("click", () => this.cancel());
                    el.addEventListener("contextmenu", e => {
                        e.preventDefault();
                        return false;
                    });
                }
            }
        }, choices.map((role, i) => {
            const top = (color === orientation ? topRank + i : dim.height - 1 - topRank - i) * (100 / dim.height);
            return (0, h_1.h)("square", {
                style: { top: top + "%", left: left + "%" },
                hook: (0, document_1.bind)("click", e => {
                    e.stopPropagation();
                    this.finish(role);
                }, false)
            }, [(0, h_1.h)(`piece.${role}.${color}.${side}`)]);
        }));
    }
}
exports.Promotion = Promotion;

},{"./chess":8,"./document":13,"./roundCtrl":42,"chessgroundx/util":69,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/style":92,"snabbdom/tovnode":95}],41:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.roundView = void 0;
const snabbdom_1 = require("snabbdom");
const i18n_1 = require("./i18n");
const roundCtrl_1 = __importDefault(require("./roundCtrl"));
const chess_1 = require("./chess");
const datetime_1 = require("./datetime");
const profile_1 = require("./profile");
const view_1 = require("./view");
function runGround(vnode, model) {
    const el = vnode.elm;
    const ctrl = new roundCtrl_1.default(el, model);
    const cg = ctrl.chessground;
    window["cg"] = cg;
}
function roundView(model) {
    console.log("roundView model=", model);
    const variant = chess_1.VARIANTS[model.variant];
    const chess960 = model.chess960 === 'True';
    const dataIcon = variant.icon(chess960);
    const fc = variant.firstColor;
    const sc = variant.secondColor;
    (0, datetime_1.renderTimeago)();
    return [(0, snabbdom_1.h)('aside.sidebar-first', [
            (0, snabbdom_1.h)('div.game-info', [
                (0, snabbdom_1.h)('div.info0.icon', { attrs: { "data-icon": dataIcon } }, [
                    (0, snabbdom_1.h)('div.info2', [
                        (0, snabbdom_1.h)('div.tc', [
                            (0, view_1.timeControlStr)(model["base"], model["inc"], model["byo"]) + " • " + (0, profile_1.gameType)(model["rated"]) + " • ",
                            (0, snabbdom_1.h)('a.user-link', {
                                attrs: {
                                    target: '_blank',
                                    href: '/variants/' + model["variant"] + (chess960 ? '960' : ''),
                                }
                            }, variant.displayName(chess960)),
                        ]),
                        Number(model["status"]) >= 0 ? (0, snabbdom_1.h)('info-date', { attrs: { timestamp: model["date"] } }, (0, datetime_1.timeago)(model["date"])) : (0, i18n_1._)("Playing right now"),
                    ]),
                ]),
                (0, snabbdom_1.h)('div.player-data', [
                    (0, snabbdom_1.h)('i-side.icon', {
                        class: {
                            "icon-white": fc === "White",
                            "icon-black": fc === "Black",
                            "icon-red": fc === "Red",
                            "icon-blue": fc === "Blue",
                            "icon-gold": fc === "Gold",
                            "icon-pink": fc === "Pink",
                        }
                    }),
                    (0, snabbdom_1.h)('player', playerInfo(model, 'w', null)),
                ]),
                (0, snabbdom_1.h)('div.player-data', [
                    (0, snabbdom_1.h)('i-side.icon', {
                        class: {
                            "icon-white": sc === "White",
                            "icon-black": sc === "Black",
                            "icon-red": sc === "Red",
                            "icon-blue": sc === "Blue",
                            "icon-gold": sc === "Gold",
                            "icon-pink": sc === "Pink",
                        }
                    }),
                    (0, snabbdom_1.h)('player', playerInfo(model, 'b', null)),
                ]),
            ]),
            (0, snabbdom_1.h)('div#roundchat'),
        ]),
        (0, snabbdom_1.h)('div.round-app', [
            (0, snabbdom_1.h)('selection#mainboard.' + variant.board + '.' + variant.piece, [
                (0, snabbdom_1.h)('div.cg-wrap.' + variant.cg, {
                    hook: {
                        insert: (vnode) => runGround(vnode, model)
                    },
                }),
            ]),
            (0, snabbdom_1.h)('div.pocket-top', [
                (0, snabbdom_1.h)('div.' + variant.piece + '.' + model["variant"], [
                    (0, snabbdom_1.h)('div.cg-wrap.pocket', [
                        (0, snabbdom_1.h)('div#pocket0'),
                    ]),
                ]),
            ]),
            (0, snabbdom_1.h)('div.info-wrap0', [
                (0, snabbdom_1.h)('div.clock-wrap', [
                    (0, snabbdom_1.h)('div#clock0'),
                    (0, snabbdom_1.h)('div#more-time'),
                ]),
                (0, snabbdom_1.h)('div#misc-info0'),
            ]),
            (0, snabbdom_1.h)('div#expiration-top'),
            (0, snabbdom_1.h)('round-player0#rplayer0'),
            (0, snabbdom_1.h)('div#move-controls'),
            (0, snabbdom_1.h)('div.movelist-block', [
                (0, snabbdom_1.h)('div#movelist'),
            ]),
            (0, snabbdom_1.h)('div#game-controls'),
            (0, snabbdom_1.h)('round-player1#rplayer1'),
            (0, snabbdom_1.h)('div#expiration-bottom'),
            (0, snabbdom_1.h)('div.info-wrap1', [
                (0, snabbdom_1.h)('div#clock1'),
                (0, snabbdom_1.h)('div#misc-info1'),
            ]),
            (0, snabbdom_1.h)('div.pocket-bot', [
                (0, snabbdom_1.h)('div.' + variant.piece + '.' + model["variant"], [
                    (0, snabbdom_1.h)('div.cg-wrap.pocket', [
                        (0, snabbdom_1.h)('div#pocket1'),
                    ]),
                ]),
            ]),
        ]),
        (0, snabbdom_1.h)('under-left#spectators'),
        (0, snabbdom_1.h)('under-board', [
            (0, snabbdom_1.h)('div#janggi-setup-buttons'),
            (0, snabbdom_1.h)('div#ctable-container'),
        ]),
    ];
}
exports.roundView = roundView;
function playerInfo(model, color, rdiff) {
    const username = model[color + "player"];
    const title = model[color + "title"];
    const level = model.level;
    const rating = model[color + "rating"];
    return (0, snabbdom_1.h)('a.user-link', { attrs: { href: '/@/' + username } }, [
        (0, snabbdom_1.h)('player-title', " " + title + " "),
        username + (0, profile_1.aiLevel)(title, level) + (title !== 'BOT' ? (" (" + rating + ") ") : ''),
        rdiff === null ? (0, snabbdom_1.h)('rdiff#' + color + 'rdiff') : (0, profile_1.renderRdiff)(rdiff),
    ]);
}

},{"./chess":8,"./datetime":12,"./i18n":18,"./profile":39,"./roundCtrl":42,"./view":49,"snabbdom":93}],42:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sockette_1 = __importDefault(require("sockette"));
const snabbdom_1 = require("snabbdom");
const h_1 = require("snabbdom/h");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const util_1 = require("chessgroundx/util");
const chessgroundx_1 = require("chessgroundx");
const drop_1 = require("chessgroundx/drop");
const predrop_1 = __importDefault(require("chessgroundx/predrop"));
const i18n_1 = require("./i18n");
const boardSettings_1 = require("./boardSettings");
const clock_1 = require("./clock");
const gating_1 = require("./gating");
const promotion_1 = require("./promotion");
const pocket_1 = require("./pocket");
const sound_1 = require("./sound");
const chess_1 = require("./chess");
const crosstable_1 = require("./crosstable");
const chat_1 = require("./chat");
const movelist_1 = require("./movelist");
const profile_1 = require("./profile");
const player_1 = require("./player");
const info_1 = require("./info");
const notification_1 = require("./notification");
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
let rang = false;
class RoundController {
    // In case of bad connection, we are never sure if it was sent (thus the name)
    // until a "board" message from server is received from server that confirms it.
    // So if at any moment connection drops, after reconnect we always resend it.
    // If server received and processed it the first time, it will just ignore it
    constructor(el, model) {
        this.getGround = () => this.chessground;
        this.abort = () => {
            // console.log("Abort");
            this.doSend({ type: "abort", gameId: this.gameId });
        };
        this.draw = () => {
            // console.log("Draw");
            this.doSend({ type: "draw", gameId: this.gameId });
        };
        this.resign = () => {
            // console.log("Resign");
            if (confirm((0, i18n_1._)('Are you sure you want to resign?'))) {
                this.doSend({ type: "resign", gameId: this.gameId });
            }
        };
        this.pass = () => {
            let passKey = 'a0';
            const pieces = this.chessground.state.pieces;
            const dests = this.chessground.state.movable.dests;
            for (const key in pieces) {
                if (pieces[key].role === 'k-piece' && pieces[key].color === this.turnColor) {
                    if ((key in dests) && (dests[key].indexOf(key) >= 0))
                        passKey = key;
                }
            }
            if (passKey !== 'a0') {
                // prevent calling pass() again by selectSquare() -> onSelect()
                this.chessground.state.movable.dests = undefined;
                this.chessground.selectSquare(passKey);
                sound_1.sound.moveSound(this.variant, false);
                this.sendMove(passKey, passKey, '');
            }
        };
        // Janggi second player (Red) setup
        this.onMsgSetup = (msg) => {
            this.setupFen = msg.fen;
            this.chessground.set({ fen: this.setupFen });
            const side = (msg.color === 'white') ? (0, i18n_1._)('Blue (Cho)') : (0, i18n_1._)('Red (Han)');
            const message = (0, i18n_1._)('Waiting for %1 to choose starting positions of the horses and elephants...', side);
            this.expiStart = 0;
            this.renderExpiration();
            this.turnColor = msg.color;
            this.expiStart = Date.now();
            setTimeout(this.showExpiration, 350);
            if (this.spectator || msg.color !== this.mycolor) {
                (0, chat_1.chatMessage)('', message, "roundchat");
                return;
            }
            (0, chat_1.chatMessage)('', message, "roundchat");
            const switchLetters = (side) => {
                const white = this.mycolor === 'white';
                const rank = (white) ? 9 : 0;
                const horse = (white) ? 'N' : 'n';
                const elephant = (white) ? 'B' : 'b';
                const parts = this.setupFen.split(' ')[0].split('/');
                let [left, right] = parts[rank].split('1');
                if (side === -1) {
                    left = left.replace(horse, '*').replace(elephant, horse).replace('*', elephant);
                }
                else {
                    right = right.replace(horse, '*').replace(elephant, horse).replace('*', elephant);
                }
                parts[rank] = left + '1' + right;
                this.setupFen = parts.join('/') + ' w - - 0 1';
                this.chessground.set({ fen: this.setupFen });
            };
            const sendSetup = () => {
                patch(document.getElementById('janggi-setup-buttons'), (0, h_1.h)('div#empty'));
                this.doSend({ type: "setup", gameId: this.gameId, color: this.mycolor, fen: this.setupFen });
            };
            const leftSide = (this.mycolor === 'white') ? -1 : 1;
            const rightSide = leftSide * -1;
            patch(document.getElementById('janggi-setup-buttons'), (0, h_1.h)('div#janggi-setup-buttons', [
                (0, h_1.h)('button#flipLeft', { on: { click: () => switchLetters(leftSide) } }, [(0, h_1.h)('i', { props: { title: (0, i18n_1._)('Switch pieces') }, class: { "icon": true, "icon-exchange": true } }),]),
                (0, h_1.h)('button', { on: { click: () => sendSetup() } }, [(0, h_1.h)('i', { props: { title: (0, i18n_1._)('Ready') }, class: { "icon": true, "icon-check": true } }),]),
                (0, h_1.h)('button#flipRight', { on: { click: () => switchLetters(rightSide) } }, [(0, h_1.h)('i', { props: { title: (0, i18n_1._)('Switch pieces') }, class: { "icon": true, "icon-exchange": true } }),]),
            ]));
        };
        this.notifyMsg = (msg) => {
            const opp_name = this.model["username"] === this.wplayer ? this.bplayer : this.wplayer;
            const logoUrl = `${this.model["asset-url"]}/favicon/android-icon-192x192.png`;
            (0, notification_1.notify)('pychess.org', { body: `${opp_name}\n${msg}`, icon: logoUrl });
        };
        this.onMsgGameStart = (msg) => {
            // console.log("got gameStart msg:", msg);
            if (msg.gameId !== this.gameId)
                return;
            if (!this.spectator) {
                sound_1.sound.genericNotify();
                if (!this.focus)
                    this.notifyMsg('joined the game.');
            }
        };
        this.onMsgNewGame = (msg) => {
            window.location.assign(this.model["home"] + '/' + msg["gameId"]);
        };
        this.onMsgViewRematch = (msg) => {
            const btns_after = document.querySelector('.btn-controls.after');
            let rematch_button = (0, h_1.h)('button.newopp', { on: { click: () => window.location.assign(this.model["home"] + '/' + msg["gameId"]) } }, (0, i18n_1._)("VIEW REMATCH"));
            let rematch_button_location = btns_after.insertBefore(document.createElement('div'), btns_after.firstChild);
            patch(rematch_button_location, rematch_button);
        };
        this.rematch = () => {
            this.doSend({ type: "rematch", gameId: this.gameId, handicap: this.handicap });
        };
        this.newOpponent = (home) => {
            this.doSend({ "type": "leave", "gameId": this.gameId });
            window.location.assign(home);
        };
        this.analysis = (home) => {
            window.location.assign(home + '/' + this.gameId + '?ply=' + this.ply.toString());
        };
        this.joinTournament = () => {
            window.location.assign(this.model["home"] + '/tournament/' + this.model["tournamentId"]);
        };
        this.pauseTournament = () => {
            window.location.assign(this.model["home"] + '/tournament/' + this.model["tournamentId"] + '/pause');
        };
        this.gameOver = (rdiffs) => {
            let container;
            container = document.getElementById('wrdiff');
            if (container)
                patch(container, (0, profile_1.renderRdiff)(rdiffs["wrdiff"]));
            container = document.getElementById('brdiff');
            if (container)
                patch(container, (0, profile_1.renderRdiff)(rdiffs["brdiff"]));
            // console.log(rdiffs)
            this.gameControls = patch(this.gameControls, (0, h_1.h)('div'));
            let buttons = [];
            if (!this.spectator) {
                if (this.tournamentGame) {
                    // TODO: isOver = ?
                    const isOver = false;
                    if (isOver) {
                        buttons.push((0, h_1.h)('button.newopp', { on: { click: () => this.joinTournament() } }, [(0, h_1.h)('div', { class: { "icon": true, 'icon-play3': true } }, (0, i18n_1._)("VIEW TOURNAMENT"))]));
                    }
                    else {
                        buttons.push((0, h_1.h)('button.newopp', { on: { click: () => this.joinTournament() } }, [(0, h_1.h)('div', { class: { "icon": true, 'icon-play3': true } }, (0, i18n_1._)("BACK TO TOURNAMENT"))]));
                        buttons.push((0, h_1.h)('button.newopp', { on: { click: () => this.pauseTournament() } }, [(0, h_1.h)('div', { class: { "icon": true, 'icon-pause2': true } }, (0, i18n_1._)("PAUSE"))]));
                    }
                }
                else {
                    buttons.push((0, h_1.h)('button.rematch', { on: { click: () => this.rematch() } }, (0, i18n_1._)("REMATCH")));
                    buttons.push((0, h_1.h)('button.newopp', { on: { click: () => this.newOpponent(this.model["home"]) } }, (0, i18n_1._)("NEW OPPONENT")));
                }
            }
            buttons.push((0, h_1.h)('button.analysis', { on: { click: () => this.analysis(this.model["home"]) } }, (0, i18n_1._)("ANALYSIS BOARD")));
            patch(this.gameControls, (0, h_1.h)('div.btn-controls.after', buttons));
        };
        this.checkStatus = (msg) => {
            if (msg.gameId !== this.gameId)
                return;
            if (msg.status >= 0) {
                this.status = msg.status;
                this.result = msg.result;
                this.clocks[0].pause(false);
                this.clocks[1].pause(false);
                this.dests = {};
                if (this.result !== "*" && !this.spectator)
                    sound_1.sound.gameEndSound(msg.result, this.mycolor);
                this.gameOver(msg.rdiffs);
                (0, movelist_1.selectMove)(this, this.ply);
                (0, movelist_1.updateResult)(this);
                if (msg.ct) {
                    this.ctableContainer = patch(this.ctableContainer, (0, h_1.h)('div#ctable-container'));
                    this.ctableContainer = patch(this.ctableContainer, (0, crosstable_1.crosstableView)(msg.ct, this.gameId));
                }
                // clean up gating/promotion widget left over the ground while game ended by time out
                const container = document.getElementById('extension_choice');
                if (container instanceof Element)
                    patch(container, (0, h_1.h)('extension'));
                if (this.tv) {
                    setInterval(() => { this.doSend({ type: "updateTV", gameId: this.gameId, profileId: this.model["profileid"] }); }, 2000);
                }
            }
        };
        this.onMsgUpdateTV = (msg) => {
            if (msg.gameId !== this.gameId) {
                if (this.model["profileid"] !== "") {
                    window.location.assign(this.model["home"] + '/@/' + this.model["profileid"] + '/tv');
                }
                else {
                    window.location.assign(this.model["home"] + '/tv');
                }
                // TODO: reuse current websocket to fix https://github.com/gbtami/pychess-variants/issues/142
                // this.doSend({ type: "game_user_connected", username: this.model["username"], gameId: msg.gameId });
            }
        };
        this.onMsgBoard = (msg) => {
            var _a, _b, _c;
            if (msg.gameId !== this.gameId)
                return;
            const pocketsChanged = this.hasPockets && ((0, chess_1.getPockets)(this.fullfen) !== (0, chess_1.getPockets)(msg.fen));
            // console.log("got board msg:", msg);
            const latestPly = (this.ply === -1 || msg.ply >= this.ply + 1); // when receiving a board msg with full list of moves (aka steps) after reconnecting
            // its ply might be ahead with 2 ply - our move that failed to get confirmed
            // because of disconnect and then also opp's reply to it, that we didn't
            // receive while offline. Not sure if it could be ahead with more than 2 ply
            if (latestPly)
                this.ply = msg.ply;
            if (this.ply === 0 && this.variant.name !== 'janggi') {
                this.expiStart = Date.now();
                setTimeout(this.showExpiration, 350);
            }
            if (this.ply === 1 || this.ply === 2) {
                this.expiStart = 0;
                this.renderExpiration();
                if (this.ply === 1) {
                    this.expiStart = Date.now();
                    setTimeout(this.showExpiration, 350);
                }
            }
            this.fullfen = msg.fen;
            if (this.variant.gate) {
                // When castling with gating is possible 
                // e1g1, e1g1h, e1g1e, h1e1h, h1e1e all will be offered by moving our king two squares
                // so we filter out rook takes king moves (h1e1h, h1e1e) from dests
                for (const orig of Object.keys(msg.dests)) {
                    const movingPiece = this.chessground.state.pieces[orig];
                    if (movingPiece !== undefined && movingPiece.role === "r-piece") {
                        msg.dests[orig] = msg.dests[orig].filter(x => {
                            const destPiece = this.chessground.state.pieces[x];
                            return destPiece === undefined || destPiece.role !== 'k-piece';
                        });
                    }
                }
            }
            const parts = msg.fen.split(" ");
            this.turnColor = parts[1] === "w" ? "white" : "black";
            this.dests = (msg.status < 0) ? msg.dests : {};
            // TODO: this logic ideally belongs in chessground somehow i feel - but where can i put it on turn change and also it depends now on this.dests
            //       as far as i can tell the analogous logic for setting up move/pre-move destinations is in state.ts->configure->call to setSelected
            if (this.mycolor === this.turnColor) {
                // when turn gets mine, if a piece is being dragged or is selected, then pre-drop dests should be hidden and replaced by dests
                this.chessground.state.predroppable.dropDests = undefined; // always clean up predrop dests when my turn starts
                const pdrole = this.chessground.state.dropmode.active ? // TODO: Sometimes dropmode.piece is not cleaned-up so best check if active==true. Maybe clean it in drop.cancelDropMode() together with everything else there?
                    (_a = this.chessground.state.dropmode.piece) === null || _a === void 0 ? void 0 : _a.role :
                    ((_b = this.chessground.state.draggable.current) === null || _b === void 0 ? void 0 : _b.piece.role) ?
                        (_c = this.chessground.state.draggable.current) === null || _c === void 0 ? void 0 : _c.piece.role :
                        undefined;
                if (pdrole) { // is there a pocket piece that is being dragged or is selected for dropping
                    const dropDests = new Map([[pdrole, this.dests[(0, chess_1.role2san)(pdrole) + "@"]]]);
                    this.chessground.set({
                        dropmode: {
                            dropDests: dropDests
                        }
                    }); // if yes - show normal dests on turn start after the pre-drop dests were hidden
                }
            }
            else {
                if (this.chessground.state.draggable.current) {
                    // we have just received a message from the server confirming it is not our turn (i.e. we must have just moved a piece)
                    // at the same time we are dragging a piece - either we are very fast and managed to grab another piece while
                    // waiting for server's message that confirm the move we just made, or the move we just made was a pre-move/pre-drop
                    // either way we have to init the predrop destinations so they can be highlighted
                    const dropDests = (0, predrop_1.default)(this.chessground.state.pieces, this.chessground.state.draggable.current.piece, this.chessground.state.geometry, this.chessground.state.variant);
                    this.chessground.set({
                        predroppable: {
                            dropDests: dropDests
                        }
                    });
                }
            }
            // list of legal promotion moves
            this.promotions = msg.promo;
            this.clocktimes = msg.clocks;
            this.result = msg.result;
            this.status = msg.status;
            if (msg.steps.length > 1) {
                this.steps = [];
                const container = document.getElementById('movelist');
                patch(container, (0, h_1.h)('div#movelist'));
                msg.steps.forEach((step) => {
                    this.steps.push(step);
                });
                const full = true;
                const activate = true;
                const result = false;
                (0, movelist_1.updateMovelist)(this, full, activate, result);
            }
            else {
                if (msg.ply === this.steps.length) {
                    const step = {
                        'fen': msg.fen,
                        'move': msg.lastMove,
                        'check': msg.check,
                        'turnColor': this.turnColor,
                        'san': msg.steps[0].san,
                    };
                    this.steps.push(step);
                    const full = false;
                    const activate = !this.spectator || latestPly;
                    const result = false;
                    (0, movelist_1.updateMovelist)(this, full, activate, result);
                }
            }
            this.clockOn = Number(msg.ply) >= 2;
            if ((!this.spectator && this.clockOn) || this.tournamentGame) {
                const container = document.getElementById('abort');
                if (container)
                    patch(container, (0, h_1.h)('div'));
            }
            let lastMove = msg.lastMove;
            if (lastMove !== null) {
                lastMove = (0, chess_1.uci2cg)(lastMove);
                // drop lastMove causing scrollbar flicker,
                // so we remove from part to avoid that
                lastMove = lastMove.includes('@') ? [lastMove.slice(-2)] : [lastMove.slice(0, 2), lastMove.slice(2, 4)];
            }
            const step = this.steps[this.steps.length - 1];
            let capture = false;
            if (step.san !== undefined) {
                capture = step.san.slice(1, 2) === 'x';
            }
            if (lastMove !== null && (this.turnColor === this.mycolor || this.spectator)) {
                sound_1.sound.moveSound(this.variant, capture);
            }
            else {
                lastMove = [];
            }
            this.checkStatus(msg);
            if (!this.spectator && msg.check) {
                sound_1.sound.check();
            }
            if (this.variant.counting) {
                this.updateCount(msg.fen);
            }
            if (this.variant.materialPoint) {
                this.updatePoint(msg.fen);
            }
            const oppclock = !this.flip ? 0 : 1;
            const myclock = 1 - oppclock;
            this.clocks[0].pause(false);
            this.clocks[1].pause(false);
            if (this.byoyomi) {
                this.clocks[oppclock].byoyomiPeriod = msg.byo[(this.oppcolor === 'white') ? 0 : 1];
                this.clocks[myclock].byoyomiPeriod = msg.byo[(this.mycolor === 'white') ? 0 : 1];
            }
            this.clocks[oppclock].setTime(this.clocktimes[this.oppcolor]);
            this.clocks[myclock].setTime(this.clocktimes[this.mycolor]);
            if (this.spectator) {
                if (latestPly) {
                    this.chessground.set({
                        fen: parts[0],
                        turnColor: this.turnColor,
                        check: msg.check,
                        lastMove: lastMove,
                    });
                    if (pocketsChanged)
                        (0, pocket_1.updatePockets)(this, this.vpocket0, this.vpocket1);
                }
                if (this.clockOn && msg.status < 0) {
                    if (this.turnColor === this.mycolor) {
                        this.clocks[myclock].start();
                    }
                    else {
                        this.clocks[oppclock].start();
                    }
                }
            }
            else {
                if (this.turnColor === this.mycolor) {
                    if (latestPly) {
                        this.chessground.set({
                            fen: parts[0],
                            turnColor: this.turnColor,
                            movable: {
                                free: false,
                                color: this.mycolor,
                                dests: this.dests,
                            },
                            check: msg.check,
                            lastMove: lastMove,
                        });
                        if (pocketsChanged)
                            (0, pocket_1.updatePockets)(this, this.vpocket0, this.vpocket1);
                        if (!this.focus)
                            this.notifyMsg(`Played ${step.san}\nYour turn.`);
                        // prevent sending premove/predrop when (auto)reconnecting websocked asks server to (re)sends the same board to us
                        // console.log("trying to play premove....");
                        if (this.premove)
                            this.performPremove();
                        if (this.predrop)
                            this.performPredrop();
                    }
                    if (this.clockOn && msg.status < 0) {
                        this.clocks[myclock].start();
                        // console.log('MY CLOCK STARTED');
                    }
                }
                else {
                    this.chessground.set({
                        // giving fen here will place castling rooks to their destination in chess960 variants
                        fen: parts[0],
                        turnColor: this.turnColor,
                        check: msg.check,
                    });
                    if (this.clockOn && msg.status < 0) {
                        this.clocks[oppclock].start();
                        // console.log('OPP CLOCK  STARTED');
                    }
                }
            }
            ;
        };
        this.goPly = (ply) => {
            const step = this.steps[ply];
            if (step === undefined)
                return;
            let move = step['move'];
            let capture = false;
            if (move !== undefined) {
                move = (0, chess_1.uci2cg)(move);
                move = move.includes('@') ? [move.slice(-2)] : [move.slice(0, 2), move.slice(2, 4)];
                // 960 king takes rook castling is not capture
                capture = (this.chessground.state.pieces[move[move.length - 1]] !== undefined && step.san.slice(0, 2) !== 'O-') || (step.san.slice(1, 2) === 'x');
            }
            this.chessground.set({
                fen: step.fen,
                turnColor: step.turnColor,
                movable: {
                    free: false,
                    color: this.spectator ? undefined : step.turnColor,
                    dests: (this.turnColor === this.mycolor && this.result === "*" && ply === this.steps.length - 1) ? this.dests : undefined,
                },
                check: step.check,
                lastMove: move,
            });
            this.fullfen = step.fen;
            (0, pocket_1.updatePockets)(this, this.vpocket0, this.vpocket1);
            if (this.variant.counting) {
                this.updateCount(step.fen);
            }
            if (this.variant.materialPoint) {
                this.updatePoint(step.fen);
            }
            if (ply === this.ply + 1) {
                sound_1.sound.moveSound(this.variant, capture);
            }
            this.ply = ply;
        };
        this.doSend = (message) => {
            // console.log("---> doSend():", message);
            this.sock.send(JSON.stringify(message));
        };
        this.sendMove = (orig, dest, promo) => {
            // pause() will add increment!
            const oppclock = !this.flip ? 0 : 1;
            const myclock = 1 - oppclock;
            const movetime = (this.clocks[myclock].running) ? Date.now() - this.clocks[myclock].startTime : 0;
            this.clocks[myclock].pause((this.base === 0 && this.ply < 2) ? false : true);
            // console.log("sendMove(orig, dest, prom)", orig, dest, promo);
            const move = (0, chess_1.cg2uci)(orig + dest + promo);
            // console.log("sendMove(move)", move);
            let bclock, clocks;
            if (!this.flip) {
                bclock = this.mycolor === "black" ? 1 : 0;
            }
            else {
                bclock = this.mycolor === "black" ? 0 : 1;
            }
            const wclock = 1 - bclock;
            const increment = (this.inc > 0 && this.ply >= 2 && !this.byoyomi) ? this.inc * 1000 : 0;
            const bclocktime = (this.mycolor === "black" && this.preaction) ? this.clocktimes.black + increment : this.clocks[bclock].duration;
            const wclocktime = (this.mycolor === "white" && this.preaction) ? this.clocktimes.white + increment : this.clocks[wclock].duration;
            clocks = { movetime: (this.preaction) ? 0 : movetime, black: bclocktime, white: wclocktime };
            this.lastMaybeSentMsgMove = { type: "move", gameId: this.gameId, move: move, clocks: clocks, ply: this.ply + 1 };
            this.doSend(this.lastMaybeSentMsgMove);
            if (this.clockOn)
                this.clocks[oppclock].start();
        };
        this.startCount = () => {
            this.doSend({ type: "count", gameId: this.gameId, mode: "start" });
        };
        this.stopCount = () => {
            this.doSend({ type: "count", gameId: this.gameId, mode: "stop" });
        };
        this.updateCount = (fen) => {
            [this.vmiscInfoW, this.vmiscInfoB] = (0, info_1.updateCount)(fen, this.vmiscInfoW, this.vmiscInfoB);
            const countButton = document.getElementById('count');
            if (countButton) {
                const [, , countingSide, countingType] = (0, chess_1.getCounting)(fen);
                const myturn = this.mycolor === this.turnColor;
                if (countingType === 'board')
                    if ((countingSide === 'w' && this.mycolor === 'white') || (countingSide === 'b' && this.mycolor === 'black'))
                        patch(countButton, (0, h_1.h)('button#count', { on: { click: () => this.stopCount() }, props: { title: (0, i18n_1._)('Stop counting') }, class: { disabled: !myturn } }, (0, i18n_1._)('Stop')));
                    else
                        patch(countButton, (0, h_1.h)('button#count', { on: { click: () => this.startCount() }, props: { title: (0, i18n_1._)('Start counting') }, class: { disabled: !(myturn && countingSide === '') } }, (0, i18n_1._)('Count')));
                else
                    patch(countButton, (0, h_1.h)('button#count', { props: { title: (0, i18n_1._)('Start counting') }, class: { disabled: true } }, (0, i18n_1._)('Count')));
            }
        };
        this.updatePoint = (fen) => {
            [this.vmiscInfoW, this.vmiscInfoB] = (0, info_1.updatePoint)(fen, this.vmiscInfoW, this.vmiscInfoB);
        };
        this.onMove = () => {
            return (orig, dest, capturedPiece) => {
                console.log("   ground.onMove()", orig, dest, capturedPiece);
                sound_1.sound.moveSound(this.variant, capturedPiece);
            };
        };
        this.onDrop = () => {
            return (piece, dest) => {
                // console.log("ground.onDrop()", piece, dest);
                if (dest != 'a0' && piece.role && (0, chess_1.dropIsValid)(this.dests, piece.role, dest)) {
                    sound_1.sound.moveSound(this.variant, false);
                }
            };
        };
        this.setPremove = (orig, dest, metadata) => {
            this.premove = { orig, dest, metadata };
            // console.log("setPremove() to:", orig, dest, meta);
        };
        this.unsetPremove = () => {
            this.premove = null;
            this.preaction = false;
        };
        this.setPredrop = (role, key) => {
            this.predrop = { role, key };
            // console.log("setPredrop() to:", role, key);
        };
        this.unsetPredrop = () => {
            this.predrop = null;
            this.preaction = false;
        };
        this.performPremove = () => {
            // const { orig, dest, meta } = this.premove;
            // TODO: promotion?
            // console.log("performPremove()", orig, dest, meta);
            this.chessground.playPremove();
            this.premove = null;
        };
        this.performPredrop = () => {
            // const { role, key } = this.predrop;
            // console.log("performPredrop()", role, key);
            this.chessground.playPredrop(drop => { return (0, chess_1.dropIsValid)(this.dests, drop.role, drop.key); });
            this.predrop = null;
        };
        this.onUserMove = (orig, dest, meta) => {
            this.preaction = meta.premove === true;
            // chessground doesn't knows about ep, so we have to remove ep captured pawn
            const pieces = this.chessground.state.pieces;
            // console.log("ground.onUserMove()", orig, dest, meta);
            let moved = pieces[dest];
            // Fix king to rook 960 castling case
            if (moved === undefined)
                moved = { role: 'k-piece', color: this.mycolor };
            if (meta.captured === undefined && moved !== undefined && moved.role === "p-piece" && orig[0] != dest[0] && this.variant.enPassant) {
                const pos = (0, util_1.key2pos)(dest), pawnPos = [pos[0], pos[1] + (this.mycolor === 'white' ? -1 : 1)];
                const diff = {};
                diff[(0, util_1.pos2key)(pawnPos)] = undefined;
                this.chessground.setPieces(diff);
                meta.captured = { role: "p-piece" };
            }
            // increase pocket count
            if (this.variant.drop && meta.captured) {
                let role = meta.captured.role;
                if (meta.captured.promoted)
                    role = (this.variant.promotion === 'shogi' || this.variant.promotion === 'kyoto') ? meta.captured.role.slice(1) : "p-piece";
                let position = (this.turnColor === this.mycolor) ? "bottom" : "top";
                if (this.flip)
                    position = (position === "top") ? "bottom" : "top";
                if (position === "top") { // TODO:this refreshes pockets similar to pocket.ts -> updatePockets() - consider moving all pocket related logic there maybe?
                    this.pockets[0][role]++;
                    this.vpocket0 = patch(this.vpocket0, (0, pocket_1.pocketView)(this, this.turnColor, "top"));
                }
                else {
                    this.pockets[1][role]++;
                    this.vpocket1 = patch(this.vpocket1, (0, pocket_1.pocketView)(this, this.turnColor, "bottom"));
                }
            }
            //  gating elephant/hawk
            if (this.variant.gate) {
                if (!this.promotion.start(moved.role, orig, dest, meta.ctrlKey) && !this.gating.start(this.fullfen, orig, dest))
                    this.sendMove(orig, dest, '');
            }
            else {
                if (!this.promotion.start(moved.role, orig, dest, meta.ctrlKey))
                    this.sendMove(orig, dest, '');
                this.preaction = false;
            }
        };
        this.onUserDrop = (role, dest, meta) => {
            (0, drop_1.cancelDropMode)(this.chessground.state); // drop of new piece was actually performed - lets set dropmode to not active. Maybe this logic better belongs in chessgroudx?
            this.preaction = meta.predrop === true;
            // console.log("ground.onUserDrop()", role, dest, meta);
            // decrease pocket count
            if ((0, chess_1.dropIsValid)(this.dests, role, dest)) {
                let position = (this.turnColor === this.mycolor) ? "bottom" : "top";
                if (this.flip)
                    position = (position === "top") ? "bottom" : "top";
                if (position === "top") {
                    this.pockets[0][role]--;
                    this.vpocket0 = patch(this.vpocket0, (0, pocket_1.pocketView)(this, this.turnColor, "top"));
                }
                else {
                    this.pockets[1][role]--;
                    this.vpocket1 = patch(this.vpocket1, (0, pocket_1.pocketView)(this, this.turnColor, "bottom"));
                }
                if (this.variant.promotion === 'kyoto') {
                    if (!this.promotion.start(role, 'a0', dest))
                        this.sendMove((0, chess_1.role2san)(role) + "@", dest, '');
                }
                else {
                    this.sendMove((0, chess_1.role2san)(role) + "@", dest, '');
                }
                // console.log("sent move", move);
            }
            else {
                // console.log("!!! invalid move !!!", role, dest);
                // restore board
                this.chessground.set({
                    fen: this.fullfen,
                    lastMove: this.lastmove,
                    turnColor: this.mycolor,
                    animation: { enabled: this.animation },
                    movable: {
                        dests: this.dests,
                        showDests: this.showDests,
                    },
                });
            }
            this.preaction = false;
        };
        this.onSelect = () => {
            return (key) => {
                var _a;
                if (this.chessground.state.movable.dests === undefined)
                    return;
                // Save state.pieces to help recognise 960 castling (king takes rook) moves
                // Shouldn't this be implemented in chessground instead?
                if (this.chess960 && this.variant.gate) {
                    this.prevPieces = Object.assign({}, this.chessground.state.pieces);
                }
                // Janggi pass and Sittuyin in place promotion on Ctrl+click
                if (this.chessground.state.stats.ctrlKey &&
                    ((_a = this.chessground.state.movable.dests[key]) === null || _a === void 0 ? void 0 : _a.includes(key))) {
                    const piece = this.chessground.state.pieces[key];
                    if (this.variant.name === 'sittuyin') { // TODO make this more generic
                        // console.log("Ctrl in place promotion", key);
                        const pieces = {};
                        pieces[key] = {
                            color: piece.color,
                            role: 'f-piece',
                            promoted: true
                        };
                        this.chessground.setPieces(pieces);
                        this.sendMove(key, key, 'f');
                    }
                    else if (this.variant.pass && piece.role === 'k-piece') {
                        this.pass();
                    }
                }
            };
        };
        this.onCancelDropMode = () => {
            return () => { (0, pocket_1.refreshPockets)(this); };
        };
        this.renderExpiration = () => {
            if (this.spectator)
                return;
            let position = (this.turnColor === this.mycolor) ? "bottom" : "top";
            if (this.flip)
                position = (position === "top") ? "bottom" : "top";
            let expi = (position === 'top') ? 0 : 1;
            const timeLeft = Math.max(0, this.expiStart - Date.now() + this.firstmovetime);
            // console.log("renderExpiration()", position, timeLeft);
            if (timeLeft === 0 || this.status >= 0) {
                this.expirations[expi] = patch(this.expirations[expi], (0, h_1.h)('div#expiration-' + position));
            }
            else {
                const emerg = (this.turnColor === this.mycolor && timeLeft < 8000);
                if (!rang && emerg) {
                    sound_1.sound.lowTime();
                    rang = true;
                }
                this.expirations[expi] = patch(this.expirations[expi], (0, h_1.h)('div#expiration-' + position + '.expiration', { class: { emerg, 'bar-glider': this.turnColor === this.mycolor }
                }, [(0, h_1.h)('strong', Math.floor(timeLeft / 1000)), 'seconds to play the first move']));
            }
        };
        this.showExpiration = () => {
            if (this.expiStart === 0 || this.spectator)
                return;
            this.renderExpiration();
            setTimeout(this.showExpiration, 250);
        };
        this.onMsgUserConnected = (msg) => {
            this.model["username"] = msg["username"];
            if (this.spectator) {
                this.doSend({ type: "is_user_present", username: this.wplayer, gameId: this.gameId });
                this.doSend({ type: "is_user_present", username: this.bplayer, gameId: this.gameId });
                // we want to know lastMove and check status
                this.doSend({ type: "board", gameId: this.gameId });
            }
            else {
                this.firstmovetime = msg.firstmovetime;
                const opp_name = this.model["username"] === this.wplayer ? this.bplayer : this.wplayer;
                this.doSend({ type: "is_user_present", username: opp_name, gameId: this.gameId });
                const container = document.getElementById('player1');
                patch(container, (0, h_1.h)('i-side.online#player1', { class: { "icon": true, "icon-online": true, "icon-offline": false } }));
                // prevent sending gameStart message when user just reconecting
                if (msg.ply === 0) {
                    this.doSend({ type: "ready", gameId: this.gameId });
                }
                this.doSend({ type: "board", gameId: this.gameId });
            }
        };
        this.onMsgSpectators = (msg) => {
            const container = document.getElementById('spectators');
            patch(container, (0, h_1.h)('under-left#spectators', (0, i18n_1._)('Spectators: ') + msg.spectators));
        };
        this.onMsgUserPresent = (msg) => {
            // console.log(msg);
            if (msg.username === this.players[0]) {
                const container = document.getElementById('player0');
                patch(container, (0, h_1.h)('i-side.online#player0', { class: { "icon": true, "icon-online": true, "icon-offline": false } }));
            }
            else {
                const container = document.getElementById('player1');
                patch(container, (0, h_1.h)('i-side.online#player1', { class: { "icon": true, "icon-online": true, "icon-offline": false } }));
            }
        };
        this.onMsgUserDisconnected = (msg) => {
            // console.log(msg);
            if (msg.username === this.players[0]) {
                const container = document.getElementById('player0');
                patch(container, (0, h_1.h)('i-side.online#player0', { class: { "icon": true, "icon-online": false, "icon-offline": true } }));
            }
            else {
                const container = document.getElementById('player1');
                patch(container, (0, h_1.h)('i-side.online#player1', { class: { "icon": true, "icon-online": false, "icon-offline": true } }));
            }
        };
        this.onMsgChat = (msg) => {
            if ((this.spectator && msg.room === 'spectator') || (!this.spectator && msg.room !== 'spectator') || msg.user.length === 0) {
                (0, chat_1.chatMessage)(msg.user, msg.message, "roundchat");
            }
        };
        this.onMsgFullChat = (msg) => {
            // To prevent multiplication of messages we have to remove old messages div first
            patch(document.getElementById('messages'), (0, h_1.h)('div#messages-clear'));
            // then create a new one
            patch(document.getElementById('messages-clear'), (0, h_1.h)('div#messages'));
            msg.lines.forEach((line) => {
                if ((this.spectator && line.room === 'spectator') || (!this.spectator && line.room !== 'spectator') || line.user.length === 0) {
                    (0, chat_1.chatMessage)(line.user, line.message, "roundchat");
                }
            });
        };
        this.onMsgMoreTime = (msg) => {
            (0, chat_1.chatMessage)('', msg.username + (0, i18n_1._)(' +15 seconds'), "roundchat");
            if (this.spectator) {
                if (msg.username === this.players[0]) {
                    this.clocks[0].setTime(this.clocks[0].duration + 15 * 1000);
                }
                else {
                    this.clocks[1].setTime(this.clocks[1].duration + 15 * 1000);
                }
            }
            else {
                this.clocks[1].setTime(this.clocks[1].duration + 15 * 1000);
            }
        };
        this.onMsgOffer = (msg) => {
            (0, chat_1.chatMessage)("", msg.message, "roundchat");
        };
        this.onMsgGameNotFound = (msg) => {
            alert((0, i18n_1._)("Requested game %1 not found!", msg['gameId']));
            window.location.assign(this.model["home"]);
        };
        this.onMsgShutdown = (msg) => {
            alert(msg.message);
        };
        this.onMsgCtable = (ct, gameId) => {
            if (ct !== "") {
                this.ctableContainer = patch(this.ctableContainer, (0, h_1.h)('div#ctable-container'));
                this.ctableContainer = patch(this.ctableContainer, (0, crosstable_1.crosstableView)(ct, gameId));
            }
        };
        this.onMsgCount = (msg) => {
            (0, chat_1.chatMessage)("", msg.message, "roundchat");
            if (msg.message.endsWith("started")) {
                if (this.turnColor === 'white')
                    this.vmiscInfoW = patch(this.vmiscInfoW, (0, h_1.h)('div#count-white', '0/64'));
                else
                    this.vmiscInfoB = patch(this.vmiscInfoB, (0, h_1.h)('div#count-black', '0/64'));
            }
            else if (msg.message.endsWith("stopped")) {
                if (this.turnColor === 'white')
                    this.vmiscInfoW = patch(this.vmiscInfoW, (0, h_1.h)('div#count-white', ''));
                else
                    this.vmiscInfoB = patch(this.vmiscInfoB, (0, h_1.h)('div#count-black', ''));
            }
        };
        this.onMessage = (evt) => {
            // console.log("<+++ onMessage():", evt.data);
            const msg = JSON.parse(evt.data);
            switch (msg.type) {
                case "board":
                    this.onMsgBoard(msg);
                    break;
                case "crosstable":
                    this.onMsgCtable(msg.ct, this.gameId);
                    break;
                case "gameEnd":
                    this.checkStatus(msg);
                    break;
                case "gameStart":
                    this.onMsgGameStart(msg);
                    break;
                case "game_user_connected":
                    this.onMsgUserConnected(msg);
                    break;
                case "user_present":
                    this.onMsgUserPresent(msg);
                    break;
                case "spectators":
                    this.onMsgSpectators(msg);
                    break;
                case "user_disconnected":
                    this.onMsgUserDisconnected(msg);
                    break;
                case "roundchat":
                    this.onMsgChat(msg);
                    break;
                case "fullchat":
                    this.onMsgFullChat(msg);
                    break;
                case "new_game":
                    this.onMsgNewGame(msg);
                    break;
                case "view_rematch":
                    this.onMsgViewRematch(msg);
                    break;
                case "offer":
                    this.onMsgOffer(msg);
                    break;
                case "moretime":
                    this.onMsgMoreTime(msg);
                    break;
                case "updateTV":
                    this.onMsgUpdateTV(msg);
                    break;
                case "game_not_found":
                    this.onMsgGameNotFound(msg);
                    break;
                case "shutdown":
                    this.onMsgShutdown(msg);
                    break;
                case "logout":
                    this.doSend({ type: "logout" });
                    break;
                case "setup":
                    this.onMsgSetup(msg);
                    break;
                case "count":
                    this.onMsgCount(msg);
                    break;
            }
        };
        this.focus = !document.hidden;
        document.addEventListener("visibilitychange", () => { this.focus = !document.hidden; });
        window.addEventListener('blur', () => { this.focus = false; });
        window.addEventListener('focus', () => { this.focus = true; });
        const onOpen = (evt) => {
            console.log("ctrl.onOpen()", evt);
            if (this.lastMaybeSentMsgMove && this.lastMaybeSentMsgMove.ply === this.ply + 1) {
                // if this.ply === this.lastMaybeSentMsgMove.ply it would mean the move message was received by server and it has replied with "board" message, confirming and updating the state, including this.ply
                // since they are not equal, but also one ply behind, means we should try to re-send it
                try {
                    console.log("resending unsent message ", this.lastMaybeSentMsgMove);
                    this.doSend(this.lastMaybeSentMsgMove);
                }
                catch (e) {
                    console.log("could not even REsend unsent message ", this.lastMaybeSentMsgMove);
                }
            }
            this.clocks[0].connecting = false;
            this.clocks[1].connecting = false;
            const cl = document.body.classList; // removing the "reconnecting" message in lower left corner
            cl.remove('offline');
            cl.add('online');
            this.doSend({ type: "game_user_connected", username: this.model["username"], gameId: this.model["gameId"] });
        };
        const opts = {
            maxAttempts: 10,
            onopen: e => onOpen(e),
            onmessage: e => this.onMessage(e),
            onreconnect: e => {
                this.clocks[0].connecting = true;
                this.clocks[1].connecting = true;
                console.log('Reconnecting in round...', e);
                // relevant to the "reconnecting" message in lower left corner
                document.body.classList.add('offline');
                document.body.classList.remove('online');
                document.body.classList.add('reconnected'); // this will trigger the animation once we get "online" class added back on reconnect
                const container = document.getElementById('player1');
                patch(container, (0, h_1.h)('i-side.online#player1', { class: { "icon": true, "icon-online": false, "icon-offline": true } }));
            },
            onmaximum: e => console.log('Stop Attempting!', e),
            onclose: e => console.log('Closed!', e),
            onerror: e => console.log('Error:', e),
        };
        const ws = (location.host.indexOf('pychess') === -1) ? 'ws://' : 'wss://';
        this.sock = new sockette_1.default(ws + location.host + "/wsr", opts);
        this.model = model;
        this.gameId = model["gameId"];
        this.variant = chess_1.VARIANTS[model["variant"]];
        this.chess960 = model["chess960"] === 'True';
        this.fullfen = model["fen"];
        this.wplayer = model["wplayer"];
        this.bplayer = model["bplayer"];
        this.base = Number(model["base"]);
        this.inc = Number(model["inc"]);
        this.byoyomiPeriod = Number(model["byo"]);
        this.byoyomi = this.variant.timeControl === 'byoyomi';
        this.status = Number(model["status"]);
        this.tv = model["tv"];
        this.steps = [];
        this.pgn = "";
        this.ply = -1;
        this.flip = false;
        this.settings = true;
        this.animation = localStorage.animation === undefined ? true : localStorage.animation === "true";
        this.showDests = localStorage.showDests === undefined ? true : localStorage.showDests === "true";
        this.blindfold = localStorage.blindfold === undefined ? false : localStorage.blindfold === "true";
        this.autoqueen = localStorage.autoqueen === undefined ? false : localStorage.autoqueen === "true";
        this.spectator = this.model["username"] !== this.wplayer && this.model["username"] !== this.bplayer;
        this.hasPockets = this.variant.pocket;
        this.handicap = this.variant.alternateStart ? Object.keys(this.variant.alternateStart).some(alt => (0, chess_1.isHandicap)(alt) && this.variant.alternateStart[alt] === this.fullfen) : false;
        // orientation = this.mycolor
        if (this.spectator) {
            this.mycolor = 'white';
            this.oppcolor = 'black';
        }
        else {
            this.mycolor = this.model["username"] === this.wplayer ? 'white' : 'black';
            this.oppcolor = this.model["username"] === this.wplayer ? 'black' : 'white';
        }
        // players[0] is top player, players[1] is bottom player
        this.players = [
            this.mycolor === "white" ? this.bplayer : this.wplayer,
            this.mycolor === "white" ? this.wplayer : this.bplayer
        ];
        this.titles = [
            this.mycolor === "white" ? this.model['btitle'] : this.model['wtitle'],
            this.mycolor === "white" ? this.model['wtitle'] : this.model['btitle']
        ];
        this.ratings = [
            this.mycolor === "white" ? this.model['brating'] : this.model['wrating'],
            this.mycolor === "white" ? this.model['wrating'] : this.model['brating']
        ];
        this.premove = null;
        this.predrop = null;
        this.preaction = false;
        this.result = "*";
        const parts = this.fullfen.split(" ");
        this.tournamentGame = this.model["tournamentId"] !== '';
        this.clockOn = (Number(parts[parts.length - 1]) >= 2);
        const fen_placement = parts[0];
        this.turnColor = parts[1] === "w" ? "white" : "black";
        this.steps.push({
            'fen': this.fullfen,
            'move': undefined,
            'check': false,
            'turnColor': this.turnColor,
        });
        this.chessground = (0, chessgroundx_1.Chessground)(el, {
            fen: fen_placement,
            variant: this.variant.name,
            geometry: this.variant.geometry,
            chess960: this.chess960,
            notation: (this.variant.name === 'janggi') ? 6 /* JANGGI */ : 0 /* DEFAULT */,
            orientation: this.mycolor,
            turnColor: this.turnColor,
            autoCastle: this.variant.name !== 'cambodian',
            animation: { enabled: this.animation },
        });
        if (this.spectator) {
            this.chessground.set({
                //viewOnly: false,
                movable: { free: false },
                draggable: { enabled: false },
                premovable: { enabled: false },
                predroppable: { enabled: false },
                events: { move: this.onMove() }
            });
        }
        else {
            this.chessground.set({
                animation: { enabled: this.animation },
                movable: {
                    free: false,
                    color: this.mycolor,
                    showDests: this.showDests,
                    events: {
                        after: this.onUserMove,
                        afterNewPiece: this.onUserDrop,
                    }
                },
                premovable: {
                    enabled: true,
                    events: {
                        set: this.setPremove,
                        unset: this.unsetPremove,
                    }
                },
                predroppable: {
                    enabled: true,
                    events: {
                        set: this.setPredrop,
                        unset: this.unsetPredrop,
                    }
                },
                events: {
                    move: this.onMove(),
                    dropNewPiece: this.onDrop(),
                    select: this.onSelect(),
                },
                dropmode: {
                    events: {
                        cancel: this.onCancelDropMode()
                    }
                }
            });
        }
        this.gating = new gating_1.Gating(this);
        this.promotion = new promotion_1.Promotion(this);
        // initialize users
        const player0 = document.getElementById('rplayer0');
        const player1 = document.getElementById('rplayer1');
        this.vplayer0 = patch(player0, (0, player_1.player)('player0', this.titles[0], this.players[0], this.ratings[0], model["level"]));
        this.vplayer1 = patch(player1, (0, player_1.player)('player1', this.titles[1], this.players[1], this.ratings[1], model["level"]));
        // initialize pockets
        if (this.hasPockets) {
            const pocket0 = document.getElementById('pocket0');
            const pocket1 = document.getElementById('pocket1');
            (0, pocket_1.updatePockets)(this, pocket0, pocket1);
        }
        // initialize expirations
        this.expirations = [
            document.getElementById('expiration-top'),
            document.getElementById('expiration-bottom')
        ];
        // initialize clocks
        this.clocktimes = {};
        const c0 = new clock_1.Clock(this.base, this.inc, this.byoyomiPeriod, document.getElementById('clock0'), 'clock0');
        const c1 = new clock_1.Clock(this.base, this.inc, this.byoyomiPeriod, document.getElementById('clock1'), 'clock1');
        this.clocks = [c0, c1];
        this.clocks[0].onTick(this.clocks[0].renderTime);
        this.clocks[1].onTick(this.clocks[1].renderTime);
        const onMoreTime = () => {
            // TODO: enable when this.flip is true
            if (this.model['wtitle'] === 'BOT' || this.model['btitle'] === 'BOT' || this.spectator || this.status >= 0 || this.flip)
                return;
            this.clocks[0].setTime(this.clocks[0].duration + 15 * 1000);
            this.doSend({ type: "moretime", gameId: this.gameId });
            const oppName = (this.model["username"] === this.wplayer) ? this.bplayer : this.wplayer;
            (0, chat_1.chatMessage)('', oppName + (0, i18n_1._)(' +15 seconds'), "roundchat");
        };
        if (!this.spectator && model["rated"] != '1' && this.model['wtitle'] !== 'BOT' && this.model['btitle'] !== 'BOT') {
            const container = document.getElementById('more-time');
            patch(container, (0, h_1.h)('div#more-time', [
                (0, h_1.h)('button.icon.icon-plus-square', {
                    props: { type: "button", title: (0, i18n_1._)("Give 15 seconds") },
                    on: { click: () => onMoreTime() }
                })
            ]));
        }
        // initialize crosstable
        this.ctableContainer = document.getElementById('ctable-container');
        const misc0 = document.getElementById('misc-info0');
        const misc1 = document.getElementById('misc-info1');
        // initialize material point and counting indicator
        if (this.variant.materialPoint || this.variant.counting) {
            this.vmiscInfoW = this.mycolor === 'white' ? patch(misc1, (0, h_1.h)('div#misc-infow')) : patch(misc0, (0, h_1.h)('div#misc-infow'));
            this.vmiscInfoB = this.mycolor === 'black' ? patch(misc1, (0, h_1.h)('div#misc-infob')) : patch(misc0, (0, h_1.h)('div#misc-infob'));
        }
        const flagCallback = () => {
            if (this.turnColor === this.mycolor) {
                this.chessground.stop();
                // console.log("Flag");
                this.doSend({ type: "flag", gameId: this.gameId });
            }
        };
        const byoyomiCallback = () => {
            if (this.turnColor === this.mycolor) {
                // console.log("Byoyomi", this.clocks[1].byoyomiPeriod);
                const oppclock = !this.flip ? 0 : 1;
                const myclock = 1 - oppclock;
                this.doSend({ type: "byoyomi", gameId: this.gameId, color: this.mycolor, period: this.clocks[myclock].byoyomiPeriod });
            }
        };
        if (!this.spectator) {
            if (this.byoyomiPeriod > 0) {
                this.clocks[1].onByoyomi(byoyomiCallback);
            }
            this.clocks[1].onFlag(flagCallback);
        }
        const container = document.getElementById('game-controls');
        if (!this.spectator) {
            const pass = this.variant.pass;
            this.gameControls = patch(container, (0, h_1.h)('div.btn-controls', [
                (0, h_1.h)('button#abort', { on: { click: () => this.abort() }, props: { title: (0, i18n_1._)('Abort') } }, [(0, h_1.h)('i', { class: { "icon": true, "icon-abort": true } }),]),
                (0, h_1.h)('button#count', (0, i18n_1._)('Count')),
                (0, h_1.h)('button#draw', { on: { click: () => (pass) ? this.pass() : this.draw() }, props: { title: (pass) ? (0, i18n_1._)('Pass') : (0, i18n_1._)("Draw") } }, [(pass) ? (0, i18n_1._)('Pass') : (0, h_1.h)('i', '½')]),
                (0, h_1.h)('button#resign', { on: { click: () => this.resign() }, props: { title: (0, i18n_1._)("Resign") } }, [(0, h_1.h)('i', { class: { "icon": true, "icon-flag-o": true } }),]),
            ]));
            const manualCount = this.variant.counting === 'makruk' && !(this.model['wtitle'] === 'BOT' || this.model['btitle'] === 'BOT');
            if (!manualCount)
                patch(document.getElementById('count'), (0, h_1.h)('div'));
        }
        else {
            this.gameControls = patch(container, (0, h_1.h)('div.btn-controls'));
        }
        (0, movelist_1.createMovelistButtons)(this);
        this.vmovelist = document.getElementById('movelist');
        patch(document.getElementById('roundchat'), (0, chat_1.chatView)(this, "roundchat"));
        boardSettings_1.boardSettings.ctrl = this;
        const boardFamily = this.variant.board;
        const pieceFamily = this.variant.piece;
        boardSettings_1.boardSettings.updateBoardStyle(boardFamily);
        boardSettings_1.boardSettings.updatePieceStyle(pieceFamily);
        boardSettings_1.boardSettings.updateZoom(boardFamily);
        boardSettings_1.boardSettings.updateBlindfold();
    }
}
exports.default = RoundController;

},{"./boardSettings":5,"./chat":7,"./chess":8,"./clock":10,"./crosstable":11,"./gating":17,"./i18n":18,"./info":19,"./movelist":32,"./notification":33,"./player":36,"./pocket":38,"./profile":39,"./promotion":40,"./sound":45,"chessgroundx":55,"chessgroundx/drop":59,"chessgroundx/predrop":63,"chessgroundx/util":69,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"sockette":97}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BooleanSettings = exports.NumberSettings = exports.StringSettings = void 0;
const document_1 = require("./document");
class Settings {
    constructor(name) {
        this.name = name;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        // TODO some mechanism to save settings to server
        localStorage[this.name] = value;
        this._value = value;
        this.update();
    }
}
class StringSettings extends Settings {
    constructor(name, defaultValue) {
        var _a, _b;
        super(name);
        this._value = (_b = (_a = (0, document_1.getDocumentData)(name)) !== null && _a !== void 0 ? _a : localStorage[name]) !== null && _b !== void 0 ? _b : defaultValue;
    }
}
exports.StringSettings = StringSettings;
class NumberSettings extends Settings {
    constructor(name, defaultValue) {
        var _a, _b;
        super(name);
        this._value = Number((_a = (0, document_1.getDocumentData)(name)) !== null && _a !== void 0 ? _a : ((_b = localStorage[name]) !== null && _b !== void 0 ? _b : defaultValue));
    }
}
exports.NumberSettings = NumberSettings;
class BooleanSettings extends Settings {
    constructor(name, defaultValue) {
        super(name);
        if ((0, document_1.getDocumentData)(name))
            this._value = (0, document_1.getDocumentData)(name) === 'True';
        else if (localStorage[name])
            this._value = localStorage[name] === 'true';
        else
            this._value = defaultValue;
    }
}
exports.BooleanSettings = BooleanSettings;

},{"./document":13}],44:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.settingsView = void 0;
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
const h_1 = require("snabbdom/h");
const background_1 = require("./background");
const boardSettings_1 = require("./boardSettings");
const chess_1 = require("./chess");
const document_1 = require("./document");
const i18n_1 = require("./i18n");
const sound_1 = require("./sound");
const zen_1 = require("./zen");
function settingsView() {
    const anon = (0, document_1.getDocumentData)('anon');
    const menu = (anon === 'True') ? [settingsMenu()] : [userMenu(), settingsMenu()];
    return (0, h_1.h)('div#settings-panel', [
        settingsButton(),
        (0, h_1.h)('div#settings', [
            (0, h_1.h)('div#settings-main', menu),
            (0, h_1.h)('div#settings-sub', [
                langSettingsView(),
                soundSettingsView(),
                backgroundSettingsView(),
                boardSettingsView(),
                zenModeSettingsView(),
            ]),
        ]),
    ]);
}
exports.settingsView = settingsView;
function settingsButton() {
    return (0, h_1.h)('button#btn-settings', { on: { click: toggleSettings } }, [
        (0, h_1.h)('div.icon.icon-cog'),
    ]);
}
function toggleSettings() {
    if (document.getElementById('settings').style.display === 'flex')
        hideSettings();
    else
        showMainSettings();
}
function hideSettings() {
    document.getElementById('settings').style.display = 'none';
}
function showMainSettings() {
    document.getElementById('settings').style.display = 'flex';
    document.getElementById('settings-main').style.display = 'flex';
    document.getElementById('settings-sub').style.display = 'none';
}
function userMenu() {
    return (0, h_1.h)('div#settings-buttons', [
        (0, h_1.h)('button#btn-logout', { on: { click: logoutDialog } }, (0, i18n_1._)("Log out")),
    ]);
}
function logoutDialog() {
    if (confirm((0, i18n_1._)("Are you sure you want to log out?")))
        window.location.href = "/logout";
}
function settingsMenu() {
    return (0, h_1.h)('div#settings-buttons', [
        (0, h_1.h)('button#btn-lang', { on: { click: showSubsettings } }, i18n_1.translatedLanguage),
        (0, h_1.h)('button#btn-sound', { on: { click: showSubsettings } }, (0, i18n_1._)('Sound')),
        (0, h_1.h)('button#btn-background', { on: { click: showSubsettings } }, (0, i18n_1._)('Background')),
        (0, h_1.h)('button#btn-board', { on: { click: showSubsettings } }, (0, i18n_1._)('Board Settings')),
        (0, h_1.h)('button#btn-zen', { on: { click: showSubsettings } }, (0, i18n_1._)('Zen Mode')),
    ]);
}
function showSubsettings(evt) {
    const mainSettings = document.getElementById('settings-main');
    const subSettings = document.getElementById('settings-sub');
    Array.from(subSettings.children).forEach((sub) => sub.style.display = 'none');
    const settingsName = evt.target.id.slice(4);
    const targetSettings = document.getElementById('settings-' + settingsName);
    targetSettings.style.display = 'flex';
    mainSettings.style.display = 'none';
    subSettings.style.display = 'flex';
}
function backButton(text) {
    return (0, h_1.h)('button.back', { on: { click: showMainSettings } }, [
        (0, h_1.h)('back.icon.icon-left', text),
    ]);
}
function langSettingsView() {
    return (0, h_1.h)('div#settings-lang', [
        backButton(i18n_1.translatedLanguage),
        i18n_1.languageSettings.view(),
    ]);
}
function soundSettingsView() {
    return (0, h_1.h)('div#settings-sound', [
        backButton((0, i18n_1._)("Sound")),
        (0, h_1.h)('div', [
            sound_1.volumeSettings.view(),
            sound_1.soundThemeSettings.view(),
        ]),
    ]);
}
function backgroundSettingsView() {
    return (0, h_1.h)('div#settings-background', [
        backButton((0, i18n_1._)("Background")),
        background_1.backgroundSettings.view(),
    ]);
}
function zenModeSettingsView() {
    return (0, h_1.h)('div#settings-zen', [
        backButton((0, i18n_1._)("Zen Mode")),
        zen_1.zenModeSettings.view(),
    ]);
}
function boardSettingsView() {
    const variant = (0, document_1.getDocumentData)('variant') || "chess";
    return (0, h_1.h)('div#settings-board', [
        backButton((0, i18n_1._)("Board Settings")),
        (0, h_1.h)('div', [
            (0, h_1.h)('div', [
                (0, h_1.h)('label', { props: { for: "settings-variant" } }, (0, i18n_1._)("Variant")),
                (0, chess_1.selectVariant)("settings-variant", variant, () => showVariantBoardSettings(), () => showVariantBoardSettings()),
            ]),
            (0, h_1.h)('div#board-settings'),
        ]),
    ]);
}
function showVariantBoardSettings() {
    const e = document.getElementById('settings-variant');
    const variant = e.options[e.selectedIndex].value;
    const settings = document.getElementById('board-settings');
    settings.innerHTML = "";
    patch(settings, boardSettings_1.boardSettings.view(variant));
}

},{"./background":4,"./boardSettings":5,"./chess":8,"./document":13,"./i18n":18,"./sound":45,"./zen":51,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.soundThemeSettings = exports.volumeSettings = exports.sound = void 0;
const h_1 = require("snabbdom/h");
const howler_1 = require("howler");
const settings_1 = require("./settings");
const view_1 = require("./view");
const main_1 = require("./main");
class Sounds {
    constructor() {
        this.moveSoundSet = {
            regular: { move: () => this.move(), capture: () => this.capture() },
            shogi: { move: () => this.shogimove(), capture: () => this.shogicapture() },
            atomic: { move: () => this.move(), capture: () => this.explosion() },
        };
        this.tracks = {};
    }
    updateVolume() {
        const volume = exports.volumeSettings.value;
        Object.keys(this.tracks).forEach(key => {
            this.tracks[key].volume(volume);
        });
    }
    updateSoundTheme() {
        Object.keys(Sounds.trackNames).forEach(key => {
            this.tracks[key] = this.buildSound(Sounds.trackNames[key]);
        });
    }
    buildSound(trackName) {
        const soundTheme = exports.soundThemeSettings.value;
        const soundTrack = (soundTheme === 'silent') ? 'Silence' : trackName;
        const sound = new howler_1.Howl({
            src: [
                main_1.model["asset-url"] + '/sound/' + soundTheme + '/' + soundTrack + '.ogg',
                main_1.model["asset-url"] + '/sound/' + soundTheme + '/' + soundTrack + '.mp3'
            ],
            onplayerror: function () {
                sound.once('unlock', function () {
                    sound.play();
                });
            },
            volume: exports.volumeSettings.value,
        });
        return sound;
    }
    audio() {
        return exports.soundThemeSettings.value !== 'silent';
    }
    genericNotify() { if (this.audio())
        this.tracks.GenericNotify.play(); }
    socialNotify() { if (this.audio())
        this.tracks.SocialNotify.play(); }
    move() { if (this.audio())
        this.tracks.Move.play(); }
    capture() { if (this.audio())
        this.tracks.Capture.play(); }
    check() { if (this.audio())
        this.tracks.Check.play(); }
    draw() { if (this.audio())
        this.tracks.Draw.play(); }
    victory() { if (this.audio())
        this.tracks.Victory.play(); }
    defeat() { if (this.audio())
        this.tracks.Defeat.play(); }
    shogimove() { if (this.audio())
        this.tracks.ShogiMove.play(); }
    shogicapture() { if (this.audio())
        this.tracks.ShogiCapture.play(); }
    chat() { if (this.audio())
        this.tracks.Chat.play(); }
    setup() { if (this.audio())
        this.tracks.Setup.play(); }
    lowTime() { if (this.audio())
        this.tracks.LowTime.play(); }
    tick() { if (this.audio())
        this.tracks.Tick.play(); }
    explosion() { if (this.audio())
        this.tracks.Explosion.play(); }
    moveSound(variant, capture) {
        const soundSet = this.moveSoundSet[variant.pieceSound];
        if (capture)
            soundSet.capture();
        else
            soundSet.move();
    }
    gameEndSound(result, color) {
        switch (result) {
            case "1/2-1/2":
                this.draw();
                break;
            case "1-0":
                if (color === "white")
                    this.victory();
                else
                    this.defeat();
                break;
            case "0-1":
                if (color === "black")
                    this.victory();
                else
                    this.defeat();
                break;
        }
    }
}
Sounds.trackNames = {
    GenericNotify: 'GenericNotify',
    SocialNotify: 'SocialNotify',
    Move: 'Move',
    Capture: 'Capture',
    Check: 'Check',
    Draw: 'Draw',
    Victory: 'Victory',
    Defeat: 'Defeat',
    ShogiMove: 'shogisnap',
    ShogiCapture: 'shogislam',
    Chat: 'chat',
    Setup: 'dinding',
    LowTime: 'LowTime',
    Tick: 'Tick',
    Explosion: 'Explosion',
};
class VolumeSettings extends settings_1.NumberSettings {
    constructor() {
        super('volume', 1);
    }
    update() {
        exports.sound.updateVolume();
    }
    view() {
        return (0, view_1.slider)(this, 'sound-volume', 0, 1, 0.01);
    }
}
const soundThemes = {
    silent: "Silent",
    standard: "Standard",
    robot: "Robot",
};
class SoundThemeSettings extends settings_1.StringSettings {
    constructor() {
        super('soundtheme', 'standard');
    }
    update() {
        exports.sound.updateSoundTheme();
    }
    view() {
        return (0, h_1.h)('div#soundtheme.radio-list', (0, view_1.radioList)(this, 'soundtheme', soundThemes, (_, key) => this.value = key));
    }
}
exports.sound = new (Sounds);
exports.volumeSettings = new VolumeSettings();
exports.soundThemeSettings = new SoundThemeSettings();

},{"./main":31,"./settings":43,"./view":49,"howler":73,"snabbdom/h":85}],46:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.statsView = void 0;
const highcharts_1 = __importDefault(require("highcharts"));
const h_1 = __importDefault(require("snabbdom/h"));
function createPeriods() {
    const periodList = [];
    const date = new Date(2019, 5, 1, 0, 0, 0); // (2019-06-01) the month is 0-indexed
    const endDate = new Date();
    const months = ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    while (date <= endDate) {
        const year = date.getFullYear().toString();
        const month = months[date.getMonth()];
        periodList.push(year + '-' + month);
        date.setMonth(date.getMonth() + 1);
    }
    return periodList;
}
function buildChart() {
    const xmlhttp = new XMLHttpRequest();
    const url = "/api/stats";
    xmlhttp.onreadystatechange = function () {
        if (this.readyState == 4 && this.status == 200) {
            const response = JSON.parse(this.responseText);
            if (!response.length) {
                return;
            }
            highcharts_1.default.chart('stats-chart', {
                chart: { type: 'line' },
                credits: { enabled: false },
                title: { text: undefined },
                legend: {
                    layout: 'vertical',
                    align: 'right',
                    verticalAlign: 'top',
                },
                xAxis: {
                    categories: createPeriods(),
                },
                yAxis: {
                    type: 'logarithmic',
                },
                responsive: {
                    rules: [{
                            condition: {
                                maxWidth: 1200
                            },
                            chartOptions: {
                                legend: {
                                    align: 'center',
                                    verticalAlign: 'bottom',
                                    layout: 'horizontal'
                                }
                            }
                        }]
                },
                series: response
            });
        }
    };
    xmlhttp.open("GET", url, true);
    xmlhttp.send();
}
function statsView() {
    return [(0, h_1.default)('div#stats-chart', { hook: { insert: () => buildChart() } })];
}
exports.statsView = statsView;

},{"highcharts":72,"snabbdom/h":85}],47:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tournamentView = void 0;
const sockette_1 = __importDefault(require("sockette"));
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const style_1 = __importDefault(require("snabbdom/modules/style"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default, style_1.default]);
const h_1 = __importDefault(require("snabbdom/h"));
const chessgroundx_1 = require("chessgroundx");
const i18n_1 = require("./i18n");
const chat_1 = require("./chat");
//import { sound } from './sound';
const chess_1 = require("./chess");
const view_1 = require("./view");
const datetime_1 = require("./datetime");
const profile_1 = require("./profile");
const boardSettings_1 = require("./boardSettings");
const T_STATUS = {
    0: "created",
    1: "started",
    2: "aborted",
    3: "finished",
    4: "archived",
};
const scoreTagNames = ['score', 'streak', 'double'];
const SCORE_SHIFT = 100000;
const SHIELD = 's';
class TournamentController {
    constructor(el, model) {
        this.onMsgSpectators = (msg) => {
            const container = document.getElementById('spectators');
            patch(container, (0, h_1.default)('under-chat#spectators', (0, i18n_1._)('Spectators: ') + msg.spectators));
        };
        this.onMsgBoard = (msg) => {
            if (this.topGameChessground === undefined || this.topGameId !== msg.gameId) {
                return;
            }
            ;
            let lastMove = msg.lastMove;
            if (lastMove !== null) {
                lastMove = (0, chess_1.uci2cg)(lastMove);
                // drop lastMove causing scrollbar flicker,
                // so we remove from part to avoid that
                lastMove = lastMove.includes('@') ? [lastMove.slice(-2)] : [lastMove.slice(0, 2), lastMove.slice(2, 4)];
            }
            this.topGameChessground.set({
                fen: msg.fen,
                turnColor: msg.fen.split(" ")[1] === "b" ? "white" : "black",
                check: msg.check,
                lastMove: lastMove,
            });
        };
        this.checkStatus = (msg) => {
            if (this.topGameChessground === undefined || this.topGameId !== msg.gameId) {
                return;
            }
            console.log(msg);
            if (msg.status >= 0) {
                const result = msg.result.split('-');
                patch(document.getElementById('wresult'), (0, h_1.default)('div#wresult', result[0]));
                patch(document.getElementById('bresult'), (0, h_1.default)('div#bresult', result[1]));
            }
        };
        console.log("TournamentController constructor", el, model);
        this.model = model;
        this.nbPlayers = 0;
        this.page = 1;
        this.tournamentStatus = T_STATUS[model["status"]];
        this.visitedPlayer = '';
        this.startsAt = model["date"];
        this.secondsToStart = 0;
        this.secondsToFinish = 0;
        const onOpen = (evt) => {
            this._ws = evt.target;
            console.log('onOpen()');
            this.doSend({ type: "tournament_user_connected", username: this.model["username"], tournamentId: this.model["tournamentId"] });
            this.doSend({ type: "get_players", "tournamentId": this.model["tournamentId"], page: this.page });
        };
        this._ws = { "readyState": -1 };
        const opts = {
            maxAttempts: 20,
            onopen: e => onOpen(e),
            onmessage: e => this.onMessage(e),
            onreconnect: e => console.log('Reconnecting in tournament...', e),
            onmaximum: e => console.log('Stop Attempting!', e),
            onclose: e => { console.log('Closed!', e); },
            onerror: e => console.log('Error:', e),
        };
        const ws = location.host.includes('pychess') ? 'wss://' : 'ws://';
        this.sock = new sockette_1.default(ws + location.host + "/wst", opts);
        const variant = chess_1.VARIANTS[this.model.variant];
        this.fc = variant.firstColor;
        this.sc = variant.secondColor;
        patch(document.getElementById('lobbychat'), (0, chat_1.chatView)(this, "lobbychat"));
        this.buttons = patch(document.getElementById('page-controls'), this.renderButtons());
        this.clockdiv = patch(document.getElementById('clockdiv'), (0, h_1.default)('div#clockdiv'));
        this.playerGamesOn = false;
        boardSettings_1.boardSettings.updateBoardAndPieceStyles();
    }
    doSend(message) {
        // console.log("---> tournament doSend():", message);
        this.sock.send(JSON.stringify(message));
    }
    goToPage(page) {
        let newPage = page;
        if (page < 1) {
            newPage = 1;
        }
        else {
            const x = Math.floor(this.nbPlayers / 10);
            const y = this.nbPlayers % 10;
            const lastPage = x + ((y > 0) ? 1 : 0);
            newPage = (page > lastPage) ? lastPage : page;
        }
        if (newPage !== this.page) {
            this.page = newPage;
            this.doSend({ type: "get_players", "tournamentId": this.model["tournamentId"], "page": newPage });
        }
    }
    goToMyPage() {
        this.doSend({ type: "my_page", "tournamentId": this.model["tournamentId"] });
    }
    login() {
        window.location.assign(this.model["home"] + '/login');
    }
    join() {
        this.doSend({ type: "join", "tournamentId": this.model["tournamentId"] });
    }
    pause() {
        this.doSend({ type: "pause", "tournamentId": this.model["tournamentId"] });
    }
    withdraw() {
        this.doSend({ type: "withdraw", "tournamentId": this.model["tournamentId"] });
    }
    renderButtons() {
        return (0, h_1.default)('div#page-controls.btn-controls', [
            (0, h_1.default)('div.pager', [
                (0, h_1.default)('button', { on: { click: () => this.goToPage(1) } }, [(0, h_1.default)('i.icon.icon-fast-backward', { props: { title: (0, i18n_1._)('First') } })]),
                (0, h_1.default)('button', { on: { click: () => this.goToPage(this.page - 1) } }, [(0, h_1.default)('i.icon.icon-step-backward', { props: { title: (0, i18n_1._)('Prev') } })]),
                // TODO: update
                (0, h_1.default)('span.page', `${(this.page - 1) * 10 + 1} - ${Math.min((this.page) * 10, this.nbPlayers)} / ${this.nbPlayers}`),
                (0, h_1.default)('button', { on: { click: () => this.goToPage(this.page + 1) } }, [(0, h_1.default)('i.icon.icon-step-forward', { props: { title: (0, i18n_1._)('Next') } })]),
                (0, h_1.default)('button', { on: { click: () => this.goToPage(10000) } }, [(0, h_1.default)('i.icon.icon-fast-forward', { props: { title: (0, i18n_1._)('Last') } })]),
                (0, h_1.default)('button', { on: { click: () => this.goToMyPage() } }, [(0, h_1.default)('i.icon.icon-target', { props: { title: (0, i18n_1._)('Scroll to your player') } })]),
            ]),
            (0, h_1.default)('div#action'),
        ]);
    }
    updateActionButton() {
        let button = (0, h_1.default)('div#action');
        switch (this.tournamentStatus) {
            case 'created':
                if (this.userStatus === 'joined') {
                    button = (0, h_1.default)('button#action', { on: { click: () => this.withdraw() }, class: { "icon": true, "icon-flag-o": true } }, (0, i18n_1._)('WITHDRAW'));
                }
                else {
                    button = (0, h_1.default)('button#action', { on: { click: () => this.join() }, class: { "icon": true, "icon-play": true } }, (0, i18n_1._)('JOIN'));
                }
                break;
            case 'started':
                if ('spectator|paused'.includes(this.userStatus)) {
                    button = (0, h_1.default)('button#action', { on: { click: () => this.join() }, class: { "icon": true, "icon-play": true } }, (0, i18n_1._)('JOIN'));
                }
                else {
                    button = (0, h_1.default)('button#action', { on: { click: () => this.pause() }, class: { "icon": true, "icon-pause": true } }, (0, i18n_1._)('PAUSE'));
                }
                break;
        }
        if (this.model["anon"] === 'True' && 'created|started'.includes(this.tournamentStatus)) {
            button = (0, h_1.default)('button#action', { on: { click: () => this.login() }, class: { "icon": true, "icon-play": true } }, (0, i18n_1._)('LOG IN'));
        }
        // console.log("updateActionButton()", this.tournamentStatus, button);
        this.action = patch(document.getElementById('action'), button);
    }
    completed() {
        return 'aborted|finished|archived'.includes(this.tournamentStatus);
    }
    renderSummary(msg) {
        const summary = (0, h_1.default)('div#summary', { class: { "box": true } }, [
            (0, h_1.default)('h2', (0, i18n_1._)('Tournament complete')),
            (0, h_1.default)('table', [
                (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Players')), (0, h_1.default)('td', msg.nbPlayers)]),
                (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Average rating')), (0, h_1.default)('td', Math.round(msg.sumRating / msg.nbPlayers))]),
                (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Games played')), (0, h_1.default)('td', msg.nbGames)]),
                (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('White wins')), (0, h_1.default)('td', this.winRate(msg.nbGames, msg.wWin))]),
                (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Black wins')), (0, h_1.default)('td', this.winRate(msg.nbGames, msg.bWin))]),
                (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Draws')), (0, h_1.default)('td', this.winRate(msg.nbGames, msg.draw))]),
                //h('tr', [h('div', _('Berserk rate')), h('td', 0)]),
            ]),
            (0, h_1.default)('table.tour-stats-links', [
                (0, h_1.default)('a.i-dl.icon.icon-download', {
                    attrs: {
                        href: '/games/export/tournament/' + this.model["tournamentId"],
                        download: this.model["tournamentId"] + '.pgn',
                    },
                }, (0, i18n_1._)('Download all games')),
            ]),
        ]);
        const el = document.getElementById('summarybox');
        if (el)
            patch(el, summary);
    }
    renderPlayers(players) {
        const rows = players.map((player, index) => this.playerView(player, (this.page - 1) * 10 + index + 1));
        return rows;
    }
    playerView(player, index) {
        if (player.name === this.visitedPlayer) {
            this.doSend({ type: "get_games", tournamentId: this.model["tournamentId"], player: this.visitedPlayer });
        }
        let fullScore = Math.trunc(player.score / SCORE_SHIFT);
        if (this.system > 0 && this.model["variant"] !== 'janggi')
            fullScore = fullScore / 2;
        return (0, h_1.default)('tr', { on: { click: () => this.onClickPlayer(player.name) } }, [
            (0, h_1.default)('td.rank', [(player.paused) ? (0, h_1.default)('i', { class: { "icon": true, "icon-pause": true } }) : index]),
            (0, h_1.default)('td.player', [
                (0, h_1.default)('span.title', player.title),
                (0, h_1.default)('span.name', player.name),
                (0, h_1.default)('span', player.rating),
            ]),
            (0, h_1.default)('td.sheet', [(0, h_1.default)('div', player.points.map(s => {
                    let score = Array.isArray(s) ? s[0] : s;
                    if (this.system > 0 && score !== '*' && score !== '-' && this.model["variant"] !== 'janggi')
                        score = score / 2;
                    const pointKlass = this.system > 0 ? '.point' : '';
                    const resultKlass = ((this.system > 0) ? (score >= 1) ? '.win' : (score === 0.5) ? '.draw' : '.lose' : '');
                    if (score === 0.5)
                        score = '½';
                    return (0, h_1.default)(scoreTagNames[(s[1] || 1) - 1] + pointKlass + resultKlass, [score]);
                }))]),
            (0, h_1.default)('td.total', [
                (0, h_1.default)('fire', [(player.fire === 2 && this.tournamentStatus === 'started') ? (0, h_1.default)('i', { class: { "icon": true, "icon-fire": true } }) : '']),
                (0, h_1.default)('strong.score', fullScore),
                // h('span.perf', player.perf)
            ]),
        ]);
    }
    onClickPlayer(player) {
        console.log('onClickPlayer()', player);
        if (this.tournamentStatus === 'created')
            return;
        if (this.completed()) {
            if (this.playerGamesOn && this.visitedPlayer === player) {
                document.getElementById('summary').style.display = 'block';
                document.getElementById('player').style.display = 'none';
                this.playerGamesOn = false;
            }
            else {
                this.doSend({ type: "get_games", tournamentId: this.model["tournamentId"], player: player });
                document.getElementById('summary').style.display = 'none';
                document.getElementById('player').style.display = 'block';
                this.playerGamesOn = true;
                this.visitedPlayer = player;
            }
            // started
        }
        else {
            this.doSend({ type: "get_games", tournamentId: this.model["tournamentId"], player: player });
            if (this.playerGamesOn && this.visitedPlayer === player) {
                this.renderTopGame();
                document.getElementById('player').style.display = 'none';
                this.playerGamesOn = false;
            }
            else {
                this.renderEmptyTopGame();
                document.getElementById('player').style.display = 'block';
                this.playerGamesOn = true;
            }
            this.visitedPlayer = player;
        }
    }
    renderGames(games) {
        const rows = games.reverse().map((game, index) => this.gameView(game, games.length - index));
        return rows;
    }
    result(result, color) {
        let value = '*';
        switch (result) {
            case '1-0':
                value = (color === 'w') ? '1' : '0';
                break;
            case '0-1':
                value = (color === 'b') ? '1' : '0';
                break;
            case '1/2-1/2':
                value = '½';
                break;
            case '-':
                value = '-';
                break;
        }
        const klass = (value === '1') ? '.win' : (value === '0') ? '.lose' : '';
        return (0, h_1.default)(`td.result${klass}`, value);
    }
    gameView(game, index) {
        if (game.result === '-') {
            return (0, h_1.default)('tr', [
                (0, h_1.default)('th', index),
                (0, h_1.default)('td.bye', { attrs: { colspan: '3' } }, 'Bye'),
                (0, h_1.default)('td.result', '-')
            ]);
        }
        else {
            const color = (game.color === 'w') ? this.fc : this.sc;
            return (0, h_1.default)('tr', { on: { click: () => { window.open('/' + game.gameId, '_blank', 'noopener'); } } }, [
                (0, h_1.default)('th', index),
                (0, h_1.default)('td.player', [
                    (0, h_1.default)('span.title', game.title),
                    (0, h_1.default)('span.name', game.name),
                ]),
                (0, h_1.default)('td', game.rating),
                (0, h_1.default)('td', [
                    (0, h_1.default)('i-side.icon', {
                        class: {
                            "icon-white": color === "White",
                            "icon-black": color === "Black",
                            "icon-red": color === "Red",
                            "icon-blue": color === "Blue",
                            "icon-gold": color === "Gold",
                            "icon-pink": color === "Pink",
                        }
                    }),
                ]),
                this.result(game.result, game.color),
            ]);
        }
    }
    tSystem(system) {
        switch (parseInt(system)) {
            case 0:
                return "Arena";
            case 1:
                return "Round-Robin";
            default:
                return "Swiss";
        }
    }
    renderStats(msg) {
        const games = msg.games.filter(game => game.result !== '-');
        const gamesLen = games.length;
        const avgOp = gamesLen
            ? Math.round(games.reduce(function (a, b) {
                return a + b.rating;
            }, 0) / gamesLen)
            : 0;
        return [
            (0, h_1.default)('span.close', {
                on: { click: () => this.onClickPlayer(this.visitedPlayer) },
                attrs: { 'data-icon': 'j' }
            }),
            (0, h_1.default)('h2', [
                (0, h_1.default)('rank', msg.rank + '. '),
                playerInfo(msg.name, msg.title),
            ]),
            (0, h_1.default)('table.stats', [
                (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Performance')), (0, h_1.default)('td', msg.perf)]),
                (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Games played')), (0, h_1.default)('td', gamesLen)]),
                (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Win rate')), (0, h_1.default)('td', this.winRate(msg.nbGames, msg.nbWin))]),
                (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Average opponent')), (0, h_1.default)('td', avgOp)]),
            ]),
        ];
    }
    renderEmptyTopGame() {
        patch(document.getElementById('top-game'), (0, h_1.default)('div#top-game.empty'));
    }
    renderTopGame() {
        if (this.topGame === undefined)
            return;
        const game = this.topGame;
        const variant = chess_1.VARIANTS[game.variant];
        const element = (0, h_1.default)(`selection#mainboard.${variant.board}.${variant.piece}`, {
            on: { click: () => window.location.assign('/' + game.gameId) }
        }, (0, h_1.default)('div', [
            (0, h_1.default)('div.player', [(0, h_1.default)('user', [(0, h_1.default)('rank', '#' + game.br), game.b]), (0, h_1.default)('div#bresult')]),
            (0, h_1.default)(`div.cg-wrap.${variant.cg}`, {
                hook: {
                    insert: vnode => {
                        const cg = (0, chessgroundx_1.Chessground)(vnode.elm, {
                            fen: game.fen,
                            lastMove: game.lastMove,
                            geometry: variant.geometry,
                            coordinates: false,
                            viewOnly: true
                        });
                        this.topGameChessground = cg;
                        this.topGameId = game.gameId;
                    }
                }
            }),
            (0, h_1.default)('div.player', [(0, h_1.default)('user', [(0, h_1.default)('rank', '#' + game.wr), game.w]), (0, h_1.default)('div#wresult')]),
        ]));
        patch(document.getElementById('top-game'), (0, h_1.default)('div#top-game', element));
    }
    winRate(nbGames, nbWin) {
        return ((nbGames !== 0) ? Math.round(100 * (nbWin / nbGames)) : 0) + '%';
    }
    renderPodium(players) {
        return (0, h_1.default)('div.podium', [
            (0, h_1.default)('div.second', [
                (0, h_1.default)('div.trophy'),
                playerInfo(players[1].name, players[1].title),
                (0, h_1.default)('table.stats', [
                    (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Performance')), (0, h_1.default)('td', players[1].perf)]),
                    (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Games played')), (0, h_1.default)('td', players[1].nbGames)]),
                    (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Win rate')), (0, h_1.default)('td', this.winRate(players[1].nbGames, players[1].nbWin))]),
                    //h('tr', [h('th', _('Berserk rate')), h('td', players[1].???)])
                ])
            ]),
            (0, h_1.default)('div.first', [
                (0, h_1.default)('div.trophy'),
                playerInfo(players[0].name, players[0].title),
                (0, h_1.default)('table.stats', [
                    (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Performance')), (0, h_1.default)('td', players[0].perf)]),
                    (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Games played')), (0, h_1.default)('td', players[0].nbGames)]),
                    (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Win rate')), (0, h_1.default)('td', this.winRate(players[0].nbGames, players[0].nbWin))]),
                    //h('tr', [h('th', _('Berserk rate')), h('td', players[0].???)])
                ])
            ]),
            (0, h_1.default)('div.third', [
                (0, h_1.default)('div.trophy'),
                playerInfo(players[2].name, players[2].title),
                (0, h_1.default)('table.stats', [
                    (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Performance')), (0, h_1.default)('td', players[2].perf)]),
                    (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Games played')), (0, h_1.default)('td', players[2].nbGames)]),
                    (0, h_1.default)('tr', [(0, h_1.default)('th', (0, i18n_1._)('Win rate')), (0, h_1.default)('td', this.winRate(players[2].nbGames, players[2].nbWin))]),
                    //h('tr', [h('th', _('Berserk rate')), h('td', players[2].???)])
                ])
            ])
        ]);
    }
    onMsgGetGames(msg) {
        const oldStats = document.getElementById('stats');
        oldStats.innerHTML = "";
        patch(oldStats, (0, h_1.default)('div#stats.box', [(0, h_1.default)('tbody', this.renderStats(msg))]));
        const oldGames = document.getElementById('games');
        oldGames.innerHTML = "";
        patch(oldGames, (0, h_1.default)('table#games.pairings.box', [(0, h_1.default)('tbody', this.renderGames(msg.games))]));
    }
    onMsgGetPlayers(msg) {
        if (this.completed() && msg.players.length >= 3 && msg.nbGames > 0) {
            const podium = document.getElementById('podium');
            if (podium instanceof Element) {
                patch(podium, this.renderPodium(msg.players));
            }
        }
        if (this.page = msg.page || msg.requestedBy === this.model["username"]) {
            this.players = msg.players;
            this.page = msg.page;
            this.nbPlayers = msg.nbPlayers;
            this.buttons = patch(this.buttons, this.renderButtons());
            const oldPlayers = document.getElementById('players');
            oldPlayers.innerHTML = "";
            patch(oldPlayers, (0, h_1.default)('table#players.players.box', [(0, h_1.default)('tbody', this.renderPlayers(msg.players))]));
        }
    }
    onMsgNewGame(msg) {
        window.location.assign('/' + msg.gameId);
    }
    onMsgGameUpdate() {
        this.doSend({ type: "get_players", tournamentId: this.model["tournamentId"], page: this.page });
    }
    durationString(minutes) {
        if (minutes == 0)
            return '';
        if (minutes < 60) {
            return " • " + minutes + 'm';
        }
        else {
            return " • " + Math.floor(minutes / 60) + 'h' + ((minutes % 60 != 0) ? ' ' + (minutes % 60) + 'm' : '');
        }
    }
    renderDescription(text) {
        const parts = text.split(/(\[.*?\))/g);
        if (parts != null && parts.length > 0) {
            const newArr = parts.map(el => {
                const txtPart = el.match(/\[(.+)\]/); //get only the txt
                const urlPart = el.match(/\((.+)\)/); //get only the link
                if (txtPart && urlPart) {
                    return (0, h_1.default)('a', { attrs: { href: urlPart[1], target: "_blank" } }, txtPart[1]);
                }
                else {
                    return el;
                }
            });
            return (0, h_1.default)('div.description', newArr);
        }
        return (0, h_1.default)('div.description', text);
    }
    onMsgUserConnected(msg) {
        const variant = chess_1.VARIANTS[this.model.variant];
        const chess960 = this.model.chess960 === 'True';
        const dataIcon = variant.icon(chess960);
        const trophy = document.getElementById('trophy');
        if (trophy && msg.frequency === SHIELD)
            patch(trophy, (0, h_1.default)('a', { class: { "shield-trophy": true } }, dataIcon));
        this.system = msg.tsystem;
        const tsystem = document.getElementById('tsystem');
        patch(tsystem, (0, h_1.default)('div#tsystem', (0, profile_1.gameType)(this.model["rated"]) + " • " + this.tSystem(this.system)));
        const tminutes = document.getElementById('tminutes');
        patch(tminutes, (0, h_1.default)('span#tminutes', this.durationString(msg.tminutes)));
        const startsAtDate = new Date(msg.startsAt);
        const startsAt = document.getElementById('startsAt');
        if (startsAt)
            patch(startsAt, (0, h_1.default)('date', startsAtDate.toLocaleString("default", datetime_1.localeOptions)));
        if (msg.startFen !== '') {
            const startFen = document.getElementById('startFen');
            const fen = msg.startFen.split(" ").join('_').replace(/\+/g, '.');
            patch(startFen, (0, h_1.default)('p', [
                (0, i18n_1._)('Custom position') + ' • ',
                (0, h_1.default)('a', { attrs: { href: '/analysis/' + this.model["variant"] + '?fen=' + fen } }, (0, i18n_1._)('Analysis board'))
            ]));
        }
        const description = document.getElementById('description');
        if (msg.description.length > 0 && description)
            patch(description, this.renderDescription(msg.description));
        this.model.username = msg.username;
        this.tournamentStatus = T_STATUS[msg.tstatus];
        this.userStatus = msg.ustatus;
        this.userRating = msg.urating;
        this.secondsToStart = msg.secondsToStart;
        this.secondsToFinish = msg.secondsToFinish;
        this.updateActionButton();
        if (!this.completed()) {
            (0, datetime_1.initializeClock)(this);
        }
    }
    onMsgUserStatus(msg) {
        this.userStatus = msg.ustatus;
        this.updateActionButton();
    }
    onMsgTournamentStatus(msg) {
        const oldStatus = this.tournamentStatus;
        this.tournamentStatus = T_STATUS[msg.tstatus];
        if (oldStatus !== this.tournamentStatus) {
            if (msg.secondsToFinish !== undefined) {
                this.secondsToFinish = msg.secondsToFinish;
            }
            // TODO: in Swiss/RR clock is meaningless, we need the number of ongoing games shown and updating
            (0, datetime_1.initializeClock)(this);
        }
        this.updateActionButton();
        if (this.completed()) {
            patch(this.clockdiv, (0, h_1.default)('div#clockdiv'));
            this.renderEmptyTopGame();
            document.getElementById('player').style.display = 'none';
            this.renderSummary(msg);
            this.doSend({ type: "get_players", "tournamentId": this.model["tournamentId"], page: this.page });
        }
    }
    onMsgTopGame(msg) {
        this.topGame = msg;
        if (this.tournamentStatus === 'started' && !this.playerGamesOn) {
            this.renderEmptyTopGame();
            this.renderTopGame();
        }
    }
    onMsgChat(msg) {
        (0, chat_1.chatMessage)(msg.user, msg.message, "lobbychat");
        // seems this is annoying for most of the users
        //if (msg.user.length !== 0 && msg.user !== '_server')
        //    sound.socialNotify();
    }
    onMsgFullChat(msg) {
        // To prevent multiplication of messages we have to remove old messages div first
        patch(document.getElementById('messages'), (0, h_1.default)('div#messages-clear'));
        // then create a new one
        patch(document.getElementById('messages-clear'), (0, h_1.default)('div#messages'));
        msg.lines.forEach(line => (0, chat_1.chatMessage)(line.user, line.message, "lobbychat"));
    }
    onMsgPing(msg) {
        this.doSend({ type: "pong", timestamp: msg.timestamp });
    }
    onMsgError(msg) {
        alert(msg.message);
    }
    onMessage(evt) {
        //console.log("<+++ tournament onMessage():", evt.data);
        const msg = JSON.parse(evt.data);
        switch (msg.type) {
            case "ustatus":
                this.onMsgUserStatus(msg);
                break;
            case "tstatus":
                this.onMsgTournamentStatus(msg);
                break;
            case "get_players":
                this.onMsgGetPlayers(msg);
                break;
            case "new_game":
                this.onMsgNewGame(msg);
                break;
            case "game_update":
                this.onMsgGameUpdate();
                break;
            case "get_games":
                this.onMsgGetGames(msg);
                break;
            case "board":
                this.onMsgBoard(msg);
                break;
            case "gameEnd":
                this.checkStatus(msg);
                break;
            case "tournament_user_connected":
                this.onMsgUserConnected(msg);
                break;
            case "spectators":
                this.onMsgSpectators(msg);
                break;
            case "top_game":
                this.onMsgTopGame(msg);
                break;
            case "lobbychat":
                this.onMsgChat(msg);
                break;
            case "fullchat":
                this.onMsgFullChat(msg);
                break;
            case "ping":
                this.onMsgPing(msg);
                break;
            case "error":
                this.onMsgError(msg);
                break;
        }
    }
}
exports.default = TournamentController;
function runTournament(vnode, model) {
    const el = vnode.elm;
    new TournamentController(el, model);
}
function tournamentView(model) {
    const variant = chess_1.VARIANTS[model.variant];
    const chess960 = model.chess960 === 'True';
    const dataIcon = variant.icon(chess960);
    return [
        (0, h_1.default)('aside.sidebar-first', [
            (0, h_1.default)('div.game-info', [
                (0, h_1.default)('div.info0.icon', { attrs: { "data-icon": dataIcon } }, [
                    (0, h_1.default)('div.info2', [
                        (0, h_1.default)('div.tc', [
                            (0, view_1.timeControlStr)(model["base"], model["inc"], model["byo"]) + " • ",
                            (0, h_1.default)('a', {
                                attrs: {
                                    target: '_blank',
                                    href: '/variants/' + model["variant"] + (chess960 ? '960' : ''),
                                }
                            }, variant.displayName(chess960)),
                            (0, h_1.default)('span#tminutes'),
                        ]),
                        (0, h_1.default)('div#tsystem'),
                    ]),
                ]),
                // TODO: update in onMsgUserConnected()
                (0, h_1.default)('div#description'),
                (0, h_1.default)('div#requirements'),
                (0, h_1.default)('div#startsAt'),
                (0, h_1.default)('div#startFen'),
            ]),
            (0, h_1.default)('div#lobbychat')
        ]),
        (0, h_1.default)('div.players', [
            (0, h_1.default)('div.box', [
                (0, h_1.default)('div.tour-header', [
                    (0, h_1.default)('div#trophy'),
                    (0, h_1.default)('h1', model["tournamentname"]),
                    (0, h_1.default)('div#clockdiv'),
                ]),
                (0, h_1.default)('div#podium'),
                (0, h_1.default)('div#page-controls'),
                (0, h_1.default)('table#players', { hook: { insert: vnode => runTournament(vnode, model) } }),
            ]),
        ]),
        (0, h_1.default)('div.tour-table', [
            (0, h_1.default)('div#summarybox'),
            (0, h_1.default)('div#top-game'),
            (0, h_1.default)('div#player', [
                (0, h_1.default)('div#stats.box'),
                (0, h_1.default)('table#games.box'),
            ]),
        ]),
        (0, h_1.default)('under-chat#spectators'),
    ];
}
exports.tournamentView = tournamentView;
function playerInfo(name, title) {
    return (0, h_1.default)('a.user-link', { attrs: { href: '/@/' + name } }, [(0, h_1.default)('player-title', " " + title + " "), name]);
}

},{"./boardSettings":5,"./chat":7,"./chess":8,"./datetime":12,"./i18n":18,"./profile":39,"./view":49,"chessgroundx":55,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91,"snabbdom/modules/style":92,"sockette":97}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.variantsIni = void 0;
exports.variantsIni = `
# Hybrid variant of Grand-chess and crazyhouse, using Grand-chess as a template
[grandhouse:grand]
startFen = r8r/1nbqkcabn1/pppppppppp/10/10/10/10/PPPPPPPPPP/1NBQKCABN1/R8R[] w - - 0 1
pieceDrops = true
capturesToHand = true

# Hybrid variant of Gothic-chess and crazyhouse, using Capablanca as a template
[gothhouse:capablanca]
startFen = rnbqckabnr/pppppppppp/10/10/10/10/PPPPPPPPPP/RNBQCKABNR[] w KQkq - 0 1
pieceDrops = true
capturesToHand = true

[shogun:crazyhouse]
startFen = rnb+fkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNB+FKBNR[] w KQkq - 0 1
commoner = c
centaur = g
archbishop = a
chancellor = m
fers = f
promotionRank = 6
promotionLimit = g:1 a:1 m:1 q:1
promotionPieceTypes = -
promotedPieceType = p:c n:g b:a r:m f:q
mandatoryPawnPromotion = false
firstRankPawnDrops = true
promotionZonePawnDrops = true
whiteDropRegion = *1 *2 *3 *4 *5
blackDropRegion = *4 *5 *6 *7 *8
immobilityIllegal = true

[orda:chess]
centaur = h
knibis = a
kniroo = l
silver = y
promotionPieceTypes = qh
startFen = lhaykahl/8/pppppppp/8/8/8/PPPPPPPP/RNBQKBNR w KQ - 0 1
flagPiece = k
whiteFlag = *8
blackFlag = *1

[synochess:pocketknight]
janggiCannon = c
soldier = s
horse = h
fersAlfil = e
commoner = a
startFen = rneakenr/8/1c4c1/1ss2ss1/8/8/PPPPPPPP/RNBQKBNR[ss] w KQ - 0 1
stalemateValue = loss
perpetualCheckIllegal = true
flyingGeneral = true
blackDropRegion = *5
flagPiece = k
whiteFlag = *8
blackFlag = *1

[shinobi:crazyhouse]
commoner = c
bers = d
archbishop = j
fers = m
shogiKnight = h
lance = l
promotionRank = 7
promotionPieceTypes = -
promotedPieceType = p:c m:b h:n l:r
mandatoryPiecePromotion = true
stalemateValue = loss
perpetualCheckIllegal = true
startFen = rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/LH1CK1HL[LHMMDJ] w kq - 0 1
capturesToHand = false
whiteDropRegion = *1 *2 *3 *4
immobilityIllegal = true
flagPiece = k
whiteFlag = *8
blackFlag = *1

[ordamirror:chess]
centaur = h
knibis = a
kniroo = l
customPiece1 = f:mQcN
promotionPieceTypes = lhaf
startFen = lhafkahl/8/pppppppp/8/8/PPPPPPPP/8/LHAFKAHL w - - 0 1
flagPiece = k
whiteFlag = *8
blackFlag = *1

[empire:chess]
customPiece1 = e:mQcN
customPiece2 = c:mQcB
customPiece3 = t:mQcR
customPiece4 = d:mQcK
soldier = s
promotionPieceTypes = q
startFen = rnbqkbnr/pppppppp/8/8/8/PPPSSPPP/8/TECDKCET w kq - 0 1
stalemateValue = loss
nFoldValue = loss
flagPiece = k
whiteFlag = *8
blackFlag = *1
flyingGeneral = true
`;

},{}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeControlStr = exports.checkbox = exports.slider = exports.radioList = void 0;
const h_1 = require("snabbdom/h");
function radioList(settings, name, options, onchange) {
    const result = [];
    Object.keys(options).forEach(key => {
        const id = name + "-" + key;
        result.push((0, h_1.h)(`input#${id}`, {
            props: { name: name, type: "radio", value: key },
            attrs: { checked: settings.value === key },
            on: { change: evt => onchange(evt, key) },
        }));
        result.push((0, h_1.h)('label', { attrs: { for: id } }, options[key]));
    });
    return result;
}
exports.radioList = radioList;
function slider(settings, name, min = 0, max = 100, step = 1) {
    const id = name;
    return (0, h_1.h)(`input#${id}.slider`, {
        props: { name: name, type: "range", min: min, max: max, step: step, value: settings.value },
        on: { input: e => settings.value = Number(e.target.value) },
    });
}
exports.slider = slider;
function checkbox(settings, name, text) {
    const id = name;
    return [
        (0, h_1.h)(`input#${id}`, {
            props: { name: name, type: "checkbox" },
            attrs: { checked: settings.value },
            on: { change: evt => settings.value = evt.target.checked },
        }),
        (0, h_1.h)('label', { attrs: { for: id } }, text),
    ];
}
exports.checkbox = checkbox;
function timeControlStr(minutes, increment = 0, byoyomiPeriod = 0) {
    minutes = Number(minutes);
    byoyomiPeriod = Number(byoyomiPeriod);
    switch (minutes) {
        case 1 / 4:
            minutes = "¼";
            break;
        case 1 / 2:
            minutes = "½";
            break;
        case 3 / 4:
            minutes = "¾";
            break;
        default:
            minutes = String(minutes);
    }
    switch (byoyomiPeriod) {
        case 0: return `${minutes}+${increment}`;
        case 1: return `${minutes}+${increment}(b)`;
        default: return `${minutes}+${byoyomiPeriod}×${increment}(b)`;
    }
}
exports.timeControlStr = timeControlStr;

},{"snabbdom/h":85}],50:[function(require,module,exports){
"use strict";
// https://github.com/ornicar/lila/blob/master/ui/ceval/src/winningChances.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.povChances = void 0;
// winning chances for a color
// 1  infinitely winning
// -1 infinitely losing
function povChances(color, ev) {
    return toPov(color, evalWinningChances(ev));
}
exports.povChances = povChances;
function toPov(color, diff) {
    return color === 'white' ? diff : -diff;
}
function rawWinningChances(cp) {
    return 2 / (1 + Math.exp(-0.004 * cp)) - 1;
}
function cpWinningChances(cp) {
    return rawWinningChances(Math.min(Math.max(-1000, cp), 1000));
}
function mateWinningChances(mate) {
    const cp = (21 - Math.min(10, Math.abs(mate))) * 100;
    const signed = cp * (mate > 0 ? 1 : -1);
    return rawWinningChances(signed);
}
function evalWinningChances(ev) {
    return typeof ev.mate !== 'undefined' ? mateWinningChances(ev.mate) : cpWinningChances(ev.cp);
}

},{}],51:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.zenButtonView = exports.zenModeSettings = void 0;
const h_1 = require("snabbdom/h");
const i18n_1 = require("./i18n");
const settings_1 = require("./settings");
const view_1 = require("./view");
const snabbdom_1 = require("snabbdom");
const class_1 = __importDefault(require("snabbdom/modules/class"));
const attributes_1 = __importDefault(require("snabbdom/modules/attributes"));
const props_1 = __importDefault(require("snabbdom/modules/props"));
const eventlisteners_1 = __importDefault(require("snabbdom/modules/eventlisteners"));
const patch = (0, snabbdom_1.init)([class_1.default, attributes_1.default, props_1.default, eventlisteners_1.default]);
const zenModeOptions = {
    off: (0, i18n_1._)("Off"),
    on: (0, i18n_1._)("On"),
};
class ZenModeSettings extends settings_1.StringSettings {
    constructor() {
        super('zen', 'off');
    }
    update() {
        document.documentElement.setAttribute('data-zen', this.value);
    }
    view() {
        return (0, h_1.h)('div#zen-selector', (0, view_1.radioList)(this, 'zen', zenModeOptions, (_, key) => this.value = key));
    }
}
exports.zenModeSettings = new ZenModeSettings();
function deactivateZenMode() {
    exports.zenModeSettings.value = 'off';
    exports.zenModeSettings.update();
    const zenSettings = document.getElementById('zen-selector');
    zenSettings.innerHTML = "";
    patch(zenSettings, exports.zenModeSettings.view());
}
function zenButtonView() {
    return (0, h_1.h)('a#zen-button', { on: { click: deactivateZenMode } }, [
        (0, h_1.h)('div.icon.icon-check', (0, i18n_1._)('ZEN MODE'))
    ]);
}
exports.zenButtonView = zenButtonView;

},{"./i18n":18,"./settings":43,"./view":49,"snabbdom":93,"snabbdom/h":85,"snabbdom/modules/attributes":88,"snabbdom/modules/class":89,"snabbdom/modules/eventlisteners":90,"snabbdom/modules/props":91}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.render = exports.anim = void 0;
const util = require("./util");
function anim(mutation, state) {
    return state.animation.enabled ? animate(mutation, state) : render(mutation, state);
}
exports.anim = anim;
function render(mutation, state) {
    const result = mutation(state);
    state.dom.redraw();
    return result;
}
exports.render = render;
function makePiece(key, piece) {
    return {
        key: key,
        pos: util.key2pos(key),
        piece: piece
    };
}
function closer(piece, pieces) {
    return pieces.sort((p1, p2) => {
        return util.distanceSq(piece.pos, p1.pos) - util.distanceSq(piece.pos, p2.pos);
    })[0];
}
function computePlan(prevPieces, current) {
    const anims = {}, animedOrigs = [], fadings = {}, missings = [], news = [], prePieces = {};
    let curP, preP, i, vector;
    for (i in prevPieces) {
        prePieces[i] = makePiece(i, prevPieces[i]);
    }
    for (const key of util.allKeys(current.geometry)) {
        curP = current.pieces[key];
        preP = prePieces[key];
        if (curP) {
            if (preP) {
                if (!util.samePiece(curP, preP.piece)) {
                    missings.push(preP);
                    news.push(makePiece(key, curP));
                }
            }
            else
                news.push(makePiece(key, curP));
        }
        else if (preP)
            missings.push(preP);
    }
    news.forEach(newP => {
        preP = closer(newP, missings.filter(p => util.samePiece(newP.piece, p.piece)));
        if (preP) {
            vector = [preP.pos[0] - newP.pos[0], preP.pos[1] - newP.pos[1]];
            anims[newP.key] = vector.concat(vector);
            animedOrigs.push(preP.key);
        }
    });
    missings.forEach(p => {
        if (!util.containsX(animedOrigs, p.key))
            fadings[p.key] = p.piece;
    });
    return {
        anims: anims,
        fadings: fadings
    };
}
function step(state, now) {
    const cur = state.animation.current;
    if (cur === undefined) {
        if (!state.dom.destroyed)
            state.dom.redrawNow();
        return;
    }
    const rest = 1 - (now - cur.start) * cur.frequency;
    if (rest <= 0) {
        state.animation.current = undefined;
        state.dom.redrawNow();
    }
    else {
        const ease = easing(rest);
        for (let i in cur.plan.anims) {
            const cfg = cur.plan.anims[i];
            cfg[2] = cfg[0] * ease;
            cfg[3] = cfg[1] * ease;
        }
        state.dom.redrawNow(true);
        requestAnimationFrame((now = performance.now()) => step(state, now));
    }
}
function animate(mutation, state) {
    const prevPieces = Object.assign({}, state.pieces);
    const result = mutation(state);
    const plan = computePlan(prevPieces, state);
    if (!isObjectEmpty(plan.anims) || !isObjectEmpty(plan.fadings)) {
        const alreadyRunning = state.animation.current && state.animation.current.start;
        state.animation.current = {
            start: performance.now(),
            frequency: 1 / state.animation.duration,
            plan: plan
        };
        if (!alreadyRunning)
            step(state, performance.now());
    }
    else {
        state.dom.redraw();
    }
    return result;
}
function isObjectEmpty(o) {
    for (let _ in o)
        return false;
    return true;
}
function easing(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
}

},{"./util":69}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const board = require("./board");
const fen_1 = require("./fen");
const config_1 = require("./config");
const anim_1 = require("./anim");
const drag_1 = require("./drag");
const explosion_1 = require("./explosion");
function start(state, redrawAll) {
    function toggleOrientation() {
        board.toggleOrientation(state);
        redrawAll();
    }
    ;
    return {
        set(config) {
            if (config.orientation && config.orientation !== state.orientation)
                toggleOrientation();
            (config.fen ? anim_1.anim : anim_1.render)(state => config_1.configure(state, config), state);
        },
        state,
        getFen: () => fen_1.write(state.pieces, state.geometry),
        toggleOrientation,
        setPieces(pieces) {
            anim_1.anim(state => board.setPieces(state, pieces), state);
        },
        selectSquare(key, force) {
            if (key)
                anim_1.anim(state => board.selectSquare(state, key, force), state);
            else if (state.selected) {
                board.unselect(state);
                state.dom.redraw();
            }
        },
        move(orig, dest) {
            anim_1.anim(state => board.baseMove(state, orig, dest), state);
        },
        newPiece(piece, key) {
            anim_1.anim(state => board.baseNewPiece(state, piece, key), state);
        },
        playPremove() {
            if (state.premovable.current) {
                if (anim_1.anim(board.playPremove, state))
                    return true;
                state.dom.redraw();
            }
            return false;
        },
        playPredrop(validate) {
            if (state.predroppable.current) {
                const result = board.playPredrop(state, validate);
                state.dom.redraw();
                return result;
            }
            return false;
        },
        cancelPremove() {
            anim_1.render(board.unsetPremove, state);
        },
        cancelPredrop() {
            anim_1.render(board.unsetPredrop, state);
        },
        cancelMove() {
            anim_1.render(state => { board.cancelMove(state); drag_1.cancel(state); }, state);
        },
        stop() {
            anim_1.render(state => { board.stop(state); drag_1.cancel(state); }, state);
        },
        explode(keys) {
            explosion_1.default(state, keys);
        },
        setAutoShapes(shapes) {
            anim_1.render(state => state.drawable.autoShapes = shapes, state);
        },
        setShapes(shapes) {
            anim_1.render(state => state.drawable.shapes = shapes, state);
        },
        getKeyAtDomPos(pos) {
            return board.getKeyAtDomPos(pos, board.whitePov(state), state.dom.bounds(), state.geometry);
        },
        redrawAll,
        dragNewPiece(piece, event, force) {
            drag_1.dragNewPiece(state, piece, event, force);
        },
        destroy() {
            board.stop(state);
            state.dom.unbind && state.dom.unbind();
            state.dom.destroyed = true;
        }
    };
}
exports.start = start;

},{"./anim":52,"./board":54,"./config":56,"./drag":57,"./explosion":61,"./fen":62}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.whitePov = exports.getKeyAtDomPos = exports.stop = exports.cancelMove = exports.playPredrop = exports.playPremove = exports.isDraggable = exports.isPredroppable = exports.canMove = exports.unselect = exports.setSelected = exports.selectSquare = exports.dropNewPiece = exports.userMove = exports.baseNewPiece = exports.baseMove = exports.unsetPredrop = exports.unsetPremove = exports.setCheck = exports.setPieces = exports.reset = exports.toggleOrientation = exports.callUserFunction = void 0;
const util_1 = require("./util");
const premove_1 = require("./premove");
const predrop_1 = require("./predrop");
const cg = require("./types");
const drop_1 = require("./drop");
function callUserFunction(f, ...args) {
    if (f)
        setTimeout(() => f(...args), 1);
}
exports.callUserFunction = callUserFunction;
function toggleOrientation(state) {
    state.orientation = util_1.opposite(state.orientation);
    state.animation.current =
        state.draggable.current =
            state.selected = undefined;
}
exports.toggleOrientation = toggleOrientation;
function reset(state) {
    state.lastMove = undefined;
    unselect(state);
    unsetPremove(state);
    unsetPredrop(state);
}
exports.reset = reset;
function setPieces(state, pieces) {
    for (let key in pieces) {
        const piece = pieces[key];
        if (piece)
            state.pieces[key] = piece;
        else
            delete state.pieces[key];
    }
}
exports.setPieces = setPieces;
function setCheck(state, color) {
    state.check = undefined;
    if (color === true)
        color = state.turnColor;
    if (color)
        for (let k in state.pieces) {
            if (state.pieces[k].role === 'k-piece' && state.pieces[k].color === color) {
                state.check = k;
            }
        }
}
exports.setCheck = setCheck;
function setPremove(state, orig, dest, meta) {
    unsetPredrop(state);
    state.premovable.current = [orig, dest];
    callUserFunction(state.premovable.events.set, orig, dest, meta);
}
function unsetPremove(state) {
    if (state.premovable.current) {
        state.premovable.current = undefined;
        callUserFunction(state.premovable.events.unset);
    }
}
exports.unsetPremove = unsetPremove;
function setPredrop(state, role, key) {
    unsetPremove(state);
    state.predroppable.current = { role, key };
    callUserFunction(state.predroppable.events.set, role, key);
}
function unsetPredrop(state) {
    const pd = state.predroppable;
    if (pd.current) {
        pd.current = undefined;
        callUserFunction(pd.events.unset);
    }
}
exports.unsetPredrop = unsetPredrop;
function tryAutoCastle(state, orig, dest) {
    if (!state.autoCastle)
        return false;
    const king = state.pieces[orig];
    if (!king || king.role !== 'k-piece')
        return false;
    const origPos = util_1.key2pos(orig);
    if (origPos[0] !== 5)
        return false;
    if (origPos[1] !== 1 && origPos[1] !== 8)
        return false;
    const destPos = util_1.key2pos(dest);
    let oldRookPos, newRookPos, newKingPos;
    if (destPos[0] === 7 || destPos[0] === 8) {
        oldRookPos = util_1.pos2key([8, origPos[1]]);
        newRookPos = util_1.pos2key([6, origPos[1]]);
        newKingPos = util_1.pos2key([7, origPos[1]]);
    }
    else if (destPos[0] === 3 || destPos[0] === 1) {
        oldRookPos = util_1.pos2key([1, origPos[1]]);
        newRookPos = util_1.pos2key([4, origPos[1]]);
        newKingPos = util_1.pos2key([3, origPos[1]]);
    }
    else
        return false;
    const rook = state.pieces[oldRookPos];
    if (!rook || rook.role !== 'r-piece')
        return false;
    delete state.pieces[orig];
    delete state.pieces[oldRookPos];
    state.pieces[newKingPos] = king;
    state.pieces[newRookPos] = rook;
    return true;
}
function baseMove(state, orig, dest) {
    const origPiece = state.pieces[orig], destPiece = state.pieces[dest];
    if (orig === dest || !origPiece)
        return false;
    const captured = (destPiece && destPiece.color !== origPiece.color) ? destPiece : undefined;
    if (dest == state.selected)
        unselect(state);
    callUserFunction(state.events.move, orig, dest, captured);
    if (!tryAutoCastle(state, orig, dest)) {
        state.pieces[dest] = origPiece;
        delete state.pieces[orig];
    }
    state.lastMove = [orig, dest];
    state.check = undefined;
    callUserFunction(state.events.change);
    return captured || true;
}
exports.baseMove = baseMove;
function baseNewPiece(state, piece, key, force) {
    if (state.pieces[key]) {
        if (force)
            delete state.pieces[key];
        else
            return false;
    }
    callUserFunction(state.events.dropNewPiece, piece, key);
    state.pieces[key] = piece;
    state.lastMove = [key];
    state.check = undefined;
    callUserFunction(state.events.change);
    state.movable.dests = undefined;
    state.dropmode.dropDests = undefined;
    state.turnColor = util_1.opposite(state.turnColor);
    return true;
}
exports.baseNewPiece = baseNewPiece;
function baseUserMove(state, orig, dest) {
    const result = baseMove(state, orig, dest);
    if (result) {
        state.movable.dests = undefined;
        state.dropmode.dropDests = undefined;
        state.turnColor = util_1.opposite(state.turnColor);
        state.animation.current = undefined;
    }
    return result;
}
function userMove(state, orig, dest) {
    if (canMove(state, orig, dest)) {
        const result = baseUserMove(state, orig, dest);
        if (result) {
            const holdTime = state.hold.stop();
            unselect(state);
            const metadata = {
                premove: false,
                ctrlKey: state.stats.ctrlKey,
                holdTime
            };
            if (result !== true)
                metadata.captured = result;
            callUserFunction(state.movable.events.after, orig, dest, metadata);
            return true;
        }
    }
    else if (canPremove(state, orig, dest)) {
        setPremove(state, orig, dest, {
            ctrlKey: state.stats.ctrlKey
        });
        unselect(state);
        return true;
    }
    unselect(state);
    return false;
}
exports.userMove = userMove;
function dropNewPiece(state, orig, dest, force) {
    if (canDrop(state, orig, dest) || force) {
        const piece = state.pieces[orig];
        delete state.pieces[orig];
        baseNewPiece(state, piece, dest, force);
        callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {
            predrop: false
        });
    }
    else if (canPredrop(state, orig, dest)) {
        setPredrop(state, state.pieces[orig].role, dest);
    }
    else {
        unsetPremove(state);
        unsetPredrop(state);
        drop_1.cancelDropMode(state);
    }
    delete state.pieces[orig];
    unselect(state);
}
exports.dropNewPiece = dropNewPiece;
function selectSquare(state, key, force) {
    callUserFunction(state.events.select, key);
    if (state.selected) {
        if (state.selected === key && !state.draggable.enabled) {
            unselect(state);
            state.hold.cancel();
            return;
        }
        else if ((state.selectable.enabled || force) && state.selected !== key) {
            if (userMove(state, state.selected, key)) {
                state.stats.dragged = false;
                return;
            }
        }
    }
    if (isMovable(state, key) || isPremovable(state, key)) {
        setSelected(state, key);
        state.hold.start();
    }
}
exports.selectSquare = selectSquare;
function setSelected(state, key) {
    state.selected = key;
    if (isPremovable(state, key)) {
        state.premovable.dests = premove_1.default(state.pieces, key, state.premovable.castle, state.geometry, state.variant, state.chess960);
    }
    else {
        state.premovable.dests = undefined;
        state.predroppable.dropDests = undefined;
    }
}
exports.setSelected = setSelected;
function unselect(state) {
    state.selected = undefined;
    state.premovable.dests = undefined;
    state.predroppable.dropDests = undefined;
    state.hold.cancel();
}
exports.unselect = unselect;
function isMovable(state, orig) {
    const piece = state.pieces[orig];
    return !!piece && (state.movable.color === 'both' || (state.movable.color === piece.color &&
        state.turnColor === piece.color));
}
function canMove(state, orig, dest) {
    return orig !== dest && isMovable(state, orig) && (state.movable.free || (!!state.movable.dests && util_1.containsX(state.movable.dests[orig], dest)));
}
exports.canMove = canMove;
function canDrop(state, orig, dest) {
    const piece = state.pieces[orig];
    return !!piece && dest && (orig === dest || !state.pieces[dest]) && (state.movable.color === 'both' || (state.movable.color === piece.color &&
        state.turnColor === piece.color));
}
function isPremovable(state, orig) {
    const piece = state.pieces[orig];
    return !!piece && state.premovable.enabled &&
        state.movable.color === piece.color &&
        state.turnColor !== piece.color;
}
function isPredroppable(state) {
    var _a, _b;
    const piece = state.dropmode.active ? state.dropmode.piece : (_a = state.draggable.current) === null || _a === void 0 ? void 0 : _a.piece;
    return (!!piece &&
        (state.dropmode.active || ((_b = state.draggable.current) === null || _b === void 0 ? void 0 : _b.orig) === 'a0') &&
        state.predroppable.enabled &&
        state.movable.color === piece.color &&
        state.turnColor !== piece.color);
}
exports.isPredroppable = isPredroppable;
function canPremove(state, orig, dest) {
    return orig !== dest &&
        isPremovable(state, orig) &&
        util_1.containsX(premove_1.default(state.pieces, orig, state.premovable.castle, state.geometry, state.variant, state.chess960), dest);
}
function canPredrop(state, orig, dest) {
    const piece = state.pieces[orig];
    if (!piece) {
        return false;
    }
    const isValidPredrop = util_1.containsX(predrop_1.default(state.pieces, piece, state.geometry, state.variant), dest);
    return dest &&
        state.predroppable.enabled &&
        isValidPredrop &&
        state.movable.color === piece.color &&
        state.turnColor !== piece.color;
}
function isDraggable(state, orig) {
    const piece = state.pieces[orig];
    return !!piece && state.draggable.enabled && (state.movable.color === 'both' || (state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled)));
}
exports.isDraggable = isDraggable;
function playPremove(state) {
    const move = state.premovable.current;
    if (!move)
        return false;
    const orig = move[0], dest = move[1];
    let success = false;
    if (canMove(state, orig, dest)) {
        const result = baseUserMove(state, orig, dest);
        if (result) {
            const metadata = { premove: true };
            if (result !== true)
                metadata.captured = result;
            callUserFunction(state.movable.events.after, orig, dest, metadata);
            success = true;
        }
    }
    unsetPremove(state);
    return success;
}
exports.playPremove = playPremove;
function playPredrop(state, validate) {
    let drop = state.predroppable.current, success = false;
    if (!drop)
        return false;
    if (validate(drop)) {
        const piece = {
            role: drop.role,
            color: state.movable.color
        };
        if (baseNewPiece(state, piece, drop.key)) {
            callUserFunction(state.movable.events.afterNewPiece, drop.role, drop.key, {
                predrop: true
            });
            success = true;
        }
    }
    unsetPredrop(state);
    return success;
}
exports.playPredrop = playPredrop;
function cancelMove(state) {
    unsetPremove(state);
    unsetPredrop(state);
    unselect(state);
}
exports.cancelMove = cancelMove;
function stop(state) {
    state.movable.color =
        state.movable.dests =
            state.dropmode.dropDests =
                state.animation.current = undefined;
    cancelMove(state);
}
exports.stop = stop;
function getKeyAtDomPos(pos, asWhite, bounds, geom) {
    const bd = cg.dimensions[geom];
    let file = Math.ceil(bd.width * ((pos[0] - bounds.left) / bounds.width));
    if (!asWhite)
        file = bd.width + 1 - file;
    let rank = Math.ceil(bd.height - (bd.height * ((pos[1] - bounds.top) / bounds.height)));
    if (!asWhite)
        rank = bd.height + 1 - rank;
    return (file > 0 && file < bd.width + 1 && rank > 0 && rank < bd.height + 1) ? util_1.pos2key([file, rank]) : undefined;
}
exports.getKeyAtDomPos = getKeyAtDomPos;
function whitePov(s) {
    return s.orientation === 'white';
}
exports.whitePov = whitePov;

},{"./drop":59,"./predrop":63,"./premove":64,"./types":68,"./util":69}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chessground = void 0;
const api_1 = require("./api");
const config_1 = require("./config");
const state_1 = require("./state");
const wrap_1 = require("./wrap");
const events = require("./events");
const render_1 = require("./render");
const svg = require("./svg");
const util = require("./util");
function Chessground(element, config) {
    const state = state_1.defaults();
    config_1.configure(state, config || {});
    function redrawAll() {
        let prevUnbind = state.dom && state.dom.unbind;
        const relative = state.viewOnly && !state.drawable.visible, elements = wrap_1.default(element, state, relative), bounds = util.memo(() => elements.board.getBoundingClientRect()), redrawNow = (skipSvg) => {
            render_1.default(state);
            if (!skipSvg && elements.svg)
                svg.renderSvg(state, elements.svg);
        };
        state.dom = {
            elements,
            bounds,
            redraw: debounceRedraw(redrawNow),
            redrawNow,
            unbind: prevUnbind,
            relative
        };
        state.drawable.prevSvgHash = '';
        redrawNow(false);
        events.bindBoard(state);
        if (!prevUnbind)
            state.dom.unbind = events.bindDocument(state, redrawAll);
        state.events.insert && state.events.insert(elements);
    }
    redrawAll();
    return api_1.start(state, redrawAll);
}
exports.Chessground = Chessground;
;
function debounceRedraw(redrawNow) {
    let redrawing = false;
    return () => {
        if (redrawing)
            return;
        redrawing = true;
        requestAnimationFrame(() => {
            redrawNow();
            redrawing = false;
        });
    };
}

},{"./api":53,"./config":56,"./events":60,"./render":65,"./state":66,"./svg":67,"./util":69,"./wrap":70}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configure = void 0;
const board_1 = require("./board");
const fen_1 = require("./fen");
const cg = require("./types");
function configure(state, config) {
    var _a;
    if (config.movable && config.movable.dests)
        state.movable.dests = undefined;
    if ((_a = config.dropmode) === null || _a === void 0 ? void 0 : _a.dropDests)
        state.dropmode.dropDests = undefined;
    merge(state, config);
    if (config.geometry)
        state.dimensions = cg.dimensions[config.geometry];
    if (config.fen) {
        const pieces = fen_1.read(config.fen);
        if (state.pieces['a0'] !== undefined)
            pieces['a0'] = state.pieces['a0'];
        state.pieces = pieces;
        state.drawable.shapes = [];
    }
    if (config.hasOwnProperty('check'))
        board_1.setCheck(state, config.check || false);
    if (config.hasOwnProperty('lastMove') && !config.lastMove)
        state.lastMove = undefined;
    else if (config.lastMove)
        state.lastMove = config.lastMove;
    if (state.selected)
        board_1.setSelected(state, state.selected);
    if (!state.animation.duration || state.animation.duration < 100)
        state.animation.enabled = false;
    if (!state.movable.rookCastle && state.movable.dests) {
        const rank = state.movable.color === 'white' ? 1 : 8, kingStartPos = 'e' + rank, dests = state.movable.dests[kingStartPos], king = state.pieces[kingStartPos];
        if (!dests || !king || king.role !== 'k-piece')
            return;
        state.movable.dests[kingStartPos] = dests.filter(d => !((d === 'a' + rank) && dests.indexOf('c' + rank) !== -1) &&
            !((d === 'h' + rank) && dests.indexOf('g' + rank) !== -1));
    }
}
exports.configure = configure;
;
function merge(base, extend) {
    for (let key in extend) {
        if (isObject(base[key]) && isObject(extend[key]))
            merge(base[key], extend[key]);
        else
            base[key] = extend[key];
    }
}
function isObject(o) {
    return typeof o === 'object';
}

},{"./board":54,"./fen":62,"./types":68}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cancel = exports.end = exports.move = exports.dragNewPiece = exports.pieceCloseTo = exports.start = void 0;
const board = require("./board");
const util = require("./util");
const draw_1 = require("./draw");
const anim_1 = require("./anim");
const predrop_1 = require("./predrop");
function start(s, e) {
    if (e.button !== undefined && e.button !== 0)
        return;
    if (e.touches && e.touches.length > 1)
        return;
    const bounds = s.dom.bounds(), position = util.eventPosition(e), orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds, s.geometry);
    if (!orig)
        return;
    const piece = s.pieces[orig];
    const previouslySelected = s.selected;
    if (!previouslySelected && s.drawable.enabled && (s.drawable.eraseOnClick || (!piece || piece.color !== s.turnColor)))
        draw_1.clear(s);
    if (e.cancelable !== false &&
        (!e.touches || !s.movable.color || piece || previouslySelected || pieceCloseTo(s, position)))
        e.preventDefault();
    const hadPremove = !!s.premovable.current;
    const hadPredrop = !!s.predroppable.current;
    s.stats.ctrlKey = e.ctrlKey;
    if (s.selected && board.canMove(s, s.selected, orig)) {
        anim_1.anim(state => board.selectSquare(state, orig), s);
    }
    else {
        board.selectSquare(s, orig);
    }
    const stillSelected = s.selected === orig;
    const element = pieceElementByKey(s, orig);
    if (piece && element && stillSelected && board.isDraggable(s, orig)) {
        const squareBounds = computeSquareBounds(orig, board.whitePov(s), bounds, s.dimensions);
        s.draggable.current = {
            orig,
            origPos: util.key2pos(orig),
            piece,
            rel: position,
            epos: position,
            pos: [0, 0],
            dec: s.draggable.centerPiece ? [
                position[0] - (squareBounds.left + squareBounds.width / 2),
                position[1] - (squareBounds.top + squareBounds.height / 2)
            ] : [0, 0],
            started: s.draggable.autoDistance && s.stats.dragged,
            element,
            previouslySelected,
            originTarget: e.target
        };
        element.cgDragging = true;
        element.classList.add('dragging');
        const ghost = s.dom.elements.ghost;
        if (ghost) {
            const promoted = piece.promoted ? "promoted " : "";
            const side = piece.color === s.orientation ? "ally" : "enemy";
            ghost.className = `ghost ${piece.color} ${promoted}${piece.role} ${side}`;
            util.translateAbs(ghost, util.posToTranslateAbs(bounds, s.dimensions)(util.key2pos(orig), board.whitePov(s)));
            util.setVisible(ghost, true);
        }
        processDrag(s);
    }
    else {
        if (hadPremove)
            board.unsetPremove(s);
        if (hadPredrop)
            board.unsetPredrop(s);
    }
    s.dom.redraw();
}
exports.start = start;
function pieceCloseTo(s, pos) {
    const asWhite = board.whitePov(s), bounds = s.dom.bounds(), radiusSq = Math.pow(bounds.width / 8, 2);
    for (let key in s.pieces) {
        const squareBounds = computeSquareBounds(key, asWhite, bounds, s.dimensions), center = [
            squareBounds.left + squareBounds.width / 2,
            squareBounds.top + squareBounds.height / 2
        ];
        if (util.distanceSq(center, pos) <= radiusSq)
            return true;
    }
    return false;
}
exports.pieceCloseTo = pieceCloseTo;
function dragNewPiece(s, piece, e, force) {
    const key = 'a0';
    s.pieces[key] = piece;
    s.dom.redraw();
    const position = util.eventPosition(e), asWhite = board.whitePov(s), bounds = s.dom.bounds(), squareBounds = computeSquareBounds(key, asWhite, bounds, s.dimensions);
    const rel = [
        (asWhite ? 0 : s.dimensions.width - 1) * squareBounds.width + bounds.left,
        (asWhite ? s.dimensions.height : -1) * squareBounds.height + bounds.top
    ];
    s.draggable.current = {
        orig: key,
        origPos: util.key2pos('a0'),
        piece,
        rel,
        epos: position,
        pos: [position[0] - rel[0], position[1] - rel[1]],
        dec: [-squareBounds.width / 2, -squareBounds.height / 2],
        started: true,
        element: () => pieceElementByKey(s, key),
        originTarget: e.target,
        newPiece: true,
        force: !!force
    };
    if (piece && board.isPredroppable(s)) {
        s.predroppable.dropDests = predrop_1.default(s.pieces, piece, s.geometry, s.variant);
    }
    processDrag(s);
}
exports.dragNewPiece = dragNewPiece;
function processDrag(s) {
    requestAnimationFrame(() => {
        const cur = s.draggable.current;
        if (!cur)
            return;
        if (s.animation.current && s.animation.current.plan.anims[cur.orig])
            s.animation.current = undefined;
        const origPiece = s.pieces[cur.orig];
        if (!origPiece || !util.samePiece(origPiece, cur.piece))
            cancel(s);
        else {
            if (!cur.started && util.distanceSq(cur.epos, cur.rel) >= Math.pow(s.draggable.distance, 2))
                cur.started = true;
            if (cur.started) {
                if (typeof cur.element === 'function') {
                    const found = cur.element();
                    if (!found)
                        return;
                    found.cgDragging = true;
                    found.classList.add('dragging');
                    cur.element = found;
                }
                cur.pos = [
                    cur.epos[0] - cur.rel[0],
                    cur.epos[1] - cur.rel[1]
                ];
                const translation = util.posToTranslateAbs(s.dom.bounds(), s.dimensions)(cur.origPos, board.whitePov(s));
                translation[0] += cur.pos[0] + cur.dec[0];
                translation[1] += cur.pos[1] + cur.dec[1];
                util.translateAbs(cur.element, translation);
            }
        }
        processDrag(s);
    });
}
function move(s, e) {
    if (s.draggable.current && (!e.touches || e.touches.length < 2)) {
        s.draggable.current.epos = util.eventPosition(e);
    }
}
exports.move = move;
function end(s, e) {
    const cur = s.draggable.current;
    if (!cur)
        return;
    if (e.type === 'touchend' && e.cancelable !== false)
        e.preventDefault();
    if (e.type === 'touchend' && cur && cur.originTarget !== e.target && !cur.newPiece) {
        s.draggable.current = undefined;
        return;
    }
    board.unsetPremove(s);
    board.unsetPredrop(s);
    const eventPos = util.eventPosition(e) || cur.epos;
    const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds(), s.geometry);
    if (dest && cur.started && cur.orig !== dest) {
        if (cur.newPiece)
            board.dropNewPiece(s, cur.orig, dest, cur.force);
        else {
            s.stats.ctrlKey = e.ctrlKey;
            if (board.userMove(s, cur.orig, dest))
                s.stats.dragged = true;
        }
    }
    else if (cur.newPiece) {
        delete s.pieces[cur.orig];
    }
    else if (s.draggable.deleteOnDropOff && !dest) {
        delete s.pieces[cur.orig];
        board.callUserFunction(s.events.change);
    }
    if (cur && cur.orig === cur.previouslySelected && (cur.orig === dest || !dest))
        board.unselect(s);
    else if (!s.selectable.enabled)
        board.unselect(s);
    removeDragElements(s);
    s.draggable.current = undefined;
    s.dom.redraw();
}
exports.end = end;
function cancel(s) {
    const cur = s.draggable.current;
    if (cur) {
        if (cur.newPiece)
            delete s.pieces[cur.orig];
        s.draggable.current = undefined;
        board.unselect(s);
        removeDragElements(s);
        s.dom.redraw();
    }
}
exports.cancel = cancel;
function removeDragElements(s) {
    const e = s.dom.elements;
    if (e.ghost)
        util.setVisible(e.ghost, false);
}
function computeSquareBounds(key, asWhite, bounds, bd) {
    const pos = util.key2pos(key);
    if (!asWhite) {
        pos[0] = bd.width + 1 - pos[0];
        pos[1] = bd.height + 1 - pos[1];
    }
    return {
        left: bounds.left + bounds.width * (pos[0] - 1) / bd.width,
        top: bounds.top + bounds.height * (bd.height - pos[1]) / bd.height,
        width: bounds.width / bd.width,
        height: bounds.height / bd.height
    };
}
function pieceElementByKey(s, key) {
    let el = s.dom.elements.board.firstChild;
    while (el) {
        if (el.cgKey === key && el.tagName === 'PIECE')
            return el;
        el = el.nextSibling;
    }
    return undefined;
}

},{"./anim":52,"./board":54,"./draw":58,"./predrop":63,"./util":69}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clear = exports.cancel = exports.end = exports.move = exports.processDraw = exports.start = void 0;
const board_1 = require("./board");
const util_1 = require("./util");
const brushes = ['green', 'red', 'blue', 'yellow'];
function start(state, e) {
    if (e.touches && e.touches.length > 1)
        return;
    e.stopPropagation();
    e.preventDefault();
    e.ctrlKey ? board_1.unselect(state) : board_1.cancelMove(state);
    const pos = util_1.eventPosition(e), orig = board_1.getKeyAtDomPos(pos, board_1.whitePov(state), state.dom.bounds(), state.geometry);
    if (!orig)
        return;
    state.drawable.current = {
        orig,
        pos,
        brush: eventBrush(e)
    };
    processDraw(state);
}
exports.start = start;
function processDraw(state) {
    requestAnimationFrame(() => {
        const cur = state.drawable.current;
        if (cur) {
            const mouseSq = board_1.getKeyAtDomPos(cur.pos, board_1.whitePov(state), state.dom.bounds(), state.geometry);
            if (mouseSq !== cur.mouseSq) {
                cur.mouseSq = mouseSq;
                cur.dest = mouseSq !== cur.orig ? mouseSq : undefined;
                state.dom.redrawNow();
            }
            processDraw(state);
        }
    });
}
exports.processDraw = processDraw;
function move(state, e) {
    if (state.drawable.current)
        state.drawable.current.pos = util_1.eventPosition(e);
}
exports.move = move;
function end(state) {
    const cur = state.drawable.current;
    if (cur) {
        if (cur.mouseSq)
            addShape(state.drawable, cur);
        cancel(state);
    }
}
exports.end = end;
function cancel(state) {
    if (state.drawable.current) {
        state.drawable.current = undefined;
        state.dom.redraw();
    }
}
exports.cancel = cancel;
function clear(state) {
    if (state.drawable.shapes.length) {
        state.drawable.shapes = [];
        state.dom.redraw();
        onChange(state.drawable);
    }
}
exports.clear = clear;
function eventBrush(e) {
    return brushes[((e.shiftKey || e.ctrlKey) && util_1.isRightButton(e) ? 1 : 0) + (e.altKey ? 2 : 0)];
}
function addShape(drawable, cur) {
    const sameShape = (s) => s.orig === cur.orig && s.dest === cur.dest;
    const similar = drawable.shapes.filter(sameShape)[0];
    if (similar)
        drawable.shapes = drawable.shapes.filter(s => !sameShape(s));
    if (!similar || similar.brush !== cur.brush)
        drawable.shapes.push(cur);
    onChange(drawable);
}
function onChange(drawable) {
    if (drawable.onChange)
        drawable.onChange(drawable.shapes);
}

},{"./board":54,"./util":69}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.drop = exports.cancelDropMode = exports.setDropMode = void 0;
const board = require("./board");
const util = require("./util");
const drag_1 = require("./drag");
const predrop_1 = require("./predrop");
const board_1 = require("./board");
function setDropMode(s, piece) {
    s.dropmode.active = true;
    s.dropmode.piece = piece;
    drag_1.cancel(s);
    board.unselect(s);
    if (piece && board.isPredroppable(s)) {
        s.predroppable.dropDests = predrop_1.default(s.pieces, piece, s.geometry, s.variant);
    }
}
exports.setDropMode = setDropMode;
function cancelDropMode(s) {
    var _a;
    s.dropmode.active = false;
    board_1.callUserFunction((_a = s.dropmode.events) === null || _a === void 0 ? void 0 : _a.cancel);
}
exports.cancelDropMode = cancelDropMode;
function drop(s, e) {
    if (!s.dropmode.active)
        return;
    board.unsetPremove(s);
    board.unsetPredrop(s);
    const piece = s.dropmode.piece;
    if (piece) {
        s.pieces.a0 = piece;
        const position = util.eventPosition(e);
        const dest = position && board.getKeyAtDomPos(position, board.whitePov(s), s.dom.bounds(), s.geometry);
        if (dest)
            board.dropNewPiece(s, 'a0', dest);
    }
    s.dom.redraw();
}
exports.drop = drop;

},{"./board":54,"./drag":57,"./predrop":63,"./util":69}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bindDocument = exports.bindBoard = void 0;
const drag = require("./drag");
const draw = require("./draw");
const drop_1 = require("./drop");
const util_1 = require("./util");
const board_1 = require("./board");
function bindBoard(s) {
    if (s.viewOnly)
        return;
    const boardEl = s.dom.elements.board, onStart = startDragOrDraw(s);
    boardEl.addEventListener('touchstart', onStart, { passive: false });
    boardEl.addEventListener('mousedown', onStart, { passive: false });
    if (s.disableContextMenu || s.drawable.enabled) {
        boardEl.addEventListener('contextmenu', e => e.preventDefault());
    }
}
exports.bindBoard = bindBoard;
function bindDocument(s, redrawAll) {
    const unbinds = [];
    if (!s.dom.relative && s.resizable) {
        const onResize = () => {
            s.dom.bounds.clear();
            requestAnimationFrame(redrawAll);
        };
        unbinds.push(unbindable(document.body, 'chessground.resize', onResize));
    }
    if (!s.viewOnly) {
        const onmove = dragOrDraw(s, drag.move, draw.move);
        const onend = dragOrDraw(s, drag.end, draw.end);
        ['touchmove', 'mousemove'].forEach(ev => unbinds.push(unbindable(document, ev, onmove)));
        ['touchend', 'mouseup'].forEach(ev => unbinds.push(unbindable(document, ev, onend)));
        const onScroll = () => s.dom.bounds.clear();
        unbinds.push(unbindable(window, 'scroll', onScroll, { passive: true }));
        unbinds.push(unbindable(window, 'resize', onScroll, { passive: true }));
    }
    return () => unbinds.forEach(f => f());
}
exports.bindDocument = bindDocument;
function unbindable(el, eventName, callback, options) {
    el.addEventListener(eventName, callback, options);
    return () => el.removeEventListener(eventName, callback);
}
function startDragOrDraw(s) {
    return e => {
        var _a;
        if (s.draggable.current)
            drag.cancel(s);
        else if (s.drawable.current)
            draw.cancel(s);
        else if (e.shiftKey || util_1.isRightButton(e)) {
            if (s.drawable.enabled)
                draw.start(s, e);
        }
        else if (!s.viewOnly) {
            if (s.dropmode.active && undefined == squareOccupied(s, e)) {
                drop_1.drop(s, e);
            }
            else if (s.dropmode.active && s.movable.color != s.turnColor && ((_a = squareOccupied(s, e)) === null || _a === void 0 ? void 0 : _a.color) == s.turnColor) {
                drop_1.drop(s, e);
            }
            else {
                drop_1.cancelDropMode(s);
                drag.start(s, e);
            }
        }
    };
}
function dragOrDraw(s, withDrag, withDraw) {
    return e => {
        if (e.shiftKey || util_1.isRightButton(e)) {
            if (s.drawable.enabled)
                withDraw(s, e);
        }
        else if (!s.viewOnly)
            withDrag(s, e);
    };
}
function squareOccupied(s, e) {
    const position = util_1.eventPosition(e);
    const dest = position && board_1.getKeyAtDomPos(position, board_1.whitePov(s), s.dom.bounds(), s.geometry);
    if (dest && s.pieces[dest])
        return s.pieces[dest];
    return undefined;
}

},{"./board":54,"./drag":57,"./draw":58,"./drop":59,"./util":69}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function explosion(state, keys) {
    state.exploding = { stage: 1, keys };
    state.dom.redraw();
    setTimeout(() => {
        setStage(state, 2);
        setTimeout(() => setStage(state, undefined), 120);
    }, 120);
}
exports.default = explosion;
function setStage(state, stage) {
    if (state.exploding) {
        if (stage)
            state.exploding.stage = stage;
        else
            state.exploding = undefined;
        state.dom.redraw();
    }
}

},{}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.write = exports.read = exports.initial = void 0;
const util_1 = require("./util");
const cg = require("./types");
exports.initial = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';
function roles(letter) {
    return (letter.replace("+", "p") + "-piece");
}
function letters(role) {
    const letterPart = role.slice(0, role.indexOf('-'));
    return (letterPart.length > 1) ? letterPart.replace('p', '+') : letterPart;
}
function read(fen) {
    if (fen === 'start')
        fen = exports.initial;
    if (fen.indexOf('[') !== -1)
        fen = fen.slice(0, fen.indexOf('['));
    const pieces = {};
    let row = fen.split("/").length;
    let col = 0;
    let promoted = false;
    let num = 0;
    for (const c of fen) {
        switch (c) {
            case ' ': return pieces;
            case '/':
                --row;
                if (row === 0)
                    return pieces;
                col = 0;
                num = 0;
                break;
            case '+':
                promoted = true;
                break;
            case '~':
                const piece = pieces[util_1.pos2key([col, row])];
                if (piece) {
                    piece.promoted = true;
                }
                break;
            default:
                const nb = c.charCodeAt(0);
                if (48 <= nb && nb < 58) {
                    num = 10 * num + nb - 48;
                }
                else {
                    col += 1 + num;
                    num = 0;
                    const letter = c.toLowerCase();
                    let piece = {
                        role: roles(letter),
                        color: (c === letter ? 'black' : 'white')
                    };
                    if (promoted) {
                        piece.role = ('p' + piece.role);
                        piece.promoted = true;
                        promoted = false;
                    }
                    ;
                    pieces[util_1.pos2key([col, row])] = piece;
                }
        }
    }
    return pieces;
}
exports.read = read;
function write(pieces, geom) {
    const bd = cg.dimensions[geom];
    return util_1.invNRanks.slice(-bd.height).map(y => util_1.NRanks.slice(0, bd.width).map(x => {
        const piece = pieces[util_1.pos2key([x, y])];
        if (piece) {
            const letter = letters(piece.role) + ((piece.promoted && (letters(piece.role).charAt(0) !== '+')) ? '~' : '');
            return (piece.color === 'white') ? letter.toUpperCase() : letter;
        }
        else
            return '1';
    }).join('')).join('/').replace(/1{2,}/g, s => s.length.toString());
}
exports.write = write;

},{"./types":68,"./util":69}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util = require("./util");
const cg = require("./types");
const wholeBoard = (_x, _y) => true;
function rankRange(from, to, color, geom) {
    const height = cg.dimensions[geom].height;
    if (from < 1)
        from += height;
    if (to < 1)
        to += height;
    return (_x, y) => {
        if (color === 'black')
            y = height - y + 1;
        return from <= y && y <= to;
    };
}
function predrop(pieces, piece, geom, variant) {
    const color = piece.color;
    const role = piece.role;
    let mobility = wholeBoard;
    switch (variant) {
        case 'crazyhouse':
        case 'shouse':
        case 'capahouse':
        case 'gothhouse':
            switch (role) {
                case 'p-piece':
                    mobility = rankRange(2, -1, color, geom);
                    break;
            }
            break;
        case 'placement':
            mobility = rankRange(1, 1, color, geom);
            break;
        case 'sittuyin':
            switch (role) {
                case 'r-piece':
                    mobility = rankRange(1, 1, color, geom);
                    break;
                default: mobility = (x, y) => {
                    const width = cg.dimensions[geom].width;
                    const height = cg.dimensions[geom].height;
                    if (color === 'black') {
                        x = width - x + 1;
                        y = height - y + 1;
                    }
                    return y < 3 || (y === 3 && x > 4);
                };
            }
            break;
        case 'shogi':
        case 'minishogi':
        case 'gorogoro':
            switch (role) {
                case 'p-piece':
                case 'l-piece':
                    mobility = rankRange(1, -1, color, geom);
                    break;
                case 'n-piece':
                    mobility = rankRange(1, -2, color, geom);
                    break;
            }
            break;
        case 'kyotoshogi':
        case 'dobutsu':
            mobility = wholeBoard;
            break;
        case 'torishogi':
            switch (role) {
                case 's-piece':
                    mobility = rankRange(1, -1, color, geom);
                    break;
            }
            break;
        case 'grandhouse':
            switch (role) {
                case 'p-piece':
                    mobility = rankRange(2, 7, color, geom);
                    break;
            }
            break;
        case 'shogun':
            mobility = rankRange(1, 5, color, geom);
            break;
        case 'synochess':
            mobility = (_x, y) => y === 5;
            break;
        case 'shinobi':
            mobility = (_x, y) => y <= 4;
            break;
        default:
            console.warn("Unknown drop variant", variant);
    }
    return util.allKeys(geom).map(util.key2pos).filter(pos => {
        var _a;
        return ((_a = pieces[util.pos2key(pos)]) === null || _a === void 0 ? void 0 : _a.color) !== color && mobility(pos[0], pos[1]);
    }).map(util.pos2key);
}
exports.default = predrop;

},{"./types":68,"./util":69}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util = require("./util");
const cg = require("./types");
function diff(a, b) {
    return Math.abs(a - b);
}
function pawn(color) {
    return (x1, y1, x2, y2) => diff(x1, x2) < 2 && (color === 'white' ? (y2 === y1 + 1 || (y1 <= 2 && y2 === (y1 + 2) && x1 === x2)) : (y2 === y1 - 1 || (y1 >= 7 && y2 === (y1 - 2) && x1 === x2)));
}
const knight = (x1, y1, x2, y2) => {
    const xd = diff(x1, x2);
    const yd = diff(y1, y2);
    return (xd === 1 && yd === 2) || (xd === 2 && yd === 1);
};
const bishop = (x1, y1, x2, y2) => {
    return diff(x1, x2) === diff(y1, y2);
};
const rook = (x1, y1, x2, y2) => {
    return x1 === x2 || y1 === y2;
};
const queen = (x1, y1, x2, y2) => {
    return bishop(x1, y1, x2, y2) || rook(x1, y1, x2, y2);
};
function king(color, rookFiles, canCastle) {
    return (x1, y1, x2, y2) => (diff(x1, x2) < 2 && diff(y1, y2) < 2) || (canCastle && y1 === y2 && y1 === (color === 'white' ? 1 : 8) && ((x1 === 5 && ((util.containsX(rookFiles, 1) && x2 === 3) || (util.containsX(rookFiles, 8) && x2 === 7))) ||
        util.containsX(rookFiles, x2)));
}
function rookFilesOf(pieces, color) {
    const backrank = color === 'white' ? '1' : '8';
    return Object.keys(pieces).filter(key => {
        const piece = pieces[key];
        return key[1] === backrank && piece && piece.color === color && piece.role === 'r-piece';
    }).map((key) => util.key2pos(key)[0]);
}
const kingNoCastling = (x1, y1, x2, y2) => {
    return diff(x1, x2) < 2 && diff(y1, y2) < 2;
};
function king960(color, rookFiles, canCastle) {
    return (x1, y1, x2, y2) => (kingNoCastling(x1, y1, x2, y2)) || (canCastle && y1 === y2 && y1 === (color === 'white' ? 1 : 8) && util.containsX(rookFiles, x2));
}
function kingCapa(color, rookFiles, canCastle) {
    return (x1, y1, x2, y2) => (kingNoCastling(x1, y1, x2, y2)) || (canCastle && y1 === y2 && y1 === (color === 'white' ? 1 : 8) && (x1 == 6 && ((x2 == 9 && util.containsX(rookFiles, 10)) || (x2 == 3 && util.containsX(rookFiles, 1)))));
}
function kingShako(color, rookFiles, canCastle) {
    return (x1, y1, x2, y2) => (kingNoCastling(x1, y1, x2, y2)) || (canCastle && y1 === y2 && y1 === (color === 'white' ? 2 : 9) && (x1 == 6 && ((x2 == 8 && util.containsX(rookFiles, 9)) || (x2 == 4 && util.containsX(rookFiles, 2)))));
}
function rookFilesOfShako(pieces, color) {
    const backrank = color === 'white' ? '2' : '9';
    return Object.keys(pieces).filter(key => {
        const piece = pieces[key];
        return key[1] === backrank && piece && piece.color === color && piece.role === 'r-piece';
    }).map((key) => util.key2pos(key)[0]);
}
const wazir = (x1, y1, x2, y2) => {
    const xd = diff(x1, x2);
    const yd = diff(y1, y2);
    return (xd === 1 && yd === 0) || (xd === 0 && yd === 1);
};
const ferz = (x1, y1, x2, y2) => diff(x1, x2) === diff(y1, y2) && diff(x1, x2) === 1;
const elephant = (x1, y1, x2, y2) => {
    const xd = diff(x1, x2);
    const yd = diff(y1, y2);
    return xd === yd && xd === 2;
};
const archbishop = (x1, y1, x2, y2) => {
    return bishop(x1, y1, x2, y2) || knight(x1, y1, x2, y2);
};
const chancellor = (x1, y1, x2, y2) => {
    return rook(x1, y1, x2, y2) || knight(x1, y1, x2, y2);
};
const amazon = (x1, y1, x2, y2) => {
    return bishop(x1, y1, x2, y2) || rook(x1, y1, x2, y2) || knight(x1, y1, x2, y2);
};
const centaur = (x1, y1, x2, y2) => {
    return kingNoCastling(x1, y1, x2, y2) || knight(x1, y1, x2, y2);
};
function grandPawn(color) {
    return (x1, y1, x2, y2) => diff(x1, x2) < 2 && (color === 'white' ? (y2 === y1 + 1 || (y1 <= 3 && y2 === (y1 + 2) && x1 === x2)) : (y2 === y1 - 1 || (y1 >= 8 && y2 === (y1 - 2) && x1 === x2)));
}
function shogiLance(color) {
    return (x1, y1, x2, y2) => (x2 === x1 && (color === 'white' ? y2 > y1 : y2 < y1));
}
function shogiSilver(color) {
    return (x1, y1, x2, y2) => (ferz(x1, y1, x2, y2) || (x1 === x2 && (color === 'white' ? y2 === y1 + 1 : y2 === y1 - 1)));
}
function shogiGold(color) {
    return (x1, y1, x2, y2) => (wazir(x1, y1, x2, y2) || (diff(x1, x2) < 2 && (color === 'white' ? y2 === y1 + 1 : y2 === y1 - 1)));
}
function shogiPawn(color) {
    return (x1, y1, x2, y2) => (x2 === x1 && (color === 'white' ? y2 === y1 + 1 : y2 === y1 - 1));
}
function shogiKnight(color) {
    return (x1, y1, x2, y2) => (x2 === x1 - 1 || x2 === x1 + 1) &&
        (color === 'white' ? (y2 === y1 + 2) : (y2 === y1 - 2));
}
const shogiDragon = (x1, y1, x2, y2) => {
    return rook(x1, y1, x2, y2) || ferz(x1, y1, x2, y2);
};
const shogiHorse = (x1, y1, x2, y2) => {
    return bishop(x1, y1, x2, y2) || wazir(x1, y1, x2, y2);
};
function palace(geom, color) {
    const bd = cg.dimensions[geom];
    const middleFile = Math.floor((bd.width + 1) / 2);
    const startingRank = (color === "white") ? 1 : bd.height - 2;
    return [
        [middleFile - 1, startingRank + 2], [middleFile, startingRank + 2], [middleFile + 1, startingRank + 2],
        [middleFile - 1, startingRank + 1], [middleFile, startingRank + 1], [middleFile + 1, startingRank + 1],
        [middleFile - 1, startingRank], [middleFile, startingRank], [middleFile + 1, startingRank],
    ];
}
const palaces = {
    [3]: {
        white: palace(3, "white"),
        black: palace(3, "black"),
    },
    [6]: {
        white: palace(6, "white"),
        black: palace(6, "black"),
    },
};
function xiangqiPawn(color) {
    return (x1, y1, x2, y2) => ((x2 === x1 && (color === 'white' ? y2 === y1 + 1 : y2 === y1 - 1)) ||
        (y2 === y1 && diff(x1, x2) < 2 && (color === 'white' ? y1 > 5 : y1 < 6)));
}
function minixiangqiPawn(color) {
    return (x1, y1, x2, y2) => ((x2 === x1 && (color === 'white' ? y2 === y1 + 1 : y2 === y1 - 1)) ||
        (y2 === y1 && diff(x1, x2) < 2));
}
function xiangqiElephant(color) {
    return (x1, y1, x2, y2) => elephant(x1, y1, x2, y2) && (color === 'white' ? y2 < 6 : y2 > 5);
}
function xiangqiAdvisor(color, geom) {
    const palace = palaces[geom][color];
    return (x1, y1, x2, y2) => ferz(x1, y1, x2, y2) && palace.some(point => (point[0] === x2 && point[1] === y2));
}
function xiangqiKing(color, geom) {
    const palace = palaces[geom][color];
    return (x1, y1, x2, y2) => wazir(x1, y1, x2, y2) && palace.some(point => (point[0] === x2 && point[1] === y2));
}
const shakoElephant = (x1, y1, x2, y2) => {
    return diff(x1, x2) === diff(y1, y2) && (diff(x1, x2) < 3);
};
const janggiElephant = (x1, y1, x2, y2) => {
    const xd = diff(x1, x2);
    const yd = diff(y1, y2);
    return (xd === 2 && yd === 3) || (xd === 3 && yd === 2);
};
function janggiPawn(color, geom) {
    const oppPalace = palaces[geom][util.opposite(color)];
    return (x1, y1, x2, y2) => {
        const palacePos = oppPalace.findIndex(point => point[0] === x1 && point[1] === y1);
        let additionalMobility;
        switch (palacePos) {
            case 0:
                additionalMobility = (x1, y1, x2, y2) => x2 === x1 + 1 && color === 'black' && y2 === y1 - 1;
                break;
            case 2:
                additionalMobility = (x1, y1, x2, y2) => x2 === x1 - 1 && color === 'black' && y2 === y1 - 1;
                break;
            case 4:
                additionalMobility = (x1, y1, x2, y2) => diff(x1, x2) === 1 && (color === 'white' ? y2 === y1 + 1 : y2 === y1 - 1);
                break;
            case 6:
                additionalMobility = (x1, y1, x2, y2) => x2 === x1 + 1 && color === 'white' && y2 === y1 + 1;
                break;
            case 8:
                additionalMobility = (x1, y1, x2, y2) => x2 === x1 - 1 && color === 'white' && y2 === y1 + 1;
                break;
            default: additionalMobility = () => false;
        }
        return (x2 === x1 && (color === 'white' ? y2 === y1 + 1 : y2 === y1 - 1)) ||
            (y2 === y1 && diff(x1, x2) < 2) ||
            additionalMobility(x1, y1, x2, y2);
    };
}
function janggiRook(geom) {
    const wPalace = palaces[geom]['white'];
    const bPalace = palaces[geom]['black'];
    return (x1, y1, x2, y2) => {
        let additionalMobility;
        const wPalacePos = wPalace.findIndex(point => point[0] === x1 && point[1] === y1);
        const bPalacePos = bPalace.findIndex(point => point[0] === x1 && point[1] === y1);
        const palacePos = wPalacePos !== -1 ? wPalacePos : bPalacePos;
        const xd = diff(x1, x2);
        const yd = diff(y1, y2);
        switch (palacePos) {
            case 0:
                additionalMobility = (x1, y1, x2, y2) => xd === yd && x2 > x1 && x2 <= x1 + 2 && y2 < y1 && y2 >= y1 - 2;
                break;
            case 2:
                additionalMobility = (x1, y1, x2, y2) => xd === yd && x2 < x1 && x2 >= x1 - 2 && y2 < y1 && y2 >= y1 - 2;
                break;
            case 4:
                additionalMobility = ferz;
                break;
            case 6:
                additionalMobility = (x1, y1, x2, y2) => xd === yd && x2 > x1 && x2 <= x1 + 2 && y2 > y1 && y2 <= y1 + 2;
                break;
            case 8:
                additionalMobility = (x1, y1, x2, y2) => xd === yd && x2 < x1 && x2 >= x1 - 2 && y2 > y1 && y2 <= y1 + 2;
                break;
            default: additionalMobility = () => false;
        }
        return rook(x1, y1, x2, y2) || additionalMobility(x1, y1, x2, y2);
    };
}
function janggiKing(color, geom) {
    const palace = palaces[geom][color];
    return (x1, y1, x2, y2) => {
        const palacePos = palace.findIndex(point => point[0] === x1 && point[1] === y1);
        let additionalMobility;
        switch (palacePos) {
            case 0:
                additionalMobility = (x1, y1, x2, y2) => x2 === x1 + 1 && y2 === y1 - 1;
                break;
            case 2:
                additionalMobility = (x1, y1, x2, y2) => x2 === x1 - 1 && y2 === y1 - 1;
                break;
            case 4:
                additionalMobility = ferz;
                break;
            case 6:
                additionalMobility = (x1, y1, x2, y2) => x2 === x1 + 1 && y2 === y1 + 1;
                break;
            case 8:
                additionalMobility = (x1, y1, x2, y2) => x2 === x1 - 1 && y2 === y1 + 1;
                break;
            default: additionalMobility = () => false;
        }
        return (wazir(x1, y1, x2, y2) || additionalMobility(x1, y1, x2, y2)) && palace.some(point => (point[0] === x2 && point[1] === y2));
    };
}
const musketeerLeopard = (x1, y1, x2, y2) => {
    const xd = diff(x1, x2);
    const yd = diff(y1, y2);
    return ((xd === 1 || xd === 2)
        && (yd === 1 || yd === 2));
};
const musketeerHawk = (x1, y1, x2, y2) => {
    const xd = diff(x1, x2);
    const yd = diff(y1, y2);
    return ((xd === 0 && (yd === 2 || yd === 3))
        || (yd === 0 && (xd === 2 || xd === 3))
        || (xd === yd && (xd === 2 || xd === 3)));
};
const musketeerElephant = (x1, y1, x2, y2) => {
    const xd = diff(x1, x2);
    const yd = diff(y1, y2);
    return (xd === 1 || yd === 1
        || (xd === 2 && (yd === 0 || yd === 2))
        || (xd === 0 && yd === 2));
};
const musketeerCannon = (x1, y1, x2, y2) => {
    const xd = diff(x1, x2);
    const yd = diff(y1, y2);
    return ((xd < 3)
        && ((yd < 2) || (yd === 2 && xd === 0)));
};
const musketeerUnicorn = (x1, y1, x2, y2) => {
    const xd = diff(x1, x2);
    const yd = diff(y1, y2);
    return knight(x1, y1, x2, y2) || (xd === 1 && yd === 3) || (xd === 3 && yd === 1);
};
const musketeerDragon = (x1, y1, x2, y2) => {
    return knight(x1, y1, x2, y2) || queen(x1, y1, x2, y2);
};
const musketeerFortress = (x1, y1, x2, y2) => {
    const xd = diff(x1, x2);
    const yd = diff(y1, y2);
    return ((xd === yd && xd < 4)
        || (yd === 0 && xd === 2)
        || (yd === 2 && xd < 2));
};
const musketeerSpider = (x1, y1, x2, y2) => {
    const xd = diff(x1, x2);
    const yd = diff(y1, y2);
    return (xd < 3 && yd < 3
        && !(xd === 1 && yd === 0)
        && !(xd === 0 && yd === 1));
};
function toriGoose(color) {
    return (x1, y1, x2, y2) => {
        const xd = diff(x1, x2);
        return (color === 'white') ?
            (xd === 2 && y2 === y1 + 2) || (xd === 0 && y2 === y1 - 2)
            :
                (xd === 2 && y2 === y1 - 2) || (xd === 0 && y2 === y1 + 2);
    };
}
function toriLeftQuail(color) {
    return (x1, y1, x2, y2) => {
        const xd = diff(x1, x2);
        const yd = diff(y1, y2);
        return (color === 'white') ?
            (x2 === x1 && y2 > y1) || (xd === yd && x2 > x1 && y2 < y1) || (x2 === x1 - 1 && y2 === y1 - 1)
            :
                (x2 === x1 && y2 < y1) || (xd === yd && x2 < x1 && y2 > y1) || (x2 === x1 + 1 && y2 === y1 + 1);
    };
}
function toriRightQuail(color) {
    return (x1, y1, x2, y2) => {
        const xd = diff(x1, x2);
        const yd = diff(y1, y2);
        return (color === 'white') ?
            (x2 === x1 && y2 > y1) || (xd === yd && x2 < x1 && y2 < y1) || (x2 === x1 + 1 && y2 === y1 - 1)
            :
                (x2 === x1 && y2 < y1) || (xd === yd && x2 > x1 && y2 > y1) || (x2 === x1 - 1 && y2 === y1 + 1);
    };
}
function toriPheasant(color) {
    return (x1, y1, x2, y2) => {
        const xd = diff(x1, x2);
        return (color === 'white') ?
            (x2 === x1 && y2 === y1 + 2) || (xd === 1 && y2 === y1 - 1)
            :
                (x2 === x1 && y2 === y1 - 2) || (xd === 1 && y2 === y1 + 1);
    };
}
const toriCrane = (x1, y1, x2, y2) => {
    return kingNoCastling(x1, y1, x2, y2) && y2 !== y1;
};
function toriFalcon(color) {
    return (x1, y1, x2, y2) => {
        return (color === 'white') ?
            kingNoCastling(x1, y1, x2, y2) && !(x2 === x1 && y2 === y1 - 1)
            :
                kingNoCastling(x1, y1, x2, y2) && !(x2 === x1 && y2 === y1 + 1);
    };
}
function toriEagle(color) {
    return (x1, y1, x2, y2) => {
        const xd = diff(x1, x2);
        const yd = diff(y1, y2);
        return (color === 'white') ?
            kingNoCastling(x1, y1, x2, y2) || (xd === yd && (y2 > y1 || (y2 < y1 && yd <= 2))) || (x2 === x1 && y2 < y1)
            :
                kingNoCastling(x1, y1, x2, y2) || (xd === yd && (y2 < y1 || (y2 > y1 && yd <= 2))) || (x2 === x1 && y2 > y1);
    };
}
function premove(pieces, key, canCastle, geom, variant, chess960) {
    const piece = pieces[key];
    const role = piece.role;
    const color = piece.color;
    const pos = util.key2pos(key);
    let mobility;
    switch (variant) {
        case 'xiangqi':
        case 'manchu':
            switch (role) {
                case 'p-piece':
                    mobility = xiangqiPawn(color);
                    break;
                case 'c-piece':
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'n-piece':
                    mobility = knight;
                    break;
                case 'b-piece':
                    mobility = xiangqiElephant(color);
                    break;
                case 'a-piece':
                    mobility = xiangqiAdvisor(color, geom);
                    break;
                case 'k-piece':
                    mobility = xiangqiKing(color, geom);
                    break;
                case 'm-piece':
                    mobility = chancellor;
                    break;
            }
            break;
        case 'janggi':
            switch (piece.role) {
                case 'p-piece':
                    mobility = janggiPawn(color, geom);
                    break;
                case 'c-piece':
                case 'r-piece':
                    mobility = janggiRook(geom);
                    break;
                case 'n-piece':
                    mobility = knight;
                    break;
                case 'b-piece':
                    mobility = janggiElephant;
                    break;
                case 'a-piece':
                case 'k-piece':
                    mobility = janggiKing(color, geom);
                    break;
            }
            break;
        case 'minixiangqi':
            {
                switch (piece.role) {
                    case 'p-piece':
                        mobility = minixiangqiPawn(color);
                        break;
                    case 'c-piece':
                    case 'r-piece':
                        mobility = rook;
                        break;
                    case 'n-piece':
                        mobility = knight;
                        break;
                    case 'k-piece':
                        mobility = xiangqiKing(color, geom);
                        break;
                }
            }
            break;
        case 'shogi':
        case 'minishogi':
        case 'gorogoro':
            switch (piece.role) {
                case 'p-piece':
                    mobility = shogiPawn(color);
                    break;
                case 'l-piece':
                    mobility = shogiLance(color);
                    break;
                case 'n-piece':
                    mobility = shogiKnight(color);
                    break;
                case 'k-piece':
                    mobility = kingNoCastling;
                    break;
                case 's-piece':
                    mobility = shogiSilver(color);
                    break;
                case 'pp-piece':
                case 'pl-piece':
                case 'pn-piece':
                case 'ps-piece':
                case 'g-piece':
                    mobility = shogiGold(color);
                    break;
                case 'b-piece':
                    mobility = bishop;
                    break;
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'pr-piece':
                    mobility = shogiDragon;
                    break;
                case 'pb-piece':
                    mobility = shogiHorse;
                    break;
            }
            ;
            break;
        case 'kyotoshogi':
            switch (piece.role) {
                case 'l-piece':
                    mobility = shogiLance(color);
                    break;
                case 'pl-piece':
                    mobility = shogiGold(color);
                    break;
                case 's-piece':
                    mobility = shogiSilver(color);
                    break;
                case 'ps-piece':
                    mobility = bishop;
                    break;
                case 'n-piece':
                    mobility = shogiKnight(color);
                    break;
                case 'pn-piece':
                    mobility = shogiGold(color);
                    break;
                case 'p-piece':
                    mobility = shogiPawn(color);
                    break;
                case 'pp-piece':
                    mobility = rook;
                    break;
                case 'k-piece':
                    mobility = kingNoCastling;
                    break;
            }
            ;
            break;
        case 'dobutsu':
            switch (piece.role) {
                case 'c-piece':
                    mobility = shogiPawn(color);
                    break;
                case 'e-piece':
                    mobility = ferz;
                    break;
                case 'g-piece':
                    mobility = wazir;
                    break;
                case 'l-piece':
                    mobility = kingNoCastling;
                    break;
                case 'pc-piece':
                    mobility = shogiGold(color);
                    break;
            }
            break;
        case 'torishogi':
            switch (role) {
                case 's-piece':
                    mobility = shogiPawn(color);
                    break;
                case 'ps-piece':
                    mobility = toriGoose(color);
                    break;
                case 'l-piece':
                    mobility = toriLeftQuail(color);
                    break;
                case 'r-piece':
                    mobility = toriRightQuail(color);
                    break;
                case 'p-piece':
                    mobility = toriPheasant(color);
                    break;
                case 'c-piece':
                    mobility = toriCrane;
                    break;
                case 'f-piece':
                    mobility = toriFalcon(color);
                    break;
                case 'pf-piece':
                    mobility = toriEagle(color);
                    break;
                case 'k-piece':
                    mobility = kingNoCastling;
                    break;
            }
            break;
        case 'makruk':
        case 'makpong':
        case 'sittuyin':
        case 'cambodian':
            switch (role) {
                case 'p-piece':
                    mobility = pawn(color);
                    break;
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'n-piece':
                    mobility = knight;
                    break;
                case 's-piece':
                    mobility = shogiSilver(color);
                    break;
                case 'f-piece':
                case 'm-piece':
                    mobility = ferz;
                    break;
                case 'k-piece':
                    mobility = kingNoCastling;
                    break;
            }
            break;
        case 'grand':
        case 'grandhouse':
            switch (role) {
                case 'p-piece':
                    mobility = grandPawn(color);
                    break;
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'n-piece':
                    mobility = knight;
                    break;
                case 'b-piece':
                    mobility = bishop;
                    break;
                case 'q-piece':
                    mobility = queen;
                    break;
                case 'c-piece':
                    mobility = chancellor;
                    break;
                case 'a-piece':
                    mobility = archbishop;
                    break;
                case 'k-piece':
                    mobility = kingNoCastling;
                    break;
            }
            break;
        case 'shako':
            switch (role) {
                case 'p-piece':
                    mobility = grandPawn(color);
                    break;
                case 'c-piece':
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'n-piece':
                    mobility = knight;
                    break;
                case 'b-piece':
                    mobility = bishop;
                    break;
                case 'q-piece':
                    mobility = queen;
                    break;
                case 'e-piece':
                    mobility = shakoElephant;
                    break;
                case 'k-piece':
                    mobility = kingShako(color, rookFilesOfShako(pieces, color), canCastle);
                    break;
            }
            break;
        case 'shogun':
            switch (role) {
                case 'p-piece':
                    mobility = pawn(color);
                    break;
                case 'pp-piece':
                    mobility = kingNoCastling;
                    break;
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'pr-piece':
                    mobility = chancellor;
                    break;
                case 'n-piece':
                    mobility = knight;
                    break;
                case 'pn-piece':
                    mobility = centaur;
                    break;
                case 'b-piece':
                    mobility = bishop;
                    break;
                case 'pb-piece':
                    mobility = archbishop;
                    break;
                case 'f-piece':
                    mobility = ferz;
                    break;
                case 'pf-piece':
                    mobility = queen;
                    break;
                case 'k-piece':
                    mobility = king(color, rookFilesOf(pieces, color), canCastle);
                    break;
            }
            break;
        case 'orda':
        case 'ordamirror':
            switch (role) {
                case 'p-piece':
                    mobility = pawn(color);
                    break;
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'n-piece':
                    mobility = knight;
                    break;
                case 'b-piece':
                    mobility = bishop;
                    break;
                case 'q-piece':
                    mobility = queen;
                    break;
                case 'l-piece':
                    mobility = chancellor;
                    break;
                case 'h-piece':
                    mobility = centaur;
                    break;
                case 'a-piece':
                    mobility = archbishop;
                    break;
                case 'y-piece':
                    mobility = shogiSilver(color);
                    break;
                case 'f-piece':
                    mobility = amazon;
                    break;
                case 'k-piece':
                    mobility = king(color, rookFilesOf(pieces, color), canCastle);
                    break;
            }
            break;
        case 'synochess':
            switch (role) {
                case 'p-piece':
                    mobility = pawn(color);
                    break;
                case 'c-piece':
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'n-piece':
                    mobility = knight;
                    break;
                case 'b-piece':
                    mobility = bishop;
                    break;
                case 'q-piece':
                    mobility = queen;
                    break;
                case 's-piece':
                    mobility = minixiangqiPawn(color);
                    break;
                case 'e-piece':
                    mobility = shakoElephant;
                    break;
                case 'a-piece':
                    mobility = kingNoCastling;
                    break;
                case 'k-piece':
                    mobility = king(color, rookFilesOf(pieces, color), canCastle && color === 'white');
                    break;
            }
            break;
        case 'musketeer':
            switch (role) {
                case 'p-piece':
                    mobility = pawn(color);
                    break;
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'n-piece':
                    mobility = knight;
                    break;
                case 'b-piece':
                    mobility = bishop;
                    break;
                case 'q-piece':
                    mobility = queen;
                    break;
                case 'l-piece':
                    mobility = musketeerLeopard;
                    break;
                case 'o-piece':
                    mobility = musketeerCannon;
                    break;
                case 'u-piece':
                    mobility = musketeerUnicorn;
                    break;
                case 'd-piece':
                    mobility = musketeerDragon;
                    break;
                case 'c-piece':
                    mobility = chancellor;
                    break;
                case 'a-piece':
                    mobility = archbishop;
                    break;
                case 'e-piece':
                    mobility = musketeerElephant;
                    break;
                case 'h-piece': mobility = musketeerHawk;
                case 'f-piece': mobility = musketeerFortress;
                case 's-piece': mobility = musketeerSpider;
                case 'k-piece':
                    mobility = king(color, rookFilesOf(pieces, color), canCastle);
                    break;
            }
            break;
        case 'hoppelpoppel':
            switch (role) {
                case 'p-piece':
                    mobility = pawn(color);
                    break;
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'n-piece':
                case 'b-piece':
                    mobility = archbishop;
                    break;
                case 'q-piece':
                    mobility = queen;
                    break;
                case 'k-piece':
                    mobility = king(color, rookFilesOf(pieces, color), canCastle);
                    break;
            }
            break;
        case 'shinobi':
            switch (role) {
                case 'p-piece':
                    mobility = pawn(color);
                    break;
                case 'pl-piece':
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'ph-piece':
                case 'n-piece':
                    mobility = knight;
                    break;
                case 'pm-piece':
                case 'b-piece':
                    mobility = bishop;
                    break;
                case 'q-piece':
                    mobility = queen;
                    break;
                case 'pp-piece':
                case 'c-piece':
                    mobility = kingNoCastling;
                    break;
                case 'l-piece':
                    mobility = shogiLance(color);
                    break;
                case 'h-piece':
                    mobility = shogiKnight(color);
                    break;
                case 'm-piece':
                    mobility = ferz;
                    break;
                case 'd-piece':
                    mobility = shogiDragon;
                    break;
                case 'j-piece':
                    mobility = archbishop;
                    break;
                case 'k-piece':
                    mobility = king(color, rookFilesOf(pieces, color), canCastle);
                    break;
            }
            break;
        case 'empire':
            switch (role) {
                case 'p-piece':
                    mobility = pawn(color);
                    break;
                case 's-piece':
                    mobility = minixiangqiPawn(color);
                    break;
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'n-piece':
                    mobility = knight;
                    break;
                case 'b-piece':
                    mobility = bishop;
                    break;
                case 'd-piece':
                case 't-piece':
                case 'c-piece':
                case 'q-piece':
                    mobility = queen;
                    break;
                case 'e-piece':
                    mobility = amazon;
                    break;
                case 'k-piece':
                    mobility = king(color, rookFilesOf(pieces, color), canCastle);
                    break;
            }
            break;
        case 'capablanca':
        case 'capahouse':
            switch (role) {
                case 'p-piece':
                    mobility = pawn(color);
                    break;
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'n-piece':
                    mobility = knight;
                    break;
                case 'b-piece':
                    mobility = bishop;
                    break;
                case 'q-piece':
                    mobility = queen;
                    break;
                case 'c-piece':
                    mobility = chancellor;
                    break;
                case 'a-piece':
                    mobility = archbishop;
                    break;
                case 'k-piece':
                    mobility = chess960 ? king960(color, rookFilesOf(pieces, color), canCastle) : kingCapa(color, rookFilesOf(pieces, color), canCastle);
                    break;
            }
            break;
        default:
            switch (role) {
                case 'p-piece':
                    mobility = pawn(color);
                    break;
                case 'r-piece':
                    mobility = rook;
                    break;
                case 'n-piece':
                    mobility = knight;
                    break;
                case 'b-piece':
                    mobility = bishop;
                    break;
                case 'q-piece':
                    mobility = queen;
                    break;
                case 'e-piece':
                case 'c-piece':
                    mobility = chancellor;
                    break;
                case 'h-piece':
                case 'a-piece':
                    mobility = archbishop;
                    break;
                case 'k-piece':
                    mobility = chess960 ? king960(color, rookFilesOf(pieces, color), canCastle) : king(color, rookFilesOf(pieces, color), canCastle);
                    break;
            }
    }
    return util.allKeys(geom).map(util.key2pos).filter(pos2 => {
        return (pos[0] !== pos2[0] || pos[1] !== pos2[1]) && mobility(pos[0], pos[1], pos2[0], pos2[1]);
    }).map(util.pos2key);
}
exports.default = premove;

},{"./types":68,"./util":69}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
const board_1 = require("./board");
const util = require("./util");
function render(s) {
    const asWhite = board_1.whitePov(s), posToTranslate = s.dom.relative ? util.posToTranslateRel : util.posToTranslateAbs(s.dom.bounds(), s.dimensions), translate = s.dom.relative ? util.translateRel : util.translateAbs, boardEl = s.dom.elements.board, pieces = s.pieces, curAnim = s.animation.current, anims = curAnim ? curAnim.plan.anims : {}, fadings = curAnim ? curAnim.plan.fadings : {}, curDrag = s.draggable.current, squares = computeSquareClasses(s), samePieces = {}, sameSquares = {}, movedPieces = {}, movedSquares = {}, piecesKeys = Object.keys(pieces);
    let k, p, el, pieceAtKey, elPieceName, anim, fading, pMvdset, pMvd, sMvdset, sMvd;
    el = boardEl.firstChild;
    while (el) {
        k = el.cgKey;
        if (isPieceNode(el)) {
            pieceAtKey = pieces[k];
            anim = anims[k];
            fading = fadings[k];
            elPieceName = el.cgPiece;
            if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {
                el.classList.remove('dragging');
                translate(el, posToTranslate(util_1.key2pos(k), asWhite, s.dimensions));
                el.cgDragging = false;
            }
            if (!fading && el.cgFading) {
                el.cgFading = false;
                el.classList.remove('fading');
            }
            if (pieceAtKey) {
                if (anim && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey, s.orientation)) {
                    const pos = util_1.key2pos(k);
                    pos[0] += anim[2];
                    pos[1] += anim[3];
                    el.classList.add('anim');
                    translate(el, posToTranslate(pos, asWhite, s.dimensions));
                }
                else if (el.cgAnimating) {
                    el.cgAnimating = false;
                    el.classList.remove('anim');
                    translate(el, posToTranslate(util_1.key2pos(k), asWhite, s.dimensions));
                    if (s.addPieceZIndex)
                        el.style.zIndex = posZIndex(util_1.key2pos(k), asWhite);
                }
                if (elPieceName === pieceNameOf(pieceAtKey, s.orientation) && (!fading || !el.cgFading)) {
                    samePieces[k] = true;
                }
                else {
                    if (fading && elPieceName === pieceNameOf(fading, s.orientation)) {
                        el.classList.add('fading');
                        el.cgFading = true;
                    }
                    else {
                        if (movedPieces[elPieceName])
                            movedPieces[elPieceName].push(el);
                        else
                            movedPieces[elPieceName] = [el];
                    }
                }
            }
            else {
                if (movedPieces[elPieceName])
                    movedPieces[elPieceName].push(el);
                else
                    movedPieces[elPieceName] = [el];
            }
        }
        else if (isSquareNode(el)) {
            const cn = el.className;
            if (squares[k] === cn)
                sameSquares[k] = true;
            else if (movedSquares[cn])
                movedSquares[cn].push(el);
            else
                movedSquares[cn] = [el];
        }
        el = el.nextSibling;
    }
    for (const sk in squares) {
        if (!sameSquares[sk]) {
            sMvdset = movedSquares[squares[sk]];
            sMvd = sMvdset && sMvdset.pop();
            const translation = posToTranslate(util_1.key2pos(sk), asWhite, s.dimensions);
            if (sMvd) {
                sMvd.cgKey = sk;
                translate(sMvd, translation);
            }
            else {
                const squareNode = util_1.createEl('square', squares[sk]);
                squareNode.cgKey = sk;
                translate(squareNode, translation);
                boardEl.insertBefore(squareNode, boardEl.firstChild);
            }
        }
    }
    for (const j in piecesKeys) {
        k = piecesKeys[j];
        p = pieces[k];
        anim = anims[k];
        if (!samePieces[k]) {
            pMvdset = movedPieces[pieceNameOf(p, s.orientation)];
            pMvd = pMvdset && pMvdset.pop();
            if (pMvd) {
                pMvd.cgKey = k;
                if (pMvd.cgFading) {
                    pMvd.classList.remove('fading');
                    pMvd.cgFading = false;
                }
                const pos = util_1.key2pos(k);
                if (s.addPieceZIndex)
                    pMvd.style.zIndex = posZIndex(pos, asWhite);
                if (anim) {
                    pMvd.cgAnimating = true;
                    pMvd.classList.add('anim');
                    pos[0] += anim[2];
                    pos[1] += anim[3];
                }
                translate(pMvd, posToTranslate(pos, asWhite, s.dimensions));
            }
            else {
                const pieceName = pieceNameOf(p, s.orientation), pieceNode = util_1.createEl('piece', pieceName), pos = util_1.key2pos(k);
                pieceNode.cgPiece = pieceName;
                pieceNode.cgKey = k;
                if (anim) {
                    pieceNode.cgAnimating = true;
                    pos[0] += anim[2];
                    pos[1] += anim[3];
                }
                translate(pieceNode, posToTranslate(pos, asWhite, s.dimensions));
                if (s.addPieceZIndex)
                    pieceNode.style.zIndex = posZIndex(pos, asWhite);
                boardEl.appendChild(pieceNode);
            }
        }
    }
    for (const i in movedPieces)
        removeNodes(s, movedPieces[i]);
    for (const i in movedSquares)
        removeNodes(s, movedSquares[i]);
}
exports.default = render;
function isPieceNode(el) {
    return el.tagName === 'PIECE';
}
function isSquareNode(el) {
    return el.tagName === 'SQUARE';
}
function removeNodes(s, nodes) {
    for (const i in nodes)
        s.dom.elements.board.removeChild(nodes[i]);
}
function posZIndex(pos, asWhite) {
    let z = 2 + (pos[1] - 1) * 8 + (8 - pos[0]);
    if (asWhite)
        z = 67 - z;
    return z + '';
}
function pieceNameOf(piece, orientation) {
    const promoted = piece.promoted ? "promoted " : "";
    const side = piece.color === orientation ? "ally" : "enemy";
    return `${piece.color} ${promoted}${piece.role} ${side}`;
}
function computeSquareClasses(s) {
    var _a, _b, _c;
    const squares = {};
    let i, k;
    if (s.lastMove && s.highlight.lastMove)
        for (i in s.lastMove) {
            if (s.lastMove[i] != 'a0') {
                addSquare(squares, s.lastMove[i], 'last-move');
            }
        }
    if (s.check && s.highlight.check)
        addSquare(squares, s.check, 'check');
    if (s.selected) {
        addSquare(squares, s.selected, 'selected');
        if (s.movable.showDests) {
            const dests = s.movable.dests && s.movable.dests[s.selected];
            if (dests)
                for (i in dests) {
                    k = dests[i];
                    addSquare(squares, k, 'move-dest' + (s.pieces[k] ? ' oc' : ''));
                }
            const pDests = s.premovable.dests;
            if (pDests)
                for (i in pDests) {
                    k = pDests[i];
                    addSquare(squares, k, 'premove-dest' + (s.pieces[k] ? ' oc' : ''));
                }
        }
    }
    else if (s.dropmode.active || ((_a = s.draggable.current) === null || _a === void 0 ? void 0 : _a.orig) === 'a0') {
        const piece = s.dropmode.active ? s.dropmode.piece : (_b = s.draggable.current) === null || _b === void 0 ? void 0 : _b.piece;
        if (piece) {
            if (s.dropmode.showDropDests) {
                const dests = (_c = s.dropmode.dropDests) === null || _c === void 0 ? void 0 : _c.get(piece.role);
                if (dests)
                    for (const k of dests) {
                        addSquare(squares, k, 'move-dest');
                    }
            }
            if (s.predroppable.showDropDests) {
                const pDests = s.predroppable.dropDests;
                if (pDests)
                    for (const k of pDests) {
                        addSquare(squares, k, 'premove-dest' + (s.pieces[k] ? ' oc' : ''));
                    }
            }
        }
    }
    const premove = s.premovable.current;
    if (premove)
        for (i in premove)
            addSquare(squares, premove[i], 'current-premove');
    else if (s.predroppable.current)
        addSquare(squares, s.predroppable.current.key, 'current-premove');
    const o = s.exploding;
    if (o)
        for (i in o.keys)
            addSquare(squares, o.keys[i], 'exploding' + o.stage);
    return squares;
}
function addSquare(squares, key, klass) {
    if (squares[key])
        squares[key] += ' ' + klass;
    else
        squares[key] = klass;
}

},{"./board":54,"./util":69}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaults = void 0;
const fen = require("./fen");
const util_1 = require("./util");
function defaults() {
    return {
        pieces: fen.read(fen.initial),
        orientation: 'white',
        turnColor: 'white',
        coordinates: true,
        autoCastle: true,
        viewOnly: false,
        disableContextMenu: false,
        resizable: true,
        addPieceZIndex: false,
        pieceKey: false,
        highlight: {
            lastMove: true,
            check: true
        },
        animation: {
            enabled: true,
            duration: 200
        },
        movable: {
            free: true,
            color: 'both',
            showDests: true,
            events: {},
            rookCastle: true
        },
        premovable: {
            enabled: true,
            showDests: true,
            castle: true,
            events: {}
        },
        predroppable: {
            enabled: false,
            showDropDests: true,
            events: {}
        },
        draggable: {
            enabled: true,
            distance: 3,
            autoDistance: true,
            centerPiece: true,
            showGhost: true,
            deleteOnDropOff: false
        },
        dropmode: {
            active: false,
            showDropDests: true,
        },
        selectable: {
            enabled: true
        },
        stats: {
            dragged: !('ontouchstart' in window)
        },
        events: {},
        drawable: {
            enabled: true,
            visible: true,
            eraseOnClick: true,
            shapes: [],
            autoShapes: [],
            brushes: {
                green: { key: 'g', color: '#15781B', opacity: 1, lineWidth: 10 },
                red: { key: 'r', color: '#882020', opacity: 1, lineWidth: 10 },
                blue: { key: 'b', color: '#003088', opacity: 1, lineWidth: 10 },
                yellow: { key: 'y', color: '#e68f00', opacity: 1, lineWidth: 10 },
                paleBlue: { key: 'pb', color: '#003088', opacity: 0.4, lineWidth: 15 },
                paleGreen: { key: 'pg', color: '#15781B', opacity: 0.4, lineWidth: 15 },
                paleRed: { key: 'pr', color: '#882020', opacity: 0.4, lineWidth: 15 },
                paleGrey: { key: 'pgr', color: '#4a4a4a', opacity: 0.35, lineWidth: 15 }
            },
            pieces: {
                baseUrl: 'https://lichess1.org/assets/piece/cburnett/'
            },
            prevSvgHash: ''
        },
        hold: util_1.timer(),
        dimensions: { width: 8, height: 8 },
        geometry: 0,
        variant: 'chess',
        chess960: false,
        notation: 0,
    };
}
exports.defaults = defaults;

},{"./fen":62,"./util":69}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderSvg = exports.createElement = void 0;
const util_1 = require("./util");
function createElement(tagName) {
    return document.createElementNS('http://www.w3.org/2000/svg', tagName);
}
exports.createElement = createElement;
function renderSvg(state, root) {
    const d = state.drawable, curD = d.current, cur = curD && curD.mouseSq ? curD : undefined, arrowDests = {};
    d.shapes.concat(d.autoShapes).concat(cur ? [cur] : []).forEach(s => {
        if (s.dest)
            arrowDests[s.dest] = (arrowDests[s.dest] || 0) + 1;
    });
    const shapes = d.shapes.concat(d.autoShapes).map((s) => {
        return {
            shape: s,
            current: false,
            hash: shapeHash(s, arrowDests, false)
        };
    });
    if (cur)
        shapes.push({
            shape: cur,
            current: true,
            hash: shapeHash(cur, arrowDests, true)
        });
    const fullHash = shapes.map(sc => sc.hash).join('');
    if (fullHash === state.drawable.prevSvgHash)
        return;
    state.drawable.prevSvgHash = fullHash;
    const defsEl = root.firstChild;
    syncDefs(d, shapes, defsEl);
    syncShapes(state, shapes, d.brushes, arrowDests, root, defsEl);
}
exports.renderSvg = renderSvg;
function syncDefs(d, shapes, defsEl) {
    const brushes = {};
    let brush;
    shapes.forEach(s => {
        if (s.shape.dest) {
            brush = d.brushes[s.shape.brush];
            if (s.shape.modifiers)
                brush = makeCustomBrush(brush, s.shape.modifiers);
            brushes[brush.key] = brush;
        }
    });
    const keysInDom = {};
    let el = defsEl.firstChild;
    while (el) {
        keysInDom[el.getAttribute('cgKey')] = true;
        el = el.nextSibling;
    }
    for (let key in brushes) {
        if (!keysInDom[key])
            defsEl.appendChild(renderMarker(brushes[key]));
    }
}
function syncShapes(state, shapes, brushes, arrowDests, root, defsEl) {
    const bounds = state.dom.bounds(), hashesInDom = {}, toRemove = [];
    shapes.forEach(sc => { hashesInDom[sc.hash] = false; });
    let el = defsEl.nextSibling, elHash;
    while (el) {
        elHash = el.getAttribute('cgHash');
        if (hashesInDom.hasOwnProperty(elHash))
            hashesInDom[elHash] = true;
        else
            toRemove.push(el);
        el = el.nextSibling;
    }
    toRemove.forEach(el => root.removeChild(el));
    shapes.forEach(sc => {
        if (!hashesInDom[sc.hash])
            root.appendChild(renderShape(state, sc, brushes, arrowDests, bounds));
    });
}
function shapeHash({ orig, dest, brush, piece, modifiers }, arrowDests, current) {
    return [current, orig, dest, brush, dest && arrowDests[dest] > 1,
        piece && pieceHash(piece),
        modifiers && modifiersHash(modifiers)
    ].filter(x => x).join('');
}
function pieceHash(piece) {
    return [piece.color, piece.role, piece.scale].filter(x => x).join('');
}
function modifiersHash(m) {
    return '' + (m.lineWidth || '');
}
function renderShape(state, { shape, current, hash }, brushes, arrowDests, bounds) {
    let el;
    if (shape.piece)
        el = renderPiece(state.drawable.pieces.baseUrl, orient(util_1.key2pos(shape.orig), state.orientation, state.dimensions), shape.piece, bounds, state.dimensions, state.orientation);
    else {
        const orig = orient(util_1.key2pos(shape.orig), state.orientation, state.dimensions);
        if (shape.orig && shape.dest) {
            let brush = brushes[shape.brush];
            if (shape.modifiers)
                brush = makeCustomBrush(brush, shape.modifiers);
            el = renderArrow(brush, orig, orient(util_1.key2pos(shape.dest), state.orientation, state.dimensions), current, arrowDests[shape.dest] > 1, bounds, state.dimensions);
        }
        else
            el = renderCircle(brushes[shape.brush], orig, current, bounds, state.dimensions);
    }
    el.setAttribute('cgHash', hash);
    return el;
}
function renderCircle(brush, pos, current, bounds, bd) {
    const o = pos2px(pos, bounds, bd), widths = circleWidth(bounds, bd), radius = (bounds.width / bd.width) / 2;
    return setAttributes(createElement('circle'), {
        stroke: brush.color,
        'stroke-width': widths[current ? 0 : 1],
        fill: 'none',
        opacity: opacity(brush, current),
        cx: o[0],
        cy: o[1],
        r: radius - widths[1] / 2
    });
}
function renderArrow(brush, orig, dest, current, shorten, bounds, bd) {
    const m = arrowMargin(bounds, shorten && !current, bd), a = pos2px(orig, bounds, bd), b = pos2px(dest, bounds, bd), dx = b[0] - a[0], dy = b[1] - a[1], angle = Math.atan2(dy, dx), xo = Math.cos(angle) * m, yo = Math.sin(angle) * m;
    return setAttributes(createElement('line'), {
        stroke: brush.color,
        'stroke-width': lineWidth(brush, current, bounds, bd),
        'stroke-linecap': 'round',
        'marker-end': 'url(#arrowhead-' + brush.key + ')',
        opacity: opacity(brush, current),
        x1: a[0],
        y1: a[1],
        x2: b[0] - xo,
        y2: b[1] - yo
    });
}
function renderPiece(baseUrl, pos, piece, bounds, bd, orientation) {
    const o = pos2px(pos, bounds, bd), width = bounds.width / bd.width * (piece.scale || 1), height = bounds.height / bd.height * (piece.scale || 1), name = piece.color[0] + piece.role[0].toUpperCase();
    const href = (baseUrl.endsWith('/') ? baseUrl + name + '.svg' : baseUrl);
    const side = piece.color === orientation ? "ally" : "enemy";
    return setAttributes(createElement('image'), {
        className: `${piece.role} ${piece.color} ${side}`,
        x: o[0] - width / 2,
        y: o[1] - height / 2,
        width: width,
        height: height,
        href: href
    });
}
function renderMarker(brush) {
    const marker = setAttributes(createElement('marker'), {
        id: 'arrowhead-' + brush.key,
        orient: 'auto',
        markerWidth: 4,
        markerHeight: 8,
        refX: 2.05,
        refY: 2.01
    });
    marker.appendChild(setAttributes(createElement('path'), {
        d: 'M0,0 V4 L3,2 Z',
        fill: brush.color
    }));
    marker.setAttribute('cgKey', brush.key);
    return marker;
}
function setAttributes(el, attrs) {
    for (let key in attrs)
        el.setAttribute(key, attrs[key]);
    return el;
}
function orient(pos, color, bd) {
    return color === 'white' ? pos : [bd.width + 1 - pos[0], bd.height + 1 - pos[1]];
}
function makeCustomBrush(base, modifiers) {
    const brush = {
        color: base.color,
        opacity: Math.round(base.opacity * 10) / 10,
        lineWidth: Math.round(modifiers.lineWidth || base.lineWidth)
    };
    brush.key = [base.key, modifiers.lineWidth].filter(x => x).join('');
    return brush;
}
function circleWidth(bounds, bd) {
    const base = bounds.width / (bd.width * 64);
    return [3 * base, 4 * base];
}
function lineWidth(brush, current, bounds, bd) {
    return (brush.lineWidth || 10) * (current ? 0.85 : 1) / (bd.width * 64) * bounds.width;
}
function opacity(brush, current) {
    return (brush.opacity || 1) * (current ? 0.9 : 1);
}
function arrowMargin(bounds, shorten, bd) {
    return (shorten ? 20 : 10) / (bd.width * 64) * bounds.width;
}
function pos2px(pos, bounds, bd) {
    return [(pos[0] - 0.5) * bounds.width / bd.width, (bd.height + 0.5 - pos[1]) * bounds.height / bd.height];
}

},{"./util":69}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shogiVariants = exports.dimensions = exports.letters = exports.ranks10 = exports.ranks = exports.files = void 0;
exports.files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];
exports.ranks = ['1', '2', '3', '4', '5', '6', '7', '8', '9', ':'];
exports.ranks10 = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
exports.letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
;
;
exports.dimensions = [{ width: 8, height: 8 }, { width: 9, height: 9 }, { width: 10, height: 8 }, { width: 9, height: 10 }, { width: 10, height: 10 }, { width: 5, height: 5 }, { width: 7, height: 7 }, { width: 3, height: 4 }, { width: 5, height: 6 }];
exports.shogiVariants = ['shogi', 'minishogi', 'kyotoshogi', 'dobutsu', 'gorogoro', 'torishogi'];

},{}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEl = exports.isRightButton = exports.eventPosition = exports.setVisible = exports.translateRel = exports.translateAbs = exports.posToTranslateRel = exports.posToTranslateAbs = exports.samePiece = exports.distanceSq = exports.containsX = exports.opposite = exports.timer = exports.memo = exports.key2pos = exports.pos2key = exports.allKeys = exports.invNRanks = exports.NRanks = exports.colors = void 0;
const cg = require("./types");
exports.colors = ['white', 'black'];
exports.NRanks = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
exports.invNRanks = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
function files(n) {
    return cg.files.slice(0, n);
}
function ranks(n) {
    return cg.ranks.slice(0, n);
}
function allKeys(geom) {
    const bd = cg.dimensions[geom];
    return Array.prototype.concat(...files(bd.width).map(c => ranks(bd.height).map(r => c + r)));
}
exports.allKeys = allKeys;
function pos2key(pos) {
    return (cg.files[pos[0] - 1] + cg.ranks[pos[1] - 1]);
}
exports.pos2key = pos2key;
function key2pos(k) {
    return [k.charCodeAt(0) - 96, k.charCodeAt(1) - 48];
}
exports.key2pos = key2pos;
function memo(f) {
    let v;
    const ret = () => {
        if (v === undefined)
            v = f();
        return v;
    };
    ret.clear = () => { v = undefined; };
    return ret;
}
exports.memo = memo;
const timer = () => {
    let startAt;
    return {
        start() { startAt = performance.now(); },
        cancel() { startAt = undefined; },
        stop() {
            if (!startAt)
                return 0;
            const time = performance.now() - startAt;
            startAt = undefined;
            return time;
        }
    };
};
exports.timer = timer;
const opposite = (c) => c === 'white' ? 'black' : 'white';
exports.opposite = opposite;
function containsX(xs, x) {
    return xs !== undefined && xs.indexOf(x) !== -1;
}
exports.containsX = containsX;
const distanceSq = (pos1, pos2) => {
    return Math.pow(pos1[0] - pos2[0], 2) + Math.pow(pos1[1] - pos2[1], 2);
};
exports.distanceSq = distanceSq;
const samePiece = (p1, p2) => p1.role === p2.role && p1.color === p2.color;
exports.samePiece = samePiece;
const posToTranslateBase = (pos, asWhite, xFactor, yFactor, bt) => [
    (asWhite ? pos[0] - 1 : bt.width - pos[0]) * xFactor,
    (asWhite ? bt.height - pos[1] : pos[1] - 1) * yFactor
];
const posToTranslateAbs = (bounds, bt) => {
    const xFactor = bounds.width / bt.width, yFactor = bounds.height / bt.height;
    return (pos, asWhite) => posToTranslateBase(pos, asWhite, xFactor, yFactor, bt);
};
exports.posToTranslateAbs = posToTranslateAbs;
const posToTranslateRel = (pos, asWhite, bt) => posToTranslateBase(pos, asWhite, 100 / bt.width, 100 / bt.height, bt);
exports.posToTranslateRel = posToTranslateRel;
const translateAbs = (el, pos) => {
    el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;
};
exports.translateAbs = translateAbs;
const translateRel = (el, percents) => {
    el.style.transform = `translate(${percents[0]}%,${percents[1]}%)`;
};
exports.translateRel = translateRel;
const setVisible = (el, v) => {
    el.style.visibility = v ? 'visible' : 'hidden';
};
exports.setVisible = setVisible;
const eventPosition = e => {
    if (e.clientX || e.clientX === 0)
        return [e.clientX, e.clientY];
    if (e.touches && e.targetTouches[0])
        return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];
    return undefined;
};
exports.eventPosition = eventPosition;
const isRightButton = (e) => e.buttons === 2 || e.button === 2;
exports.isRightButton = isRightButton;
const createEl = (tagName, className) => {
    const el = document.createElement(tagName);
    if (className)
        el.className = className;
    return el;
};
exports.createEl = createEl;

},{"./types":68}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
const types_1 = require("./types");
const svg_1 = require("./svg");
function wrap(element, s, relative) {
    element.innerHTML = '';
    element.classList.add('cg-wrap');
    util_1.colors.forEach(c => element.classList.toggle('orientation-' + c, s.orientation === c));
    element.classList.toggle('manipulable', !s.viewOnly);
    const helper = util_1.createEl('cg-helper');
    element.appendChild(helper);
    const container = util_1.createEl('cg-container');
    helper.appendChild(container);
    const extension = util_1.createEl('extension');
    container.appendChild(extension);
    const board = util_1.createEl('cg-board');
    container.appendChild(board);
    let svg;
    if (s.drawable.visible && !relative) {
        svg = svg_1.createElement('svg');
        svg.appendChild(svg_1.createElement('defs'));
        container.appendChild(svg);
    }
    if (s.coordinates) {
        const orientClass = s.orientation === 'black' ? ' black' : '';
        const shogi = (types_1.shogiVariants.includes(s.variant));
        if (shogi) {
            container.appendChild(renderCoords(types_1.ranks.slice(0, s.dimensions.height).reverse(), 'files' + orientClass));
            container.appendChild(renderCoords(types_1.ranks.slice(0, s.dimensions.width).reverse(), 'ranks' + orientClass));
        }
        else if (s.notation === 6) {
            container.appendChild(renderCoords((['0']).concat(types_1.ranks.slice(0, 9).reverse()), 'ranks' + orientClass));
            container.appendChild(renderCoords(types_1.ranks.slice(0, 9), 'files' + orientClass));
        }
        else {
            container.appendChild(renderCoords(types_1.ranks10.slice(0, s.dimensions.height), 'ranks' + orientClass));
            container.appendChild(renderCoords(types_1.files.slice(0, s.dimensions.width), 'files' + orientClass));
        }
    }
    let ghost;
    if (s.draggable.showGhost && !relative) {
        ghost = util_1.createEl('piece', 'ghost');
        util_1.setVisible(ghost, false);
        container.appendChild(ghost);
    }
    return {
        board,
        container,
        ghost,
        svg
    };
}
exports.default = wrap;
function renderCoords(elems, className) {
    const el = util_1.createEl('coords', className);
    let f;
    for (let i in elems) {
        f = util_1.createEl('coord');
        f.textContent = elems[i];
        el.appendChild(f);
    }
    return el;
}

},{"./svg":67,"./types":68,"./util":69}],71:[function(require,module,exports){
"use strict";var i18n=function(t){t=t||{},this.__version="1.0.0";var r={domain:"messages",locale:"undefined"!=typeof document&&document.documentElement.getAttribute("lang")||"en",plural_func:function(t){return{nplurals:2,plural:1!=t?1:0}},ctxt_delimiter:String.fromCharCode(4)},e=function(t){var r=typeof t;return"function"===r||"object"===r&&!!t},n={},l=t.locale||r.locale,a=t.domain||r.domain,o={},i={},u=t.ctxt_delimiter||r.ctxt_delimiter;t.messages&&(o[a]={},o[a][l]=t.messages),t.plural_forms&&(i[l]=t.plural_forms);var s=function(t){var r=arguments;return t.replace(/%%/g,"%% ").replace(/%(\d+)/g,function(t,e){return r[e]}).replace(/%% /g,"%")},p=function(t){return-1!==t.indexOf(u)?t.split(u)[1]:t},c=function(t){for(var r=[t],e=t.lastIndexOf("-");e>0;)t=t.slice(0,e),r.push(t),e=t.lastIndexOf("-");return r},f=function(t,r,e){return e.plural_form?(e.plural_func?a=e.plural_func(r):n[l]?a=n[l](r):(n[l]=function(t){if(!new RegExp("^\\s*nplurals\\s*=\\s*[0-9]+\\s*;\\s*plural\\s*=\\s*(?:\\s|[-\\?\\|&=!<>+*/%:;n0-9_()])+").test(t))throw new Error(s('The plural form "%1" is not valid',t));return new Function("n","var plural, nplurals; "+t+" return { nplurals: nplurals, plural: (plural === true ? 1 : (plural ? plural : 0)) };")}(i[l]),a=n[l](r)),(void 0===a.plural||a.plural>a.nplurals||t.length<=a.plural)&&(a.plural=0),s.apply(this,[p(t[a.plural]),r].concat(Array.prototype.slice.call(arguments,3)))):s.apply(this,[p(t[0])].concat(Array.prototype.slice.call(arguments,3)));var a};return{strfmt:s,expand_locale:c,__:function(){return this.gettext.apply(this,arguments)},_n:function(){return this.ngettext.apply(this,arguments)},_p:function(){return this.pgettext.apply(this,arguments)},setMessages:function(t,r,n,l){if(!t||!r||!n)throw new Error("You must provide a domain, a locale and messages");if("string"!=typeof t||"string"!=typeof r||!e(n))throw new Error("Invalid arguments");return l&&(i[r]=l),o[t]||(o[t]={}),o[t][r]=n,this},loadJSON:function(t,n){if(e(t)||(t=JSON.parse(t)),!t[""]||!t[""].language||!t[""]["plural-forms"])throw new Error('Wrong JSON, it must have an empty key ("") with "language" and "plural-forms" information');var l=t[""];return delete t[""],this.setMessages(n||r.domain,l.language,t,l["plural-forms"])},setLocale:function(t){return l=t,this},getLocale:function(){return l},textdomain:function(t){return t?(a=t,this):a},gettext:function(t){return this.dcnpgettext.apply(this,[void 0,void 0,t,void 0,void 0].concat(Array.prototype.slice.call(arguments,1)))},ngettext:function(t,r,e){return this.dcnpgettext.apply(this,[void 0,void 0,t,r,e].concat(Array.prototype.slice.call(arguments,3)))},pgettext:function(t,r){return this.dcnpgettext.apply(this,[void 0,t,r,void 0,void 0].concat(Array.prototype.slice.call(arguments,2)))},dcnpgettext:function(t,e,n,i,s){if(t=t||a,"string"!=typeof n)throw new Error(this.strfmt('Msgid "%1" is not a valid translatable string',n));var p,d,g,m={plural_form:!1},h=e?e+u+n:n,y=c(l);for(var v in y)if(g=y[v],d=o[t]&&o[t][g]&&o[t][g][h],d=i?d&&"string"!=typeof o[t][g][h]:d&&"string"==typeof o[t][g][h])break;return d?p=o[t][g][h]:(p=n,m.plural_func=r.plural_func),i?(m.plural_form=!0,f.apply(this,[d?p:[n,i],s,m].concat(Array.prototype.slice.call(arguments,5)))):f.apply(this,[[p],s,m].concat(Array.prototype.slice.call(arguments,5)))}}};module.exports=i18n;
},{}],72:[function(require,module,exports){
/*
 Highcharts JS v9.1.0 (2021-05-03)

 (c) 2009-2021 Torstein Honsi

 License: www.highcharts.com/license
*/
(function(W,O){"object"===typeof module&&module.exports?(O["default"]=O,module.exports=W.document?O(W):O):"function"===typeof define&&define.amd?define("highcharts/highcharts",function(){return O(W)}):(W.Highcharts&&W.Highcharts.error(16,!0),W.Highcharts=O(W))})("undefined"!==typeof window?window:this,function(W){function O(D,b,e,z){D.hasOwnProperty(b)||(D[b]=z.apply(null,e))}var e={};O(e,"Core/Globals.js",[],function(){var D="undefined"!==typeof W?W:"undefined"!==typeof window?window:{},b;(function(b){b.SVG_NS=
"http://www.w3.org/2000/svg";b.product="Highcharts";b.version="9.1.0";b.win=D;b.doc=b.win.document;b.svg=b.doc&&b.doc.createElementNS&&!!b.doc.createElementNS(b.SVG_NS,"svg").createSVGRect;b.userAgent=b.win.navigator&&b.win.navigator.userAgent||"";b.isChrome=-1!==b.userAgent.indexOf("Chrome");b.isFirefox=-1!==b.userAgent.indexOf("Firefox");b.isMS=/(edge|msie|trident)/i.test(b.userAgent)&&!b.win.opera;b.isSafari=!b.isChrome&&-1!==b.userAgent.indexOf("Safari");b.isTouchDevice=/(Mobile|Android|Windows Phone)/.test(b.userAgent);
b.isWebKit=-1!==b.userAgent.indexOf("AppleWebKit");b.deg2rad=2*Math.PI/360;b.hasBidiBug=b.isFirefox&&4>parseInt(b.userAgent.split("Firefox/")[1],10);b.hasTouch=!!b.win.TouchEvent;b.marginNames=["plotTop","marginRight","marginBottom","plotLeft"];b.noop=function(){};b.supportsPassiveEvents=function(){var D=!1;if(!b.isMS){var e=Object.defineProperty({},"passive",{get:function(){D=!0}});b.win.addEventListener&&b.win.removeEventListener&&(b.win.addEventListener("testPassive",b.noop,e),b.win.removeEventListener("testPassive",
b.noop,e))}return D}();b.charts=[];b.dateFormats={};b.seriesTypes={};b.symbolSizes={}})(b||(b={}));return b});O(e,"Core/Utilities.js",[e["Core/Globals.js"]],function(D){function b(a,c,h,r){var y=c?"Highcharts error":"Highcharts warning";32===a&&(a=y+": Deprecated member");var d=w(a),M=d?y+" #"+a+": www.highcharts.com/errors/"+a+"/":a.toString();if("undefined"!==typeof r){var t="";d&&(M+="?");n(r,function(p,a){t+="\n - "+a+": "+p;d&&(M+=encodeURI(a)+"="+encodeURI(p))});M+=t}E(Highcharts,"displayError",
{chart:h,code:a,message:M,params:r},function(){if(c)throw Error(M);g.console&&-1===b.messages.indexOf(M)&&console.warn(M)});b.messages.push(M)}function e(a,c){var y={};n(a,function(g,h){if(C(a[h],!0)&&!a.nodeType&&c[h])g=e(a[h],c[h]),Object.keys(g).length&&(y[h]=g);else if(C(a[h])||a[h]!==c[h])y[h]=a[h]});return y}function z(a,c){return parseInt(a,c||10)}function H(a){return"string"===typeof a}function G(a){a=Object.prototype.toString.call(a);return"[object Array]"===a||"[object Array Iterator]"===
a}function C(a,c){return!!a&&"object"===typeof a&&(!c||!G(a))}function B(a){return C(a)&&"number"===typeof a.nodeType}function x(a){var c=a&&a.constructor;return!(!C(a,!0)||B(a)||!c||!c.name||"Object"===c.name)}function w(a){return"number"===typeof a&&!isNaN(a)&&Infinity>a&&-Infinity<a}function v(a){return"undefined"!==typeof a&&null!==a}function f(a,c,g){var y;H(c)?v(g)?a.setAttribute(c,g):a&&a.getAttribute&&((y=a.getAttribute(c))||"class"!==c||(y=a.getAttribute(c+"Name"))):n(c,function(c,y){a.setAttribute(y,
c)});return y}function d(a,c){var y;a||(a={});for(y in c)a[y]=c[y];return a}function q(){for(var a=arguments,c=a.length,g=0;g<c;g++){var h=a[g];if("undefined"!==typeof h&&null!==h)return h}}function k(a,c){D.isMS&&!D.svg&&c&&"undefined"!==typeof c.opacity&&(c.filter="alpha(opacity="+100*c.opacity+")");d(a.style,c)}function l(a,g,h,r,m){a=c.createElement(a);g&&d(a,g);m&&k(a,{padding:"0",border:"none",margin:"0"});h&&k(a,h);r&&r.appendChild(a);return a}function N(a,c){return parseFloat(a.toPrecision(c||
14))}function u(a,c,h){var y=D.getStyle||u;if("width"===c)return c=Math.min(a.offsetWidth,a.scrollWidth),h=a.getBoundingClientRect&&a.getBoundingClientRect().width,h<c&&h>=c-1&&(c=Math.floor(h)),Math.max(0,c-(y(a,"padding-left",!0)||0)-(y(a,"padding-right",!0)||0));if("height"===c)return Math.max(0,Math.min(a.offsetHeight,a.scrollHeight)-(y(a,"padding-top",!0)||0)-(y(a,"padding-bottom",!0)||0));g.getComputedStyle||b(27,!0);if(a=g.getComputedStyle(a,void 0)){var r=a.getPropertyValue(c);q(h,"opacity"!==
c)&&(r=z(r))}return r}function n(a,c,g){for(var h in a)Object.hasOwnProperty.call(a,h)&&c.call(g||a[h],a[h],h,a)}function J(a,c,g){function h(t,p){var c=a.removeEventListener||D.removeEventListenerPolyfill;c&&c.call(a,t,p,!1)}function y(t){var p;if(a.nodeName){if(c){var g={};g[c]=!0}else g=t;n(g,function(a,c){if(t[c])for(p=t[c].length;p--;)h(c,t[c][p].fn)})}}var r="function"===typeof a&&a.prototype||a;if(Object.hasOwnProperty.call(r,"hcEvents")){var M=r.hcEvents;c?(r=M[c]||[],g?(M[c]=r.filter(function(a){return g!==
a.fn}),h(c,g)):(y(M),M[c]=[])):(y(M),delete r.hcEvents)}}function E(a,g,h,r){h=h||{};if(c.createEvent&&(a.dispatchEvent||a.fireEvent&&a!==D)){var y=c.createEvent("Events");y.initEvent(g,!0,!0);h=d(y,h);a.dispatchEvent?a.dispatchEvent(h):a.fireEvent(g,h)}else if(a.hcEvents){h.target||d(h,{preventDefault:function(){h.defaultPrevented=!0},target:a,type:g});y=[];for(var m=a,M=!1;m.hcEvents;)Object.hasOwnProperty.call(m,"hcEvents")&&m.hcEvents[g]&&(y.length&&(M=!0),y.unshift.apply(y,m.hcEvents[g])),m=
Object.getPrototypeOf(m);M&&y.sort(function(a,p){return a.order-p.order});y.forEach(function(t){!1===t.fn.call(a,h)&&h.preventDefault()})}r&&!h.defaultPrevented&&r.call(a,h)}var m=D.charts,c=D.doc,g=D.win;"";(b||(b={})).messages=[];var a;Math.easeInOutSine=function(a){return-.5*(Math.cos(Math.PI*a)-1)};var h=Array.prototype.find?function(a,c){return a.find(c)}:function(a,c){var g,h=a.length;for(g=0;g<h;g++)if(c(a[g],g))return a[g]};n({map:"map",each:"forEach",grep:"filter",reduce:"reduce",some:"some"},
function(a,c){D[c]=function(g){var h;b(32,!1,void 0,(h={},h["Highcharts."+c]="use Array."+a,h));return Array.prototype[a].apply(g,[].slice.call(arguments,1))}});var r,A=function(){var a=Math.random().toString(36).substring(2,9)+"-",c=0;return function(){return"highcharts-"+(r?"":a)+c++}}();g.jQuery&&(g.jQuery.fn.highcharts=function(){var a=[].slice.call(arguments);if(this[0])return a[0]?(new (D[H(a[0])?a.shift():"Chart"])(this[0],a[0],a[1]),this):m[f(this[0],"data-highcharts-chart")]});return{addEvent:function(a,
c,g,h){void 0===h&&(h={});var r="function"===typeof a&&a.prototype||a;Object.hasOwnProperty.call(r,"hcEvents")||(r.hcEvents={});r=r.hcEvents;D.Point&&a instanceof D.Point&&a.series&&a.series.chart&&(a.series.chart.runTrackerClick=!0);var y=a.addEventListener||D.addEventListenerPolyfill;y&&y.call(a,c,g,D.supportsPassiveEvents?{passive:void 0===h.passive?-1!==c.indexOf("touch"):h.passive,capture:!1}:!1);r[c]||(r[c]=[]);r[c].push({fn:g,order:"number"===typeof h.order?h.order:Infinity});r[c].sort(function(a,
t){return a.order-t.order});return function(){J(a,c,g)}},arrayMax:function(a){for(var c=a.length,g=a[0];c--;)a[c]>g&&(g=a[c]);return g},arrayMin:function(a){for(var c=a.length,g=a[0];c--;)a[c]<g&&(g=a[c]);return g},attr:f,clamp:function(a,c,g){return a>c?a<g?a:g:c},cleanRecursively:e,clearTimeout:function(a){v(a)&&clearTimeout(a)},correctFloat:N,createElement:l,css:k,defined:v,destroyObjectProperties:function(a,c){n(a,function(g,h){g&&g!==c&&g.destroy&&g.destroy();delete a[h]})},discardElement:function(c){a||
(a=l("div"));c&&a.appendChild(c);a.innerHTML=""},erase:function(a,c){for(var g=a.length;g--;)if(a[g]===c){a.splice(g,1);break}},error:b,extend:d,extendClass:function(a,c){var g=function(){};g.prototype=new a;d(g.prototype,c);return g},find:h,fireEvent:E,getMagnitude:function(a){return Math.pow(10,Math.floor(Math.log(a)/Math.LN10))},getNestedProperty:function(a,c){for(a=a.split(".");a.length&&v(c);){var h=a.shift();if("undefined"===typeof h||"__proto__"===h)return;c=c[h];if(!v(c)||"function"===typeof c||
"number"===typeof c.nodeType||c===g)return}return c},getStyle:u,inArray:function(a,c,g){b(32,!1,void 0,{"Highcharts.inArray":"use Array.indexOf"});return c.indexOf(a,g)},isArray:G,isClass:x,isDOMElement:B,isFunction:function(a){return"function"===typeof a},isNumber:w,isObject:C,isString:H,keys:function(a){b(32,!1,void 0,{"Highcharts.keys":"use Object.keys"});return Object.keys(a)},merge:function(){var a,c=arguments,g={},h=function(a,c){"object"!==typeof a&&(a={});n(c,function(t,p){"__proto__"!==p&&
"constructor"!==p&&(!C(t,!0)||x(t)||B(t)?a[p]=c[p]:a[p]=h(a[p]||{},t))});return a};!0===c[0]&&(g=c[1],c=Array.prototype.slice.call(c,2));var r=c.length;for(a=0;a<r;a++)g=h(g,c[a]);return g},normalizeTickInterval:function(a,c,g,h,r){var d=a;g=q(g,1);var M=a/g;c||(c=r?[1,1.2,1.5,2,2.5,3,4,5,6,8,10]:[1,2,2.5,5,10],!1===h&&(1===g?c=c.filter(function(a){return 0===a%1}):.1>=g&&(c=[1/g])));for(h=0;h<c.length&&!(d=c[h],r&&d*g>=a||!r&&M<=(c[h]+(c[h+1]||c[h]))/2);h++);return d=N(d*g,-Math.round(Math.log(.001)/
Math.LN10))},objectEach:n,offset:function(a){var h=c.documentElement;a=a.parentElement||a.parentNode?a.getBoundingClientRect():{top:0,left:0,width:0,height:0};return{top:a.top+(g.pageYOffset||h.scrollTop)-(h.clientTop||0),left:a.left+(g.pageXOffset||h.scrollLeft)-(h.clientLeft||0),width:a.width,height:a.height}},pad:function(a,c,g){return Array((c||2)+1-String(a).replace("-","").length).join(g||"0")+a},pick:q,pInt:z,relativeLength:function(a,c,g){return/%$/.test(a)?c*parseFloat(a)/100+(g||0):parseFloat(a)},
removeEvent:J,splat:function(a){return G(a)?a:[a]},stableSort:function(a,c){var g=a.length,h,r;for(r=0;r<g;r++)a[r].safeI=r;a.sort(function(a,g){h=c(a,g);return 0===h?a.safeI-g.safeI:h});for(r=0;r<g;r++)delete a[r].safeI},syncTimeout:function(a,c,g){if(0<c)return setTimeout(a,c,g);a.call(0,g);return-1},timeUnits:{millisecond:1,second:1E3,minute:6E4,hour:36E5,day:864E5,week:6048E5,month:24192E5,year:314496E5},uniqueKey:A,useSerialIds:function(a){return r=q(a,r)},wrap:function(a,c,g){var h=a[c];a[c]=
function(){var a=Array.prototype.slice.call(arguments),c=arguments,r=this;r.proceed=function(){h.apply(r,arguments.length?arguments:c)};a.unshift(h);a=g.apply(this,a);r.proceed=null;return a}}}});O(e,"Core/Color/Color.js",[e["Core/Globals.js"],e["Core/Utilities.js"]],function(D,b){var e=b.isNumber,z=b.merge,H=b.pInt;"";b=function(){function b(e){this.parsers=[{regex:/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,parse:function(b){return[H(b[1]),H(b[2]),
H(b[3]),parseFloat(b[4],10)]}},{regex:/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,parse:function(b){return[H(b[1]),H(b[2]),H(b[3]),1]}}];this.rgba=[];if(D.Color!==b)return new D.Color(e);if(!(this instanceof b))return new b(e);this.init(e)}b.parse=function(e){return new b(e)};b.prototype.init=function(e){var B,x;if((this.input=e=b.names[e&&e.toLowerCase?e.toLowerCase():""]||e)&&e.stops)this.stops=e.stops.map(function(f){return new b(f[1])});else{if(e&&e.charAt&&"#"===e.charAt()){var w=
e.length;e=parseInt(e.substr(1),16);7===w?B=[(e&16711680)>>16,(e&65280)>>8,e&255,1]:4===w&&(B=[(e&3840)>>4|(e&3840)>>8,(e&240)>>4|e&240,(e&15)<<4|e&15,1])}if(!B)for(x=this.parsers.length;x--&&!B;){var v=this.parsers[x];(w=v.regex.exec(e))&&(B=v.parse(w))}}this.rgba=B||[]};b.prototype.get=function(b){var B=this.input,x=this.rgba;if("undefined"!==typeof this.stops){var w=z(B);w.stops=[].concat(w.stops);this.stops.forEach(function(v,f){w.stops[f]=[w.stops[f][0],v.get(b)]})}else w=x&&e(x[0])?"rgb"===
b||!b&&1===x[3]?"rgb("+x[0]+","+x[1]+","+x[2]+")":"a"===b?x[3]:"rgba("+x.join(",")+")":B;return w};b.prototype.brighten=function(b){var B,x=this.rgba;if(this.stops)this.stops.forEach(function(w){w.brighten(b)});else if(e(b)&&0!==b)for(B=0;3>B;B++)x[B]+=H(255*b),0>x[B]&&(x[B]=0),255<x[B]&&(x[B]=255);return this};b.prototype.setOpacity=function(b){this.rgba[3]=b;return this};b.prototype.tweenTo=function(b,e){var x=this.rgba,w=b.rgba;w.length&&x&&x.length?(b=1!==w[3]||1!==x[3],e=(b?"rgba(":"rgb(")+Math.round(w[0]+
(x[0]-w[0])*(1-e))+","+Math.round(w[1]+(x[1]-w[1])*(1-e))+","+Math.round(w[2]+(x[2]-w[2])*(1-e))+(b?","+(w[3]+(x[3]-w[3])*(1-e)):"")+")"):e=b.input||"none";return e};b.names={white:"#ffffff",black:"#000000"};return b}();D.Color=b;D.color=b.parse;return b});O(e,"Core/Color/Palette.js",[],function(){return{colors:"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),backgroundColor:"#ffffff",neutralColor100:"#000000",neutralColor80:"#333333",neutralColor60:"#666666",
neutralColor40:"#999999",neutralColor20:"#cccccc",neutralColor10:"#e6e6e6",neutralColor5:"#f2f2f2",neutralColor3:"#f7f7f7",highlightColor100:"#003399",highlightColor80:"#335cad",highlightColor60:"#6685c2",highlightColor20:"#ccd6eb",highlightColor10:"#e6ebf5",positiveColor:"#06b535",negativeColor:"#f21313"}});O(e,"Core/Time.js",[e["Core/Globals.js"],e["Core/Utilities.js"]],function(e,b){var D=e.win,z=b.defined,H=b.error,G=b.extend,C=b.isObject,B=b.merge,x=b.objectEach,w=b.pad,v=b.pick,f=b.splat,d=
b.timeUnits;"";b=function(){function q(d){this.options={};this.variableTimezone=this.useUTC=!1;this.Date=D.Date;this.getTimezoneOffset=this.timezoneOffsetFunction();this.update(d)}q.prototype.get=function(d,l){if(this.variableTimezone||this.timezoneOffset){var k=l.getTime(),u=k-this.getTimezoneOffset(l);l.setTime(u);d=l["getUTC"+d]();l.setTime(k);return d}return this.useUTC?l["getUTC"+d]():l["get"+d]()};q.prototype.set=function(d,l,f){if(this.variableTimezone||this.timezoneOffset){if("Milliseconds"===
d||"Seconds"===d||"Minutes"===d&&0===this.getTimezoneOffset(l)%36E5)return l["setUTC"+d](f);var u=this.getTimezoneOffset(l);u=l.getTime()-u;l.setTime(u);l["setUTC"+d](f);d=this.getTimezoneOffset(l);u=l.getTime()+d;return l.setTime(u)}return this.useUTC?l["setUTC"+d](f):l["set"+d](f)};q.prototype.update=function(d){var l=v(d&&d.useUTC,!0);this.options=d=B(!0,this.options||{},d);this.Date=d.Date||D.Date||Date;this.timezoneOffset=(this.useUTC=l)&&d.timezoneOffset;this.getTimezoneOffset=this.timezoneOffsetFunction();
this.variableTimezone=l&&!(!d.getTimezoneOffset&&!d.timezone)};q.prototype.makeTime=function(d,l,f,u,n,q){if(this.useUTC){var k=this.Date.UTC.apply(0,arguments);var m=this.getTimezoneOffset(k);k+=m;var c=this.getTimezoneOffset(k);m!==c?k+=c-m:m-36E5!==this.getTimezoneOffset(k-36E5)||e.isSafari||(k-=36E5)}else k=(new this.Date(d,l,v(f,1),v(u,0),v(n,0),v(q,0))).getTime();return k};q.prototype.timezoneOffsetFunction=function(){var d=this,l=this.options,f=l.moment||D.moment;if(!this.useUTC)return function(d){return 6E4*
(new Date(d.toString())).getTimezoneOffset()};if(l.timezone){if(f)return function(d){return 6E4*-f.tz(d,l.timezone).utcOffset()};H(25)}return this.useUTC&&l.getTimezoneOffset?function(d){return 6E4*l.getTimezoneOffset(d.valueOf())}:function(){return 6E4*(d.timezoneOffset||0)}};q.prototype.dateFormat=function(d,f,q){if(!z(f)||isNaN(f))return e.defaultOptions.lang&&e.defaultOptions.lang.invalidDate||"";d=v(d,"%Y-%m-%d %H:%M:%S");var l=this,n=new this.Date(f),k=this.get("Hours",n),N=this.get("Day",n),
m=this.get("Date",n),c=this.get("Month",n),g=this.get("FullYear",n),a=e.defaultOptions.lang,h=a&&a.weekdays,r=a&&a.shortWeekdays;n=G({a:r?r[N]:h[N].substr(0,3),A:h[N],d:w(m),e:w(m,2," "),w:N,b:a.shortMonths[c],B:a.months[c],m:w(c+1),o:c+1,y:g.toString().substr(2,2),Y:g,H:w(k),k:k,I:w(k%12||12),l:k%12||12,M:w(this.get("Minutes",n)),p:12>k?"AM":"PM",P:12>k?"am":"pm",S:w(n.getSeconds()),L:w(Math.floor(f%1E3),3)},e.dateFormats);x(n,function(a,c){for(;-1!==d.indexOf("%"+c);)d=d.replace("%"+c,"function"===
typeof a?a.call(l,f):a)});return q?d.substr(0,1).toUpperCase()+d.substr(1):d};q.prototype.resolveDTLFormat=function(d){return C(d,!0)?d:(d=f(d),{main:d[0],from:d[1],to:d[2]})};q.prototype.getTimeTicks=function(f,l,q,u){var n=this,k=[],N={};var m=new n.Date(l);var c=f.unitRange,g=f.count||1,a;u=v(u,1);if(z(l)){n.set("Milliseconds",m,c>=d.second?0:g*Math.floor(n.get("Milliseconds",m)/g));c>=d.second&&n.set("Seconds",m,c>=d.minute?0:g*Math.floor(n.get("Seconds",m)/g));c>=d.minute&&n.set("Minutes",m,
c>=d.hour?0:g*Math.floor(n.get("Minutes",m)/g));c>=d.hour&&n.set("Hours",m,c>=d.day?0:g*Math.floor(n.get("Hours",m)/g));c>=d.day&&n.set("Date",m,c>=d.month?1:Math.max(1,g*Math.floor(n.get("Date",m)/g)));if(c>=d.month){n.set("Month",m,c>=d.year?0:g*Math.floor(n.get("Month",m)/g));var h=n.get("FullYear",m)}c>=d.year&&n.set("FullYear",m,h-h%g);c===d.week&&(h=n.get("Day",m),n.set("Date",m,n.get("Date",m)-h+u+(h<u?-7:0)));h=n.get("FullYear",m);u=n.get("Month",m);var r=n.get("Date",m),A=n.get("Hours",m);
l=m.getTime();!n.variableTimezone&&n.useUTC||!z(q)||(a=q-l>4*d.month||n.getTimezoneOffset(l)!==n.getTimezoneOffset(q));l=m.getTime();for(m=1;l<q;)k.push(l),l=c===d.year?n.makeTime(h+m*g,0):c===d.month?n.makeTime(h,u+m*g):!a||c!==d.day&&c!==d.week?a&&c===d.hour&&1<g?n.makeTime(h,u,r,A+m*g):l+c*g:n.makeTime(h,u,r+m*g*(c===d.day?1:7)),m++;k.push(l);c<=d.hour&&1E4>k.length&&k.forEach(function(a){0===a%18E5&&"000000000"===n.dateFormat("%H%M%S%L",a)&&(N[a]="day")})}k.info=G(f,{higherRanks:N,totalRange:c*
g});return k};return q}();e.Time=b;return e.Time});O(e,"Core/Options.js",[e["Core/Globals.js"],e["Core/Color/Color.js"],e["Core/Color/Palette.js"],e["Core/Time.js"],e["Core/Utilities.js"]],function(e,b,I,z,H){var D=e.isTouchDevice,C=e.svg;b=b.parse;var B=H.merge;"";var x={colors:I.colors,symbols:["circle","diamond","square","triangle","triangle-down"],lang:{loading:"Loading...",months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
weekdays:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),decimalPoint:".",numericSymbols:"kMGTPE".split(""),resetZoom:"Reset zoom",resetZoomTitle:"Reset zoom level 1:1",thousandsSep:" "},global:{},time:{Date:void 0,getTimezoneOffset:void 0,timezone:void 0,timezoneOffset:0,useUTC:!0},chart:{panning:{enabled:!1,type:"x"},styledMode:!1,borderRadius:0,colorCount:10,defaultSeriesType:"line",ignoreHiddenSeries:!0,spacing:[10,10,15,10],resetZoomButton:{theme:{zIndex:6},position:{align:"right",
x:-10,y:10}},zoomBySingleTouch:!1,width:null,height:null,borderColor:I.highlightColor80,backgroundColor:I.backgroundColor,plotBorderColor:I.neutralColor20},title:{text:"Chart title",align:"center",margin:15,widthAdjust:-44},subtitle:{text:"",align:"center",widthAdjust:-44},caption:{margin:15,text:"",align:"left",verticalAlign:"bottom"},plotOptions:{},labels:{style:{position:"absolute",color:I.neutralColor80}},legend:{enabled:!0,align:"center",alignColumns:!0,layout:"horizontal",labelFormatter:function(){return this.name},
borderColor:I.neutralColor40,borderRadius:0,navigation:{activeColor:I.highlightColor100,inactiveColor:I.neutralColor20},itemStyle:{color:I.neutralColor80,cursor:"pointer",fontSize:"12px",fontWeight:"bold",textOverflow:"ellipsis"},itemHoverStyle:{color:I.neutralColor100},itemHiddenStyle:{color:I.neutralColor20},shadow:!1,itemCheckboxStyle:{position:"absolute",width:"13px",height:"13px"},squareSymbol:!0,symbolPadding:5,verticalAlign:"bottom",x:0,y:0,title:{style:{fontWeight:"bold"}}},loading:{labelStyle:{fontWeight:"bold",
position:"relative",top:"45%"},style:{position:"absolute",backgroundColor:I.backgroundColor,opacity:.5,textAlign:"center"}},tooltip:{enabled:!0,animation:C,borderRadius:3,dateTimeLabelFormats:{millisecond:"%A, %b %e, %H:%M:%S.%L",second:"%A, %b %e, %H:%M:%S",minute:"%A, %b %e, %H:%M",hour:"%A, %b %e, %H:%M",day:"%A, %b %e, %Y",week:"Week from %A, %b %e, %Y",month:"%B %Y",year:"%Y"},footerFormat:"",padding:8,snap:D?25:10,headerFormat:'<span style="font-size: 10px">{point.key}</span><br/>',pointFormat:'<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
backgroundColor:b(I.neutralColor3).setOpacity(.85).get(),borderWidth:1,shadow:!0,style:{color:I.neutralColor80,cursor:"default",fontSize:"12px",whiteSpace:"nowrap"}},credits:{enabled:!0,href:"https://www.highcharts.com?credits",position:{align:"right",x:-10,verticalAlign:"bottom",y:-5},style:{cursor:"pointer",color:I.neutralColor40,fontSize:"9px"},text:"Highcharts.com"}};x.chart.styledMode=!1;"";var w=new z(B(x.global,x.time));return{defaultOptions:x,defaultTime:w,getOptions:function(){return x},
setOptions:function(v){B(!0,x,v);if(v.time||v.global)e.time?e.time.update(B(x.global,x.time,v.global,v.time)):e.time=w;return x}}});O(e,"Core/Animation/Fx.js",[e["Core/Color/Color.js"],e["Core/Globals.js"],e["Core/Utilities.js"]],function(e,b,I){var D=e.parse,H=b.win,G=I.isNumber,C=I.objectEach;return function(){function b(b,w,v){this.pos=NaN;this.options=w;this.elem=b;this.prop=v}b.prototype.dSetter=function(){var b=this.paths,w=b&&b[0];b=b&&b[1];var v=this.now||0,f=[];if(1!==v&&w&&b)if(w.length===
b.length&&1>v)for(var d=0;d<b.length;d++){for(var q=w[d],k=b[d],l=[],N=0;N<k.length;N++){var u=q[N],n=k[N];G(u)&&G(n)&&("A"!==k[0]||4!==N&&5!==N)?l[N]=u+v*(n-u):l[N]=n}f.push(l)}else f=b;else f=this.toD||[];this.elem.attr("d",f,void 0,!0)};b.prototype.update=function(){var b=this.elem,w=this.prop,v=this.now,f=this.options.step;if(this[w+"Setter"])this[w+"Setter"]();else b.attr?b.element&&b.attr(w,v,null,!0):b.style[w]=v+this.unit;f&&f.call(b,v,this)};b.prototype.run=function(e,w,v){var f=this,d=f.options,
q=function(d){return q.stopped?!1:f.step(d)},k=H.requestAnimationFrame||function(d){setTimeout(d,13)},l=function(){for(var d=0;d<b.timers.length;d++)b.timers[d]()||b.timers.splice(d--,1);b.timers.length&&k(l)};e!==w||this.elem["forceAnimate:"+this.prop]?(this.startTime=+new Date,this.start=e,this.end=w,this.unit=v,this.now=this.start,this.pos=0,q.elem=this.elem,q.prop=this.prop,q()&&1===b.timers.push(q)&&k(l)):(delete d.curAnim[this.prop],d.complete&&0===Object.keys(d.curAnim).length&&d.complete.call(this.elem))};
b.prototype.step=function(b){var w=+new Date,v=this.options,f=this.elem,d=v.complete,q=v.duration,k=v.curAnim;if(f.attr&&!f.element)b=!1;else if(b||w>=q+this.startTime){this.now=this.end;this.pos=1;this.update();var l=k[this.prop]=!0;C(k,function(d){!0!==d&&(l=!1)});l&&d&&d.call(f);b=!1}else this.pos=v.easing((w-this.startTime)/q),this.now=this.start+(this.end-this.start)*this.pos,this.update(),b=!0;return b};b.prototype.initPath=function(b,w,v){function f(d,m){for(;d.length<J;){var c=d[0],g=m[J-
d.length];g&&"M"===c[0]&&(d[0]="C"===g[0]?["C",c[1],c[2],c[1],c[2],c[1],c[2]]:["L",c[1],c[2]]);d.unshift(c);l&&(c=d.pop(),d.push(d[d.length-1],c))}}function d(d,m){for(;d.length<J;)if(m=d[Math.floor(d.length/N)-1].slice(),"C"===m[0]&&(m[1]=m[5],m[2]=m[6]),l){var c=d[Math.floor(d.length/N)].slice();d.splice(d.length/2,0,m,c)}else d.push(m)}var q=b.startX,k=b.endX;v=v.slice();var l=b.isArea,N=l?2:1;w=w&&w.slice();if(!w)return[v,v];if(q&&k&&k.length){for(b=0;b<q.length;b++)if(q[b]===k[0]){var u=b;break}else if(q[0]===
k[k.length-q.length+b]){u=b;var n=!0;break}else if(q[q.length-1]===k[k.length-q.length+b]){u=q.length-b;break}"undefined"===typeof u&&(w=[])}if(w.length&&G(u)){var J=v.length+u*N;n?(f(w,v),d(v,w)):(f(v,w),d(w,v))}return[w,v]};b.prototype.fillSetter=function(){b.prototype.strokeSetter.apply(this,arguments)};b.prototype.strokeSetter=function(){this.elem.attr(this.prop,D(this.start).tweenTo(D(this.end),this.pos),null,!0)};b.timers=[];return b}()});O(e,"Core/Animation/AnimationUtilities.js",[e["Core/Animation/Fx.js"],
e["Core/Utilities.js"]],function(e,b){function D(d){return x(d)?w({duration:500,defer:0},d):{duration:d?500:0,defer:0}}function z(d,f){for(var q=e.timers.length;q--;)e.timers[q].elem!==d||f&&f!==e.timers[q].prop||(e.timers[q].stopped=!0)}var H=b.defined,G=b.getStyle,C=b.isArray,B=b.isNumber,x=b.isObject,w=b.merge,v=b.objectEach,f=b.pick;return{animate:function(d,f,k){var l,q="",u,n;if(!x(k)){var b=arguments;k={duration:b[2],easing:b[3],complete:b[4]}}B(k.duration)||(k.duration=400);k.easing="function"===
typeof k.easing?k.easing:Math[k.easing]||Math.easeInOutSine;k.curAnim=w(f);v(f,function(b,m){z(d,m);n=new e(d,k,m);u=void 0;"d"===m&&C(f.d)?(n.paths=n.initPath(d,d.pathArray,f.d),n.toD=f.d,l=0,u=1):d.attr?l=d.attr(m):(l=parseFloat(G(d,m))||0,"opacity"!==m&&(q="px"));u||(u=b);"string"===typeof u&&u.match("px")&&(u=u.replace(/px/g,""));n.run(l,u,q)})},animObject:D,getDeferredAnimation:function(d,f,b){var l=D(f),q=0,u=0;(b?[b]:d.series).forEach(function(d){d=D(d.options.animation);q=f&&H(f.defer)?l.defer:
Math.max(q,d.duration+d.defer);u=Math.min(l.duration,d.duration)});d.renderer.forExport&&(q=0);return{defer:Math.max(0,q-u),duration:Math.min(q,u)}},setAnimation:function(d,q){q.renderer.globalAnimation=f(d,q.options.chart.animation,!0)},stop:z}});O(e,"Core/Renderer/HTML/AST.js",[e["Core/Globals.js"],e["Core/Utilities.js"]],function(e,b){var D=e.SVG_NS,z=b.attr,H=b.createElement,G=b.discardElement,C=b.error,B=b.isString,x=b.objectEach,w=b.splat;"";var v=!1;try{v=!!(new DOMParser).parseFromString("",
"text/html")}catch(f){}return function(){function f(d){this.nodes="string"===typeof d?this.parseMarkup(d):d}f.filterUserAttributes=function(d){x(d,function(q,b){var l=!0;-1===f.allowedAttributes.indexOf(b)&&(l=!1);-1!==["background","dynsrc","href","lowsrc","src"].indexOf(b)&&(l=B(q)&&f.allowedReferences.some(function(d){return 0===q.indexOf(d)}));l||(C("Highcharts warning: Invalid attribute '"+b+"' in config"),delete d[b])});return d};f.setElementHTML=function(d,q){d.innerHTML="";q&&(new f(q)).addToDOM(d)};
f.prototype.addToDOM=function(d){function q(d,l){var b;w(d).forEach(function(d){var n=d.tagName,u=d.textContent?e.doc.createTextNode(d.textContent):void 0;if(n)if("#text"===n)var k=u;else if(-1!==f.allowedTags.indexOf(n)){n=e.doc.createElementNS("svg"===n?D:l.namespaceURI||D,n);var m=d.attributes||{};x(d,function(c,g){"tagName"!==g&&"attributes"!==g&&"children"!==g&&"textContent"!==g&&(m[g]=c)});z(n,f.filterUserAttributes(m));u&&n.appendChild(u);q(d.children||[],n);k=n}else C("Highcharts warning: Invalid tagName '"+
n+"' in config");k&&l.appendChild(k);b=k});return b}return q(this.nodes,d)};f.prototype.parseMarkup=function(d){var f=[];if(v)d=(new DOMParser).parseFromString(d,"text/html");else{var b=H("div");b.innerHTML=d;d={body:b}}var l=function(d,f){var n=d.nodeName.toLowerCase(),b={tagName:n};if("#text"===n){n=d.textContent||"";if(/^[\s]*$/.test(n))return;b.textContent=n}if(n=d.attributes){var u={};[].forEach.call(n,function(c){u[c.name]=c.value});b.attributes=u}if(d.childNodes.length){var m=[];[].forEach.call(d.childNodes,
function(c){l(c,m)});m.length&&(b.children=m)}f.push(b)};[].forEach.call(d.body.childNodes,function(d){return l(d,f)});b&&G(b);return f};f.allowedTags="a b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");f.allowedAttributes=
"aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style result rowspan summary target tabindex text-align textAnchor textLength type valign width x x1 x2 y y1 y2 zIndex".split(" ");
f.allowedReferences="https:// http:// mailto: / ../ ./ #".split(" ");return f}()});O(e,"Core/FormatUtilities.js",[e["Core/Options.js"],e["Core/Utilities.js"]],function(e,b){function D(b,v,f,d){b=+b||0;v=+v;var q=z.lang,k=(b.toString().split(".")[1]||"").split("e")[0].length,l=b.toString().split("e"),N=v;if(-1===v)v=Math.min(k,20);else if(!C(v))v=2;else if(v&&l[1]&&0>l[1]){var u=v+ +l[1];0<=u?(l[0]=(+l[0]).toExponential(u).split("e")[0],v=u):(l[0]=l[0].split(".")[0]||0,b=20>v?(l[0]*Math.pow(10,l[1])).toFixed(v):
0,l[1]=0)}u=(Math.abs(l[1]?l[0]:b)+Math.pow(10,-Math.max(v,k)-1)).toFixed(v);k=String(x(u));var n=3<k.length?k.length%3:0;f=B(f,q.decimalPoint);d=B(d,q.thousandsSep);b=(0>b?"-":"")+(n?k.substr(0,n)+d:"");b=0>+l[1]&&!N?"0":b+k.substr(n).replace(/(\d{3})(?=\d)/g,"$1"+d);v&&(b+=f+u.slice(-v));l[1]&&0!==+b&&(b+="e"+l[1]);return b}var z=e.defaultOptions,H=e.defaultTime,G=b.getNestedProperty,C=b.isNumber,B=b.pick,x=b.pInt;return{dateFormat:function(b,v,f){return H.dateFormat(b,v,f)},format:function(b,v,
f){var d="{",q=!1,k=/f$/,l=/\.([0-9])/,N=z.lang,u=f&&f.time||H;f=f&&f.numberFormatter||D;for(var n=[];b;){var J=b.indexOf(d);if(-1===J)break;var E=b.slice(0,J);if(q){E=E.split(":");d=G(E.shift()||"",v);if(E.length&&"number"===typeof d)if(E=E.join(":"),k.test(E)){var m=parseInt((E.match(l)||["","-1"])[1],10);null!==d&&(d=f(d,m,N.decimalPoint,-1<E.indexOf(",")?N.thousandsSep:""))}else d=u.dateFormat(E,d);n.push(d)}else n.push(E);b=b.slice(J+1);d=(q=!q)?"}":"{"}n.push(b);return n.join("")},numberFormat:D}});
O(e,"Core/Renderer/SVG/SVGElement.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Renderer/HTML/AST.js"],e["Core/Color/Color.js"],e["Core/Globals.js"],e["Core/Color/Palette.js"],e["Core/Utilities.js"]],function(e,b,I,z,H,G){var D=e.animate,B=e.animObject,x=e.stop,w=z.deg2rad,v=z.doc,f=z.noop,d=z.svg,q=z.SVG_NS,k=z.win,l=G.addEvent,N=G.attr,u=G.createElement,n=G.css,J=G.defined,E=G.erase,m=G.extend,c=G.fireEvent,g=G.isArray,a=G.isFunction,h=G.isNumber,r=G.isString,A=G.merge,y=G.objectEach,L=
G.pick,P=G.pInt,R=G.syncTimeout,V=G.uniqueKey;e=function(){function e(){this.element=void 0;this.onEvents={};this.opacity=1;this.renderer=void 0;this.SVG_NS=q;this.symbolCustomAttribs="x y width height r start end innerR anchorX anchorY rounded".split(" ")}e.prototype._defaultGetter=function(a){a=L(this[a+"Value"],this[a],this.element?this.element.getAttribute(a):null,0);/^[\-0-9\.]+$/.test(a)&&(a=parseFloat(a));return a};e.prototype._defaultSetter=function(a,t,p){p.setAttribute(t,a)};e.prototype.add=
function(a){var t=this.renderer,p=this.element;a&&(this.parentGroup=a);this.parentInverted=a&&a.inverted;"undefined"!==typeof this.textStr&&"text"===this.element.nodeName&&t.buildText(this);this.added=!0;if(!a||a.handleZ||this.zIndex)var c=this.zIndexSetter();c||(a?a.element:t.box).appendChild(p);if(this.onAdd)this.onAdd();return this};e.prototype.addClass=function(a,t){var p=t?"":this.attr("class")||"";a=(a||"").split(/ /g).reduce(function(a,t){-1===p.indexOf(t)&&a.push(t);return a},p?[p]:[]).join(" ");
a!==p&&this.attr("class",a);return this};e.prototype.afterSetters=function(){this.doTransform&&(this.updateTransform(),this.doTransform=!1)};e.prototype.align=function(a,t,p){var c={},g=this.renderer,d=g.alignedObjects,F,h,K;if(a){if(this.alignOptions=a,this.alignByTranslate=t,!p||r(p))this.alignTo=F=p||"renderer",E(d,this),d.push(this),p=void 0}else a=this.alignOptions,t=this.alignByTranslate,F=this.alignTo;p=L(p,g[F],"scrollablePlotBox"===F?g.plotBox:void 0,g);F=a.align;var M=a.verticalAlign;g=
(p.x||0)+(a.x||0);d=(p.y||0)+(a.y||0);"right"===F?h=1:"center"===F&&(h=2);h&&(g+=(p.width-(a.width||0))/h);c[t?"translateX":"x"]=Math.round(g);"bottom"===M?K=1:"middle"===M&&(K=2);K&&(d+=(p.height-(a.height||0))/K);c[t?"translateY":"y"]=Math.round(d);this[this.placed?"animate":"attr"](c);this.placed=!0;this.alignAttr=c;return this};e.prototype.alignSetter=function(a){var t={left:"start",center:"middle",right:"end"};t[a]&&(this.alignValue=a,this.element.setAttribute("text-anchor",t[a]))};e.prototype.animate=
function(a,t,p){var c=this,g=B(L(t,this.renderer.globalAnimation,!0));t=g.defer;L(v.hidden,v.msHidden,v.webkitHidden,!1)&&(g.duration=0);0!==g.duration?(p&&(g.complete=p),R(function(){c.element&&D(c,a,g)},t)):(this.attr(a,void 0,p),y(a,function(a,p){g.step&&g.step.call(this,a,{prop:p,pos:1,elem:this})},this));return this};e.prototype.applyTextOutline=function(a){var t=this.element;-1!==a.indexOf("contrast")&&(a=a.replace(/contrast/g,this.renderer.getContrast(t.style.fill)));var p=a.split(" ");a=p[p.length-
1];if((p=p[0])&&"none"!==p&&z.svg){this.fakeTS=!0;this.ySetter=this.xSetter;p=p.replace(/(^[\d\.]+)(.*?)$/g,function(a,p,t){return 2*Number(p)+t});this.removeTextOutline();var c=v.createElementNS(q,"tspan");N(c,{"class":"highcharts-text-outline",fill:a,stroke:a,"stroke-width":p,"stroke-linejoin":"round"});[].forEach.call(t.childNodes,function(a){var p=a.cloneNode(!0);p.removeAttribute&&["fill","stroke","stroke-width","stroke"].forEach(function(a){return p.removeAttribute(a)});c.appendChild(p)});var g=
v.createElementNS(q,"tspan");g.textContent="\u200b";["x","y"].forEach(function(a){var p=t.getAttribute(a);p&&g.setAttribute(a,p)});c.appendChild(g);t.insertBefore(c,t.firstChild)}};e.prototype.attr=function(a,t,p,c){var g=this.element,d=this.symbolCustomAttribs,h,r=this,K,m;if("string"===typeof a&&"undefined"!==typeof t){var M=a;a={};a[M]=t}"string"===typeof a?r=(this[a+"Getter"]||this._defaultGetter).call(this,a,g):(y(a,function(p,t){K=!1;c||x(this,t);this.symbolName&&-1!==d.indexOf(t)&&(h||(this.symbolAttr(a),
h=!0),K=!0);!this.rotation||"x"!==t&&"y"!==t||(this.doTransform=!0);K||(m=this[t+"Setter"]||this._defaultSetter,m.call(this,p,t,g),!this.styledMode&&this.shadows&&/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(t)&&this.updateShadows(t,p,m))},this),this.afterSetters());p&&p.call(this);return r};e.prototype.clip=function(a){return this.attr("clip-path",a?"url("+this.renderer.url+"#"+a.id+")":"none")};e.prototype.crisp=function(a,t){t=t||a.strokeWidth||0;var p=Math.round(t)%2/2;a.x=Math.floor(a.x||
this.x||0)+p;a.y=Math.floor(a.y||this.y||0)+p;a.width=Math.floor((a.width||this.width||0)-2*p);a.height=Math.floor((a.height||this.height||0)-2*p);J(a.strokeWidth)&&(a.strokeWidth=t);return a};e.prototype.complexColor=function(a,t,p){var d=this.renderer,h,r,F,m,K,M,f,b,l,n,u=[],q;c(this.renderer,"complexColor",{args:arguments},function(){a.radialGradient?r="radialGradient":a.linearGradient&&(r="linearGradient");if(r){F=a[r];K=d.gradients;M=a.stops;l=p.radialReference;g(F)&&(a[r]=F={x1:F[0],y1:F[1],
x2:F[2],y2:F[3],gradientUnits:"userSpaceOnUse"});"radialGradient"===r&&l&&!J(F.gradientUnits)&&(m=F,F=A(F,d.getRadialAttr(l,m),{gradientUnits:"userSpaceOnUse"}));y(F,function(a,p){"id"!==p&&u.push(p,a)});y(M,function(a){u.push(a)});u=u.join(",");if(K[u])n=K[u].attr("id");else{F.id=n=V();var c=K[u]=d.createElement(r).attr(F).add(d.defs);c.radAttr=m;c.stops=[];M.forEach(function(a){0===a[1].indexOf("rgba")?(h=I.parse(a[1]),f=h.get("rgb"),b=h.get("a")):(f=a[1],b=1);a=d.createElement("stop").attr({offset:a[0],
"stop-color":f,"stop-opacity":b}).add(c);c.stops.push(a)})}q="url("+d.url+"#"+n+")";p.setAttribute(t,q);p.gradient=u;a.toString=function(){return q}}})};e.prototype.css=function(a){var t=this.styles,p={},c=this.element,g=["textOutline","textOverflow","width"],h="",F=!t;a&&a.color&&(a.fill=a.color);t&&y(a,function(a,c){t&&t[c]!==a&&(p[c]=a,F=!0)});if(F){t&&(a=m(t,p));if(a)if(null===a.width||"auto"===a.width)delete this.textWidth;else if("text"===c.nodeName.toLowerCase()&&a.width)var r=this.textWidth=
P(a.width);this.styles=a;r&&!d&&this.renderer.forExport&&delete a.width;if(c.namespaceURI===this.SVG_NS){var K=function(a,p){return"-"+p.toLowerCase()};y(a,function(a,p){-1===g.indexOf(p)&&(h+=p.replace(/([A-Z])/g,K)+":"+a+";")});h&&N(c,"style",h)}else n(c,a);this.added&&("text"===this.element.nodeName&&this.renderer.buildText(this),a&&a.textOutline&&this.applyTextOutline(a.textOutline))}return this};e.prototype.dashstyleSetter=function(a){var t=this["stroke-width"];"inherit"===t&&(t=1);if(a=a&&a.toLowerCase()){var p=
a.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot","3,1,1,1").replace("shortdot","1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");for(a=p.length;a--;)p[a]=""+P(p[a])*L(t,NaN);a=p.join(",").replace(/NaN/g,"none");this.element.setAttribute("stroke-dasharray",a)}};e.prototype.destroy=function(){var a=this,t=a.element||{},p=a.renderer,c=t.ownerSVGElement,g=p.isSVG&&"SPAN"===t.nodeName&&a.parentGroup||
void 0;t.onclick=t.onmouseout=t.onmouseover=t.onmousemove=t.point=null;x(a);if(a.clipPath&&c){var d=a.clipPath;[].forEach.call(c.querySelectorAll("[clip-path],[CLIP-PATH]"),function(a){-1<a.getAttribute("clip-path").indexOf(d.element.id)&&a.removeAttribute("clip-path")});a.clipPath=d.destroy()}if(a.stops){for(c=0;c<a.stops.length;c++)a.stops[c].destroy();a.stops.length=0;a.stops=void 0}a.safeRemoveChild(t);for(p.styledMode||a.destroyShadows();g&&g.div&&0===g.div.childNodes.length;)t=g.parentGroup,
a.safeRemoveChild(g.div),delete g.div,g=t;a.alignTo&&E(p.alignedObjects,a);y(a,function(p,c){a[c]&&a[c].parentGroup===a&&a[c].destroy&&a[c].destroy();delete a[c]})};e.prototype.destroyShadows=function(){(this.shadows||[]).forEach(function(a){this.safeRemoveChild(a)},this);this.shadows=void 0};e.prototype.destroyTextPath=function(a,c){var p=a.getElementsByTagName("text")[0];if(p){if(p.removeAttribute("dx"),p.removeAttribute("dy"),c.element.setAttribute("id",""),this.textPathWrapper&&p.getElementsByTagName("textPath").length){for(a=
this.textPathWrapper.element.childNodes;a.length;)p.appendChild(a[0]);p.removeChild(this.textPathWrapper.element)}}else if(a.getAttribute("dx")||a.getAttribute("dy"))a.removeAttribute("dx"),a.removeAttribute("dy");this.textPathWrapper&&(this.textPathWrapper=this.textPathWrapper.destroy())};e.prototype.dSetter=function(a,c,p){g(a)&&("string"===typeof a[0]&&(a=this.renderer.pathToSegments(a)),this.pathArray=a,a=a.reduce(function(a,p,c){return p&&p.join?(c?a+" ":"")+p.join(" "):(p||"").toString()},""));
/(NaN| {2}|^$)/.test(a)&&(a="M 0 0");this[c]!==a&&(p.setAttribute(c,a),this[c]=a)};e.prototype.fadeOut=function(a){var c=this;c.animate({opacity:0},{duration:L(a,150),complete:function(){c.attr({y:-9999}).hide()}})};e.prototype.fillSetter=function(a,c,p){"string"===typeof a?p.setAttribute(c,a):a&&this.complexColor(a,c,p)};e.prototype.getBBox=function(c,t){var p=this.renderer,g=this.element,d=this.styles,h=this.textStr,F=p.cache,r=p.cacheKeys,K=g.namespaceURI===this.SVG_NS;t=L(t,this.rotation,0);var A=
p.styledMode?g&&e.prototype.getStyle.call(g,"font-size"):d&&d.fontSize,f;if(J(h)){var b=h.toString();-1===b.indexOf("<")&&(b=b.replace(/[0-9]/g,"0"));b+=["",t,A,this.textWidth,d&&d.textOverflow,d&&d.fontWeight].join()}b&&!c&&(f=F[b]);if(!f){if(K||p.forExport){try{var y=this.fakeTS&&function(a){var p=g.querySelector(".highcharts-text-outline");p&&n(p,{display:a})};a(y)&&y("none");f=g.getBBox?m({},g.getBBox()):{width:g.offsetWidth,height:g.offsetHeight};a(y)&&y("")}catch(Y){""}if(!f||0>f.width)f={width:0,
height:0}}else f=this.htmlGetBBox();p.isSVG&&(c=f.width,p=f.height,K&&(f.height=p={"11px,17":14,"13px,20":16}[d&&d.fontSize+","+Math.round(p)]||p),t&&(d=t*w,f.width=Math.abs(p*Math.sin(d))+Math.abs(c*Math.cos(d)),f.height=Math.abs(p*Math.cos(d))+Math.abs(c*Math.sin(d))));if(b&&0<f.height){for(;250<r.length;)delete F[r.shift()];F[b]||r.push(b);F[b]=f}}return f};e.prototype.getStyle=function(a){return k.getComputedStyle(this.element||this,"").getPropertyValue(a)};e.prototype.hasClass=function(a){return-1!==
(""+this.attr("class")).split(" ").indexOf(a)};e.prototype.hide=function(a){a?this.attr({y:-9999}):this.attr({visibility:"hidden"});return this};e.prototype.htmlGetBBox=function(){return{height:0,width:0,x:0,y:0}};e.prototype.init=function(a,t){this.element="span"===t?u(t):v.createElementNS(this.SVG_NS,t);this.renderer=a;c(this,"afterInit")};e.prototype.invert=function(a){this.inverted=a;this.updateTransform();return this};e.prototype.on=function(a,c){var p=this.onEvents;if(p[a])p[a]();p[a]=l(this.element,
a,c);return this};e.prototype.opacitySetter=function(a,c,p){this.opacity=a=Number(Number(a).toFixed(3));p.setAttribute(c,a)};e.prototype.removeClass=function(a){return this.attr("class",(""+this.attr("class")).replace(r(a)?new RegExp("(^| )"+a+"( |$)"):a," ").replace(/ +/g," ").trim())};e.prototype.removeTextOutline=function(){var a=this.element.querySelector("tspan.highcharts-text-outline");a&&this.safeRemoveChild(a)};e.prototype.safeRemoveChild=function(a){var c=a.parentNode;c&&c.removeChild(a)};
e.prototype.setRadialReference=function(a){var c=this.element.gradient&&this.renderer.gradients[this.element.gradient];this.element.radialReference=a;c&&c.radAttr&&c.animate(this.renderer.getRadialAttr(a,c.radAttr));return this};e.prototype.setTextPath=function(a,c){var p=this.element,t=this.text?this.text.element:p,g={textAnchor:"text-anchor"},d=!1,F=this.textPathWrapper,r=!F;c=A(!0,{enabled:!0,attributes:{dy:-5,startOffset:"50%",textAnchor:"middle"}},c);var K=b.filterUserAttributes(c.attributes);
if(a&&c&&c.enabled){F&&null===F.element.parentNode?(r=!0,F=F.destroy()):F&&this.removeTextOutline.call(F.parentGroup);this.options&&this.options.padding&&(K.dx=-this.options.padding);F||(this.textPathWrapper=F=this.renderer.createElement("textPath"),d=!0);var m=F.element;(c=a.element.getAttribute("id"))||a.element.setAttribute("id",c=V());if(r)for(t.setAttribute("y",0),h(K.dx)&&t.setAttribute("x",-K.dx),a=[].slice.call(t.childNodes),r=0;r<a.length;r++){var l=a[r];l.nodeType!==Node.TEXT_NODE&&"tspan"!==
l.nodeName||m.appendChild(l)}d&&F&&F.add({element:t});m.setAttributeNS("http://www.w3.org/1999/xlink","href",this.renderer.url+"#"+c);J(K.dy)&&(m.parentNode.setAttribute("dy",K.dy),delete K.dy);J(K.dx)&&(m.parentNode.setAttribute("dx",K.dx),delete K.dx);y(K,function(a,p){m.setAttribute(g[p]||p,a)});p.removeAttribute("transform");this.removeTextOutline.call(F);this.text&&!this.renderer.styledMode&&this.attr({fill:"none","stroke-width":0});this.applyTextOutline=this.updateTransform=f}else F&&(delete this.updateTransform,
delete this.applyTextOutline,this.destroyTextPath(p,a),this.updateTransform(),this.options&&this.options.rotation&&this.applyTextOutline(this.options.style.textOutline));return this};e.prototype.shadow=function(a,c,p){var t=[],g=this.element,d=this.oldShadowOptions,h={color:H.neutralColor100,offsetX:1,offsetY:1,opacity:.15,width:3},r=!1,K;!0===a?K=h:"object"===typeof a&&(K=m(h,a));K&&(K&&d&&y(K,function(a,p){a!==d[p]&&(r=!0)}),r&&this.destroyShadows(),this.oldShadowOptions=K);if(!K)this.destroyShadows();
else if(!this.shadows){var A=K.opacity/K.width;var f=this.parentInverted?"translate(-1,-1)":"translate("+K.offsetX+", "+K.offsetY+")";for(h=1;h<=K.width;h++){var b=g.cloneNode(!1);var l=2*K.width+1-2*h;N(b,{stroke:a.color||H.neutralColor100,"stroke-opacity":A*h,"stroke-width":l,transform:f,fill:"none"});b.setAttribute("class",(b.getAttribute("class")||"")+" highcharts-shadow");p&&(N(b,"height",Math.max(N(b,"height")-l,0)),b.cutHeight=l);c?c.element.appendChild(b):g.parentNode&&g.parentNode.insertBefore(b,
g);t.push(b)}this.shadows=t}return this};e.prototype.show=function(a){return this.attr({visibility:a?"inherit":"visible"})};e.prototype.strokeSetter=function(a,c,p){this[c]=a;this.stroke&&this["stroke-width"]?(e.prototype.fillSetter.call(this,this.stroke,"stroke",p),p.setAttribute("stroke-width",this["stroke-width"]),this.hasStroke=!0):"stroke-width"===c&&0===a&&this.hasStroke?(p.removeAttribute("stroke"),this.hasStroke=!1):this.renderer.styledMode&&this["stroke-width"]&&(p.setAttribute("stroke-width",
this["stroke-width"]),this.hasStroke=!0)};e.prototype.strokeWidth=function(){if(!this.renderer.styledMode)return this["stroke-width"]||0;var a=this.getStyle("stroke-width"),c=0;if(a.indexOf("px")===a.length-2)c=P(a);else if(""!==a){var p=v.createElementNS(q,"rect");N(p,{width:a,"stroke-width":0});this.element.parentNode.appendChild(p);c=p.getBBox().width;p.parentNode.removeChild(p)}return c};e.prototype.symbolAttr=function(a){var c=this;"x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function(p){c[p]=
L(a[p],c[p])});c.attr({d:c.renderer.symbols[c.symbolName](c.x,c.y,c.width,c.height,c)})};e.prototype.textSetter=function(a){a!==this.textStr&&(delete this.textPxLength,this.textStr=a,this.added&&this.renderer.buildText(this))};e.prototype.titleSetter=function(a){var c=this.element,p=c.getElementsByTagName("title")[0]||v.createElementNS(this.SVG_NS,"title");c.insertBefore?c.insertBefore(p,c.firstChild):c.appendChild(p);p.textContent=String(L(a,"")).replace(/<[^>]*>/g,"").replace(/&lt;/g,"<").replace(/&gt;/g,
">")};e.prototype.toFront=function(){var a=this.element;a.parentNode.appendChild(a);return this};e.prototype.translate=function(a,c){return this.attr({translateX:a,translateY:c})};e.prototype.updateShadows=function(a,c,p){var t=this.shadows;if(t)for(var g=t.length;g--;)p.call(t[g],"height"===a?Math.max(c-(t[g].cutHeight||0),0):"d"===a?this.d:c,a,t[g])};e.prototype.updateTransform=function(){var a=this.scaleX,c=this.scaleY,p=this.inverted,g=this.rotation,d=this.matrix,h=this.element,F=this.translateX||
0,r=this.translateY||0;p&&(F+=this.width,r+=this.height);F=["translate("+F+","+r+")"];J(d)&&F.push("matrix("+d.join(",")+")");p?F.push("rotate(90) scale(-1,1)"):g&&F.push("rotate("+g+" "+L(this.rotationOriginX,h.getAttribute("x"),0)+" "+L(this.rotationOriginY,h.getAttribute("y")||0)+")");(J(a)||J(c))&&F.push("scale("+L(a,1)+" "+L(c,1)+")");F.length&&h.setAttribute("transform",F.join(" "))};e.prototype.visibilitySetter=function(a,c,p){"inherit"===a?p.removeAttribute(c):this[c]!==a&&p.setAttribute(c,
a);this[c]=a};e.prototype.xGetter=function(a){"circle"===this.element.nodeName&&("x"===a?a="cx":"y"===a&&(a="cy"));return this._defaultGetter(a)};e.prototype.zIndexSetter=function(a,c){var p=this.renderer,g=this.parentGroup,t=(g||p).element||p.box,d=this.element;p=t===p.box;var h=!1;var r=this.added;var K;J(a)?(d.setAttribute("data-z-index",a),a=+a,this[c]===a&&(r=!1)):J(this[c])&&d.removeAttribute("data-z-index");this[c]=a;if(r){(a=this.zIndex)&&g&&(g.handleZ=!0);c=t.childNodes;for(K=c.length-1;0<=
K&&!h;K--){g=c[K];r=g.getAttribute("data-z-index");var m=!J(r);if(g!==d)if(0>a&&m&&!p&&!K)t.insertBefore(d,c[K]),h=!0;else if(P(r)<=a||m&&(!J(a)||0<=a))t.insertBefore(d,c[K+1]||null),h=!0}h||(t.insertBefore(d,c[p?3:0]||null),h=!0)}return h};return e}();e.prototype["stroke-widthSetter"]=e.prototype.strokeSetter;e.prototype.yGetter=e.prototype.xGetter;e.prototype.matrixSetter=e.prototype.rotationOriginXSetter=e.prototype.rotationOriginYSetter=e.prototype.rotationSetter=e.prototype.scaleXSetter=e.prototype.scaleYSetter=
e.prototype.translateXSetter=e.prototype.translateYSetter=e.prototype.verticalAlignSetter=function(a,c){this[c]=a;this.doTransform=!0};"";return e});O(e,"Core/Renderer/SVG/SVGLabel.js",[e["Core/Renderer/SVG/SVGElement.js"],e["Core/Utilities.js"]],function(e,b){function D(b,f){C(b)?b!==this[f]&&(this[f]=b,this.updateTextPadding()):this[f]=void 0}var z=this&&this.__extends||function(){var b=function(f,d){b=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,
b){for(var f in b)b.hasOwnProperty(f)&&(d[f]=b[f])};return b(f,d)};return function(f,d){function q(){this.constructor=f}b(f,d);f.prototype=null===d?Object.create(d):(q.prototype=d.prototype,new q)}}(),H=b.defined,G=b.extend,C=b.isNumber,B=b.merge,x=b.pick,w=b.removeEvent;return function(b){function f(d,q,k,l,e,u,n,v,E,m){var c=b.call(this)||this;c.paddingSetter=D;c.paddingLeftSetter=D;c.paddingRightSetter=D;c.init(d,"g");c.textStr=q;c.x=k;c.y=l;c.anchorX=u;c.anchorY=n;c.baseline=E;c.className=m;"button"!==
m&&c.addClass("highcharts-label");m&&c.addClass("highcharts-"+m);c.text=d.text("",0,0,v).attr({zIndex:1});if("string"===typeof e){var g=/^url\((.*?)\)$/.test(e);if(c.renderer.symbols[e]||g)c.symbolKey=e}c.bBox=f.emptyBBox;c.padding=3;c.baselineOffset=0;c.needsBox=d.styledMode||g;c.deferredAttr={};c.alignFactor=0;return c}z(f,b);f.prototype.alignSetter=function(d){d={left:0,center:.5,right:1}[d];d!==this.alignFactor&&(this.alignFactor=d,this.bBox&&C(this.xSetting)&&this.attr({x:this.xSetting}))};f.prototype.anchorXSetter=
function(d,b){this.anchorX=d;this.boxAttr(b,Math.round(d)-this.getCrispAdjust()-this.xSetting)};f.prototype.anchorYSetter=function(d,b){this.anchorY=d;this.boxAttr(b,d-this.ySetting)};f.prototype.boxAttr=function(d,b){this.box?this.box.attr(d,b):this.deferredAttr[d]=b};f.prototype.css=function(d){if(d){var b={},k=void 0;d=B(d);f.textProps.forEach(function(f){"undefined"!==typeof d[f]&&(b[f]=d[f],delete d[f])});this.text.css(b);k="width"in b;"fontSize"in b||"fontWeight"in b?this.updateTextPadding():
k&&this.updateBoxSize()}return e.prototype.css.call(this,d)};f.prototype.destroy=function(){w(this.element,"mouseenter");w(this.element,"mouseleave");this.text&&this.text.destroy();this.box&&(this.box=this.box.destroy());e.prototype.destroy.call(this)};f.prototype.fillSetter=function(d,b){d&&(this.needsBox=!0);this.fill=d;this.boxAttr(b,d)};f.prototype.getBBox=function(){this.textStr&&0===this.bBox.width&&0===this.bBox.height&&this.updateBoxSize();var d=this.padding,b=x(this.paddingLeft,d);return{width:this.width,
height:this.height,x:this.bBox.x-b,y:this.bBox.y-d}};f.prototype.getCrispAdjust=function(){return this.renderer.styledMode&&this.box?this.box.strokeWidth()%2/2:(this["stroke-width"]?parseInt(this["stroke-width"],10):0)%2/2};f.prototype.heightSetter=function(d){this.heightSetting=d};f.prototype.on=function(d,b){var f=this,l=f.text,q=l&&"SPAN"===l.element.tagName?l:void 0;if(q){var u=function(l){("mouseenter"===d||"mouseleave"===d)&&l.relatedTarget instanceof Element&&(f.element.compareDocumentPosition(l.relatedTarget)&
Node.DOCUMENT_POSITION_CONTAINED_BY||q.element.compareDocumentPosition(l.relatedTarget)&Node.DOCUMENT_POSITION_CONTAINED_BY)||b.call(f.element,l)};q.on(d,u)}e.prototype.on.call(f,d,u||b);return f};f.prototype.onAdd=function(){var d=this.textStr;this.text.add(this);this.attr({text:H(d)?d:"",x:this.x,y:this.y});this.box&&H(this.anchorX)&&this.attr({anchorX:this.anchorX,anchorY:this.anchorY})};f.prototype.rSetter=function(d,b){this.boxAttr(b,d)};f.prototype.shadow=function(d){d&&!this.renderer.styledMode&&
(this.updateBoxSize(),this.box&&this.box.shadow(d));return this};f.prototype.strokeSetter=function(d,b){this.stroke=d;this.boxAttr(b,d)};f.prototype["stroke-widthSetter"]=function(d,b){d&&(this.needsBox=!0);this["stroke-width"]=d;this.boxAttr(b,d)};f.prototype["text-alignSetter"]=function(d){this.textAlign=d};f.prototype.textSetter=function(d){"undefined"!==typeof d&&this.text.attr({text:d});this.updateTextPadding()};f.prototype.updateBoxSize=function(){var d=this.text.element.style,b={},e=this.padding,
l=this.bBox=C(this.widthSetting)&&C(this.heightSetting)&&!this.textAlign||!H(this.text.textStr)?f.emptyBBox:this.text.getBBox();this.width=this.getPaddedWidth();this.height=(this.heightSetting||l.height||0)+2*e;this.baselineOffset=e+Math.min(this.renderer.fontMetrics(d&&d.fontSize,this.text).b,l.height||Infinity);this.needsBox&&(this.box||(d=this.box=this.symbolKey?this.renderer.symbol(this.symbolKey):this.renderer.rect(),d.addClass(("button"===this.className?"":"highcharts-label-box")+(this.className?
" highcharts-"+this.className+"-box":"")),d.add(this)),d=this.getCrispAdjust(),b.x=d,b.y=(this.baseline?-this.baselineOffset:0)+d,b.width=Math.round(this.width),b.height=Math.round(this.height),this.box.attr(G(b,this.deferredAttr)),this.deferredAttr={})};f.prototype.updateTextPadding=function(){var d=this.text;this.updateBoxSize();var b=this.baseline?0:this.baselineOffset,f=x(this.paddingLeft,this.padding);H(this.widthSetting)&&this.bBox&&("center"===this.textAlign||"right"===this.textAlign)&&(f+=
{center:.5,right:1}[this.textAlign]*(this.widthSetting-this.bBox.width));if(f!==d.x||b!==d.y)d.attr("x",f),d.hasBoxWidthChanged&&(this.bBox=d.getBBox(!0)),"undefined"!==typeof b&&d.attr("y",b);d.x=f;d.y=b};f.prototype.widthSetter=function(d){this.widthSetting=C(d)?d:void 0};f.prototype.getPaddedWidth=function(){var d=this.padding,b=x(this.paddingLeft,d);d=x(this.paddingRight,d);return(this.widthSetting||this.bBox.width||0)+b+d};f.prototype.xSetter=function(d){this.x=d;this.alignFactor&&(d-=this.alignFactor*
this.getPaddedWidth(),this["forceAnimate:x"]=!0);this.xSetting=Math.round(d);this.attr("translateX",this.xSetting)};f.prototype.ySetter=function(d){this.ySetting=this.y=Math.round(d);this.attr("translateY",this.ySetting)};f.emptyBBox={width:0,height:0,x:0,y:0};f.textProps="color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");return f}(e)});O(e,"Core/Renderer/SVG/TextBuilder.js",[e["Core/Globals.js"],e["Core/Utilities.js"],
e["Core/Renderer/HTML/AST.js"]],function(e,b,I){var D=e.doc,H=e.SVG_NS,G=b.attr,C=b.isString,B=b.objectEach,x=b.pick;return function(){function b(b){var f=b.styles;this.renderer=b.renderer;this.svgElement=b;this.width=b.textWidth;this.textLineHeight=f&&f.lineHeight;this.textOutline=f&&f.textOutline;this.ellipsis=!(!f||"ellipsis"!==f.textOverflow);this.noWrap=!(!f||"nowrap"!==f.whiteSpace);this.fontSize=f&&f.fontSize}b.prototype.buildSVG=function(){var b=this.svgElement,f=b.element,d=b.renderer,e=
x(b.textStr,"").toString(),k=-1!==e.indexOf("<"),l=f.childNodes,N=l.length;d=this.width&&!b.added&&d.box;var u=/<br.*?>/g;var n=[e,this.ellipsis,this.noWrap,this.textLineHeight,this.textOutline,this.fontSize,this.width].join();if(n!==b.textCache){b.textCache=n;for(delete b.actualWidth;N--;)f.removeChild(l[N]);k||this.ellipsis||this.width||-1!==e.indexOf(" ")&&(!this.noWrap||u.test(e))?""!==e&&(d&&d.appendChild(f),e=new I(e),this.modifyTree(e.nodes),e.addToDOM(b.element),this.modifyDOM(),this.ellipsis&&
-1!==(f.textContent||"").indexOf("\u2026")&&b.attr("title",this.unescapeEntities(b.textStr||"",["&lt;","&gt;"])),d&&d.removeChild(f)):f.appendChild(D.createTextNode(this.unescapeEntities(e)));C(this.textOutline)&&b.applyTextOutline&&b.applyTextOutline(this.textOutline)}};b.prototype.modifyDOM=function(){var b=this,f=this.svgElement,d=G(f.element,"x");[].forEach.call(f.element.querySelectorAll("tspan.highcharts-br"),function(f){f.nextSibling&&f.previousSibling&&G(f,{dy:b.getLineHeight(f.nextSibling),
x:d})});var e=this.width||0;if(e){var k=function(l,u){var n=l.textContent||"",k=n.replace(/([^\^])-/g,"$1- ").split(" "),q=!b.noWrap&&(1<k.length||1<f.element.childNodes.length),m=b.getLineHeight(u),c=0,g=f.actualWidth;if(b.ellipsis)n&&b.truncate(l,n,void 0,0,Math.max(0,e-parseInt(b.fontSize||12,10)),function(a,c){return a.substring(0,c)+"\u2026"});else if(q){n=[];for(q=[];u.firstChild&&u.firstChild!==l;)q.push(u.firstChild),u.removeChild(u.firstChild);for(;k.length;)k.length&&!b.noWrap&&0<c&&(n.push(l.textContent||
""),l.textContent=k.join(" ").replace(/- /g,"-")),b.truncate(l,void 0,k,0===c?g||0:0,e,function(a,c){return k.slice(0,c).join(" ").replace(/- /g,"-")}),g=f.actualWidth,c++;q.forEach(function(a){u.insertBefore(a,l)});n.forEach(function(a){u.insertBefore(D.createTextNode(a),l);a=D.createElementNS(H,"tspan");a.textContent="\u200b";G(a,{dy:m,x:d});u.insertBefore(a,l)})}},l=function(d){[].slice.call(d.childNodes).forEach(function(b){b.nodeType===Node.TEXT_NODE?k(b,d):(-1!==b.className.baseVal.indexOf("highcharts-br")&&
(f.actualWidth=0),l(b))})};l(f.element)}};b.prototype.getLineHeight=function(b){var f;b=b.nodeType===Node.TEXT_NODE?b.parentElement:b;this.renderer.styledMode||(f=b&&/(px|em)$/.test(b.style.fontSize)?b.style.fontSize:this.fontSize||this.renderer.style.fontSize||12);return this.textLineHeight?parseInt(this.textLineHeight.toString(),10):this.renderer.fontMetrics(f,b||this.svgElement.element).h};b.prototype.modifyTree=function(b){var f=this,d=function(e,k){var l=e.tagName,q=f.renderer.styledMode,u=e.attributes||
{};if("b"===l||"strong"===l)q?u["class"]="highcharts-strong":u.style="font-weight:bold;"+(u.style||"");else if("i"===l||"em"===l)q?u["class"]="highcharts-emphasized":u.style="font-style:italic;"+(u.style||"");C(u.style)&&(u.style=u.style.replace(/(;| |^)color([ :])/,"$1fill$2"));"br"===l&&(u["class"]="highcharts-br",e.textContent="\u200b",(k=b[k+1])&&k.textContent&&(k.textContent=k.textContent.replace(/^ +/gm,"")));"#text"!==l&&"a"!==l&&(e.tagName="tspan");e.attributes=u;e.children&&e.children.filter(function(d){return"#text"!==
d.tagName}).forEach(d)};for(b.forEach(d);b[0]&&"tspan"===b[0].tagName&&!b[0].children;)b.splice(0,1)};b.prototype.truncate=function(b,f,d,e,k,l){var q=this.svgElement,u=q.renderer,n=q.rotation,J=[],E=d?1:0,m=(f||d||"").length,c=m,g,a=function(a,c){c=c||a;var g=b.parentNode;if(g&&"undefined"===typeof J[c])if(g.getSubStringLength)try{J[c]=e+g.getSubStringLength(0,d?c+1:c)}catch(L){""}else u.getSpanWidth&&(b.textContent=l(f||d,a),J[c]=e+u.getSpanWidth(q,b));return J[c]};q.rotation=0;var h=a(b.textContent.length);
if(e+h>k){for(;E<=m;)c=Math.ceil((E+m)/2),d&&(g=l(d,c)),h=a(c,g&&g.length-1),E===m?E=m+1:h>k?m=c-1:E=c;0===m?b.textContent="":f&&m===f.length-1||(b.textContent=g||l(f||d,c))}d&&d.splice(0,c);q.actualWidth=h;q.rotation=n};b.prototype.unescapeEntities=function(b,f){B(this.renderer.escapes,function(d,e){f&&-1!==f.indexOf(d)||(b=b.toString().replace(new RegExp(d,"g"),e))});return b};return b}()});O(e,"Core/Renderer/SVG/SVGRenderer.js",[e["Core/Color/Color.js"],e["Core/Globals.js"],e["Core/Color/Palette.js"],
e["Core/Renderer/SVG/SVGElement.js"],e["Core/Renderer/SVG/SVGLabel.js"],e["Core/Renderer/HTML/AST.js"],e["Core/Renderer/SVG/TextBuilder.js"],e["Core/Utilities.js"]],function(e,b,I,z,H,G,C,B){var x=B.addEvent,w=B.attr,v=B.createElement,f=B.css,d=B.defined,q=B.destroyObjectProperties,k=B.extend,l=B.isArray,N=B.isNumber,u=B.isObject,n=B.isString,J=B.merge,E=B.pick,m=B.pInt,c=B.uniqueKey,g=b.charts,a=b.deg2rad,h=b.doc,r=b.isFirefox,A=b.isMS,y=b.isWebKit,L=b.noop,P=b.SVG_NS,R=b.symbolSizes,V=b.win,Q;B=
function(){function t(a,c,g,t,d,h,r){this.width=this.url=this.style=this.isSVG=this.imgCount=this.height=this.gradients=this.globalAnimation=this.defs=this.chartIndex=this.cacheKeys=this.cache=this.boxWrapper=this.box=this.alignedObjects=void 0;this.init(a,c,g,t,d,h,r)}t.prototype.init=function(a,c,g,t,d,b,K){var p=this.createElement("svg").attr({version:"1.1","class":"highcharts-root"});K||p.css(this.getStyle(t));t=p.element;a.appendChild(t);w(a,"dir","ltr");-1===a.innerHTML.indexOf("xmlns")&&w(t,
"xmlns",this.SVG_NS);this.isSVG=!0;this.box=t;this.boxWrapper=p;this.alignedObjects=[];this.url=this.getReferenceURL();this.createElement("desc").add().element.appendChild(h.createTextNode("Created with Highcharts 9.1.0"));this.defs=this.createElement("defs").add();this.allowHTML=b;this.forExport=d;this.styledMode=K;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.setSize(c,g,!1);var F;r&&a.getBoundingClientRect&&(c=function(){f(a,{left:0,top:0});F=a.getBoundingClientRect();
f(a,{left:Math.ceil(F.left)-F.left+"px",top:Math.ceil(F.top)-F.top+"px"})},c(),this.unSubPixelFix=x(V,"resize",c))};t.prototype.definition=function(a){return(new G([a])).addToDOM(this.defs.element)};t.prototype.getReferenceURL=function(){if((r||y)&&h.getElementsByTagName("base").length){if(!d(Q)){var a=c();a=(new G([{tagName:"svg",attributes:{width:8,height:8},children:[{tagName:"defs",children:[{tagName:"clipPath",attributes:{id:a},children:[{tagName:"rect",attributes:{width:4,height:4}}]}]},{tagName:"rect",
attributes:{id:"hitme",width:8,height:8,"clip-path":"url(#"+a+")",fill:"rgba(0,0,0,0.001)"}}]}])).addToDOM(h.body);f(a,{position:"fixed",top:0,left:0,zIndex:9E5});var g=h.elementFromPoint(6,6);Q="hitme"===(g&&g.id);h.body.removeChild(a)}if(Q)return V.location.href.split("#")[0].replace(/<[^>]*>/g,"").replace(/([\('\)])/g,"\\$1").replace(/ /g,"%20")}return""};t.prototype.getStyle=function(a){return this.style=k({fontFamily:'"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',fontSize:"12px"},
a)};t.prototype.setStyle=function(a){this.boxWrapper.css(this.getStyle(a))};t.prototype.isHidden=function(){return!this.boxWrapper.getBBox().width};t.prototype.destroy=function(){var a=this.defs;this.box=null;this.boxWrapper=this.boxWrapper.destroy();q(this.gradients||{});this.gradients=null;a&&(this.defs=a.destroy());this.unSubPixelFix&&this.unSubPixelFix();return this.alignedObjects=null};t.prototype.createElement=function(a){var c=new this.Element;c.init(this,a);return c};t.prototype.getRadialAttr=
function(a,c){return{cx:a[0]-a[2]/2+(c.cx||0)*a[2],cy:a[1]-a[2]/2+(c.cy||0)*a[2],r:(c.r||0)*a[2]}};t.prototype.buildText=function(a){(new C(a)).buildSVG()};t.prototype.getContrast=function(a){a=e.parse(a).rgba;a[0]*=1;a[1]*=1.2;a[2]*=.5;return 459<a[0]+a[1]+a[2]?"#000000":"#FFFFFF"};t.prototype.button=function(a,c,g,t,d,h,r,b,m,f){var p=this.label(a,c,g,m,void 0,void 0,f,void 0,"button"),F=0,K=this.styledMode,y=d?J(d):{};a=y&&y.style||{};y=G.filterUserAttributes(y);p.attr(J({padding:8,r:2},y));if(!K){y=
J({fill:I.neutralColor3,stroke:I.neutralColor20,"stroke-width":1,style:{color:I.neutralColor80,cursor:"pointer",fontWeight:"normal"}},{style:a},y);var l=y.style;delete y.style;h=J(y,{fill:I.neutralColor10},G.filterUserAttributes(h||{}));var S=h.style;delete h.style;r=J(y,{fill:I.highlightColor10,style:{color:I.neutralColor100,fontWeight:"bold"}},G.filterUserAttributes(r||{}));var u=r.style;delete r.style;b=J(y,{style:{color:I.neutralColor20}},G.filterUserAttributes(b||{}));var n=b.style;delete b.style}x(p.element,
A?"mouseover":"mouseenter",function(){3!==F&&p.setState(1)});x(p.element,A?"mouseout":"mouseleave",function(){3!==F&&p.setState(F)});p.setState=function(a){1!==a&&(p.state=F=a);p.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-"+["normal","hover","pressed","disabled"][a||0]);K||p.attr([y,h,r,b][a||0]).css([l,S,u,n][a||0])};K||p.attr(y).css(k({cursor:"default"},l));return p.on("touchstart",function(a){return a.stopPropagation()}).on("click",function(a){3!==
F&&t.call(p,a)})};t.prototype.crispLine=function(a,c,g){void 0===g&&(g="round");var p=a[0],t=a[1];p[1]===t[1]&&(p[1]=t[1]=Math[g](p[1])-c%2/2);p[2]===t[2]&&(p[2]=t[2]=Math[g](p[2])+c%2/2);return a};t.prototype.path=function(a){var c=this.styledMode?{}:{fill:"none"};l(a)?c.d=a:u(a)&&k(c,a);return this.createElement("path").attr(c)};t.prototype.circle=function(a,c,g){a=u(a)?a:"undefined"===typeof a?{}:{x:a,y:c,r:g};c=this.createElement("circle");c.xSetter=c.ySetter=function(a,c,p){p.setAttribute("c"+
c,a)};return c.attr(a)};t.prototype.arc=function(a,c,g,t,d,h){u(a)?(t=a,c=t.y,g=t.r,a=t.x):t={innerR:t,start:d,end:h};a=this.symbol("arc",a,c,g,g,t);a.r=g;return a};t.prototype.rect=function(a,c,g,t,d,h){d=u(a)?a.r:d;var p=this.createElement("rect");a=u(a)?a:"undefined"===typeof a?{}:{x:a,y:c,width:Math.max(g,0),height:Math.max(t,0)};this.styledMode||("undefined"!==typeof h&&(a["stroke-width"]=h,a=p.crisp(a)),a.fill="none");d&&(a.r=d);p.rSetter=function(a,c,g){p.r=a;w(g,{rx:a,ry:a})};p.rGetter=function(){return p.r||
0};return p.attr(a)};t.prototype.setSize=function(a,c,g){this.width=a;this.height=c;this.boxWrapper.animate({width:a,height:c},{step:function(){this.attr({viewBox:"0 0 "+this.attr("width")+" "+this.attr("height")})},duration:E(g,!0)?void 0:0});this.alignElements()};t.prototype.g=function(a){var c=this.createElement("g");return a?c.attr({"class":"highcharts-"+a}):c};t.prototype.image=function(a,c,g,t,d,h){var p={preserveAspectRatio:"none"},r=function(a,c){a.setAttributeNS?a.setAttributeNS("http://www.w3.org/1999/xlink",
"href",c):a.setAttribute("hc-svg-href",c)},F=function(c){r(b.element,a);h.call(b,c)};1<arguments.length&&k(p,{x:c,y:g,width:t,height:d});var b=this.createElement("image").attr(p);h?(r(b.element,"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="),p=new V.Image,x(p,"load",F),p.src=a,p.complete&&F({})):r(b.element,a);return b};t.prototype.symbol=function(a,c,t,r,F,b){var p=this,m=/^url\((.*?)\)$/,A=m.test(a),y=!A&&(this.symbols[a]?a:"circle"),l=y&&this.symbols[y],u;if(l){"number"===
typeof c&&(u=l.call(this.symbols,Math.round(c||0),Math.round(t||0),r||0,F||0,b));var n=this.path(u);p.styledMode||n.attr("fill","none");k(n,{symbolName:y,x:c,y:t,width:r,height:F});b&&k(n,b)}else if(A){var e=a.match(m)[1];n=this.image(e);n.imgwidth=E(R[e]&&R[e].width,b&&b.width);n.imgheight=E(R[e]&&R[e].height,b&&b.height);var S=function(){n.attr({width:n.width,height:n.height})};["width","height"].forEach(function(a){n[a+"Setter"]=function(a,c){var p=this["img"+c];this[c]=a;d(p)&&(b&&"within"===
b.backgroundSize&&this.width&&this.height&&(p=Math.round(p*Math.min(this.width/this.imgwidth,this.height/this.imgheight))),this.element&&this.element.setAttribute(c,p),this.alignByTranslate||(a=((this[c]||0)-p)/2,this.attr("width"===c?{translateX:a}:{translateY:a})))}});d(c)&&n.attr({x:c,y:t});n.isImg=!0;d(n.imgwidth)&&d(n.imgheight)?S():(n.attr({width:0,height:0}),v("img",{onload:function(){var a=g[p.chartIndex];0===this.width&&(f(this,{position:"absolute",top:"-999em"}),h.body.appendChild(this));
R[e]={width:this.width,height:this.height};n.imgwidth=this.width;n.imgheight=this.height;n.element&&S();this.parentNode&&this.parentNode.removeChild(this);p.imgCount--;if(!p.imgCount&&a&&!a.hasLoaded)a.onload()},src:e}),this.imgCount++)}return n};t.prototype.clipRect=function(a,g,t,d){var p=c()+"-",h=this.createElement("clipPath").attr({id:p}).add(this.defs);a=this.rect(a,g,t,d,0).add(h);a.id=p;a.clipPath=h;a.count=0;return a};t.prototype.text=function(a,c,g,t){var p={};if(t&&(this.allowHTML||!this.forExport))return this.html(a,
c,g);p.x=Math.round(c||0);g&&(p.y=Math.round(g));d(a)&&(p.text=a);a=this.createElement("text").attr(p);t||(a.xSetter=function(a,c,p){var g=p.getElementsByTagName("tspan"),t=p.getAttribute(c),d;for(d=0;d<g.length;d++){var h=g[d];h.getAttribute(c)===t&&h.setAttribute(c,a)}p.setAttribute(c,a)});return a};t.prototype.fontMetrics=function(a,c){a=!this.styledMode&&/px/.test(a)||!V.getComputedStyle?a||c&&c.style&&c.style.fontSize||this.style&&this.style.fontSize:c&&z.prototype.getStyle.call(c,"font-size");
a=/px/.test(a)?m(a):12;c=24>a?a+3:Math.round(1.2*a);return{h:c,b:Math.round(.8*c),f:a}};t.prototype.rotCorr=function(c,g,t){var p=c;g&&t&&(p=Math.max(p*Math.cos(g*a),4));return{x:-c/3*Math.sin(g*a),y:p}};t.prototype.pathToSegments=function(a){for(var c=[],g=[],p={A:8,C:7,H:2,L:3,M:3,Q:5,S:5,T:3,V:2},t=0;t<a.length;t++)n(g[0])&&N(a[t])&&g.length===p[g[0].toUpperCase()]&&a.splice(t,0,g[0].replace("M","L").replace("m","l")),"string"===typeof a[t]&&(g.length&&c.push(g.slice(0)),g.length=0),g.push(a[t]);
c.push(g.slice(0));return c};t.prototype.label=function(a,c,g,t,d,h,r,b,m){return new H(this,a,c,g,t,d,h,r,b,m)};t.prototype.alignElements=function(){this.alignedObjects.forEach(function(a){return a.align()})};return t}();B.prototype.Element=z;B.prototype.SVG_NS=P;B.prototype.draw=L;B.prototype.escapes={"&":"&amp;","<":"&lt;",">":"&gt;","'":"&#39;",'"':"&quot;"};var M=function(a,c,g,d,h){h=h&&h.r||0;return[["M",a+h,c],["L",a+g-h,c],["C",a+g,c,a+g,c,a+g,c+h],["L",a+g,c+d-h],["C",a+g,c+d,a+g,c+d,a+
g-h,c+d],["L",a+h,c+d],["C",a,c+d,a,c+d,a,c+d-h],["L",a,c+h],["C",a,c,a,c,a+h,c]]};L=function(a,c,g,d,h){return h&&h.r?M(a,c,g,d,h):[["M",a,c],["L",a+g,c],["L",a+g,c+d],["L",a,c+d],["Z"]]};B.prototype.symbols={circle:function(a,c,g,d){return this.arc(a+g/2,c+d/2,g/2,d/2,{start:.5*Math.PI,end:2.5*Math.PI,open:!1})},rect:L,square:L,triangle:function(a,c,g,d){return[["M",a+g/2,c],["L",a+g,c+d],["L",a,c+d],["Z"]]},"triangle-down":function(a,c,g,d){return[["M",a,c],["L",a+g,c],["L",a+g/2,c+d],["Z"]]},
diamond:function(a,c,g,d){return[["M",a+g/2,c],["L",a+g,c+d/2],["L",a+g/2,c+d],["L",a,c+d/2],["Z"]]},arc:function(a,c,g,h,r){var t=[];if(r){var p=r.start||0,b=E(r.r,g);g=E(r.r,h||g);var m=(r.end||0)-.001;h=r.innerR;var f=E(r.open,.001>Math.abs((r.end||0)-p-2*Math.PI)),A=Math.cos(p),y=Math.sin(p),l=Math.cos(m),n=Math.sin(m);p=E(r.longArc,.001>m-p-Math.PI?0:1);t.push(["M",a+b*A,c+g*y],["A",b,g,0,p,E(r.clockwise,1),a+b*l,c+g*n]);d(h)&&t.push(f?["M",a+h*l,c+h*n]:["L",a+h*l,c+h*n],["A",h,h,0,p,d(r.clockwise)?
1-r.clockwise:0,a+h*A,c+h*y]);f||t.push(["Z"])}return t},callout:function(a,c,g,d,h){var p=Math.min(h&&h.r||0,g,d),t=p+6,r=h&&h.anchorX;h=h&&h.anchorY||0;var b=M(a,c,g,d,{r:p});if(!N(r))return b;a+r>=g?h>c+t&&h<c+d-t?b.splice(3,1,["L",a+g,h-6],["L",a+g+6,h],["L",a+g,h+6],["L",a+g,c+d-p]):b.splice(3,1,["L",a+g,d/2],["L",r,h],["L",a+g,d/2],["L",a+g,c+d-p]):0>=a+r?h>c+t&&h<c+d-t?b.splice(7,1,["L",a,h+6],["L",a-6,h],["L",a,h-6],["L",a,c+p]):b.splice(7,1,["L",a,d/2],["L",r,h],["L",a,d/2],["L",a,c+p]):
h&&h>d&&r>a+t&&r<a+g-t?b.splice(5,1,["L",r+6,c+d],["L",r,c+d+6],["L",r-6,c+d],["L",a+p,c+d]):h&&0>h&&r>a+t&&r<a+g-t&&b.splice(1,1,["L",r-6,c],["L",r,c-6],["L",r+6,c],["L",g-p,c]);return b}};b.SVGRenderer=B;b.Renderer=b.SVGRenderer;return b.Renderer});O(e,"Core/Renderer/HTML/HTMLElement.js",[e["Core/Globals.js"],e["Core/Renderer/SVG/SVGElement.js"],e["Core/Utilities.js"]],function(e,b,I){var D=e.isFirefox,H=e.isMS,G=e.isWebKit,C=e.win,B=I.css,x=I.defined,w=I.extend,v=I.pick,f=I.pInt;w(b.prototype,
{htmlCss:function(d){var b="SPAN"===this.element.tagName&&d&&"width"in d,f=v(b&&d.width,void 0);if(b){delete d.width;this.textWidth=f;var l=!0}d&&"ellipsis"===d.textOverflow&&(d.whiteSpace="nowrap",d.overflow="hidden");this.styles=w(this.styles,d);B(this.element,d);l&&this.htmlUpdateTransform();return this},htmlGetBBox:function(){var d=this.element;return{x:d.offsetLeft,y:d.offsetTop,width:d.offsetWidth,height:d.offsetHeight}},htmlUpdateTransform:function(){if(this.added){var d=this.renderer,b=this.element,
e=this.translateX||0,l=this.translateY||0,N=this.x||0,u=this.y||0,n=this.textAlign||"left",J={left:0,center:.5,right:1}[n],E=this.styles;E=E&&E.whiteSpace;B(b,{marginLeft:e,marginTop:l});!d.styledMode&&this.shadows&&this.shadows.forEach(function(a){B(a,{marginLeft:e+1,marginTop:l+1})});this.inverted&&[].forEach.call(b.childNodes,function(a){d.invertChild(a,b)});if("SPAN"===b.tagName){var m=this.rotation,c=void 0;c=this.textWidth&&f(this.textWidth);var g=[m,n,b.innerHTML,this.textWidth,this.textAlign].join(),
a;(a=c!==this.oldTextWidth)&&!(a=c>this.oldTextWidth)&&((a=this.textPxLength)||(B(b,{width:"",whiteSpace:E||"nowrap"}),a=b.offsetWidth),a=a>c);a&&(/[ \-]/.test(b.textContent||b.innerText)||"ellipsis"===b.style.textOverflow)?(B(b,{width:c+"px",display:"block",whiteSpace:E||"normal"}),this.oldTextWidth=c,this.hasBoxWidthChanged=!0):this.hasBoxWidthChanged=!1;g!==this.cTT&&(c=d.fontMetrics(b.style.fontSize,b).b,!x(m)||m===(this.oldRotation||0)&&n===this.oldAlign||this.setSpanRotation(m,J,c),this.getSpanCorrection(!x(m)&&
this.textPxLength||b.offsetWidth,c,J,m,n));B(b,{left:N+(this.xCorr||0)+"px",top:u+(this.yCorr||0)+"px"});this.cTT=g;this.oldRotation=m;this.oldAlign=n}}else this.alignOnAdd=!0},setSpanRotation:function(d,b,f){var l={},e=H&&!/Edge/.test(C.navigator.userAgent)?"-ms-transform":G?"-webkit-transform":D?"MozTransform":C.opera?"-o-transform":void 0;e&&(l[e]=l.transform="rotate("+d+"deg)",l[e+(D?"Origin":"-origin")]=l.transformOrigin=100*b+"% "+f+"px",B(this.element,l))},getSpanCorrection:function(d,b,f){this.xCorr=
-d*f;this.yCorr=-b}});return b});O(e,"Core/Renderer/HTML/HTMLRenderer.js",[e["Core/Renderer/HTML/AST.js"],e["Core/Renderer/SVG/SVGElement.js"],e["Core/Renderer/SVG/SVGRenderer.js"],e["Core/Utilities.js"]],function(e,b,I,z){var D=z.attr,G=z.createElement,C=z.extend,B=z.pick;C(I.prototype,{html:function(x,w,v){var f=this.createElement("span"),d=f.element,q=f.renderer,k=q.isSVG,l=function(d,f){["opacity","visibility"].forEach(function(l){d[l+"Setter"]=function(n,e,m){var c=d.div?d.div.style:f;b.prototype[l+
"Setter"].call(this,n,e,m);c&&(c[e]=n)}});d.addedSetters=!0};f.textSetter=function(d){d!==this.textStr&&(delete this.bBox,delete this.oldTextWidth,e.setElementHTML(this.element,B(d,"")),this.textStr=d,f.doTransform=!0)};k&&l(f,f.element.style);f.xSetter=f.ySetter=f.alignSetter=f.rotationSetter=function(d,b){"align"===b?f.alignValue=f.textAlign=d:f[b]=d;f.doTransform=!0};f.afterSetters=function(){this.doTransform&&(this.htmlUpdateTransform(),this.doTransform=!1)};f.attr({text:x,x:Math.round(w),y:Math.round(v)}).css({position:"absolute"});
q.styledMode||f.css({fontFamily:this.style.fontFamily,fontSize:this.style.fontSize});d.style.whiteSpace="nowrap";f.css=f.htmlCss;k&&(f.add=function(b){var e=q.box.parentNode,n=[];if(this.parentGroup=b){var k=b.div;if(!k){for(;b;)n.push(b),b=b.parentGroup;n.reverse().forEach(function(d){function b(c,g){d[g]=c;"translateX"===g?a.left=c+"px":a.top=c+"px";d.doTransform=!0}var c=D(d.element,"class"),g=d.styles||{};k=d.div=d.div||G("div",c?{className:c}:void 0,{position:"absolute",left:(d.translateX||0)+
"px",top:(d.translateY||0)+"px",display:d.display,opacity:d.opacity,cursor:g.cursor,pointerEvents:g.pointerEvents},k||e);var a=k.style;C(d,{classSetter:function(a){return function(c){this.element.setAttribute("class",c);a.className=c}}(k),on:function(){n[0].div&&f.on.apply({element:n[0].div,onEvents:f.onEvents},arguments);return d},translateXSetter:b,translateYSetter:b});d.addedSetters||l(d)})}}else k=e;k.appendChild(d);f.added=!0;f.alignOnAdd&&f.htmlUpdateTransform();return f});return f}});return I});
O(e,"Core/Axis/Tick.js",[e["Core/FormatUtilities.js"],e["Core/Globals.js"],e["Core/Utilities.js"]],function(e,b,I){var D=b.deg2rad,H=I.clamp,G=I.correctFloat,C=I.defined,B=I.destroyObjectProperties,x=I.extend,w=I.fireEvent,v=I.isNumber,f=I.merge,d=I.objectEach,q=I.pick;"";I=function(){function b(d,b,f,e,k){this.isNewLabel=this.isNew=!0;this.axis=d;this.pos=b;this.type=f||"";this.parameters=k||{};this.tickmarkOffset=this.parameters.tickmarkOffset;this.options=this.parameters.options;w(this,"init");
f||e||this.addLabel()}b.prototype.addLabel=function(){var d=this,b=d.axis,f=b.options,n=b.chart,k=b.categories,E=b.logarithmic,m=b.names,c=d.pos,g=q(d.options&&d.options.labels,f.labels),a=b.tickPositions,h=c===a[0],r=c===a[a.length-1],A=d.label,y=(!g.step||1===g.step)&&1===b.tickInterval;a=a.info;var L,P;k=this.parameters.category||(k?q(k[c],m[c],c):c);E&&v(k)&&(k=G(E.lin2log(k)));if(b.dateTime&&a){var R=n.time.resolveDTLFormat(f.dateTimeLabelFormats[!f.grid&&a.higherRanks[c]||a.unitName]);var V=
R.main}d.isFirst=h;d.isLast=r;var Q={axis:b,chart:n,dateTimeLabelFormat:V,isFirst:h,isLast:r,pos:c,tick:d,tickPositionInfo:a,value:k};w(this,"labelFormat",Q);var M=function(a){return g.formatter?g.formatter.call(a,a):g.format?(a.text=b.defaultLabelFormatter.call(a),e.format(g.format,a,n)):b.defaultLabelFormatter.call(a,a)};f=M.call(Q,Q);if(P=R&&R.list)d.shortenLabel=function(){for(L=0;L<P.length;L++)if(x(Q,{dateTimeLabelFormat:P[L]}),A.attr({text:M.call(Q,Q)}),A.getBBox().width<b.getSlotWidth(d)-
2*g.padding)return;A.attr({text:""})};y&&b._addedPlotLB&&d.moveLabel(f,g);C(A)||d.movedLabel?A&&A.textStr!==f&&!y&&(!A.textWidth||g.style.width||A.styles.width||A.css({width:null}),A.attr({text:f}),A.textPxLength=A.getBBox().width):(d.label=A=d.createLabel({x:0,y:0},f,g),d.rotation=0)};b.prototype.createLabel=function(d,b,e){var n=this.axis,l=n.chart;if(d=C(b)&&e.enabled?l.renderer.text(b,d.x,d.y,e.useHTML).add(n.labelGroup):null)l.styledMode||d.css(f(e.style)),d.textPxLength=d.getBBox().width;return d};
b.prototype.destroy=function(){B(this,this.axis)};b.prototype.getPosition=function(d,b,f,e){var n=this.axis,l=n.chart,m=e&&l.oldChartHeight||l.chartHeight;d={x:d?G(n.translate(b+f,null,null,e)+n.transB):n.left+n.offset+(n.opposite?(e&&l.oldChartWidth||l.chartWidth)-n.right-n.left:0),y:d?m-n.bottom+n.offset-(n.opposite?n.height:0):G(m-n.translate(b+f,null,null,e)-n.transB)};d.y=H(d.y,-1E5,1E5);w(this,"afterGetPosition",{pos:d});return d};b.prototype.getLabelPosition=function(d,b,f,e,k,q,m,c){var g=
this.axis,a=g.transA,h=g.isLinked&&g.linkedParent?g.linkedParent.reversed:g.reversed,r=g.staggerLines,A=g.tickRotCorr||{x:0,y:0},y=k.y,n=e||g.reserveSpaceDefault?0:-g.labelOffset*("center"===g.labelAlign?.5:1),l={};C(y)||(y=0===g.side?f.rotation?-8:-f.getBBox().height:2===g.side?A.y+8:Math.cos(f.rotation*D)*(A.y-f.getBBox(!1,0).height/2));d=d+k.x+n+A.x-(q&&e?q*a*(h?-1:1):0);b=b+y-(q&&!e?q*a*(h?1:-1):0);r&&(f=m/(c||1)%r,g.opposite&&(f=r-f-1),b+=g.labelOffset/r*f);l.x=d;l.y=Math.round(b);w(this,"afterGetLabelPosition",
{pos:l,tickmarkOffset:q,index:m});return l};b.prototype.getLabelSize=function(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0};b.prototype.getMarkPath=function(d,b,f,e,k,q){return q.crispLine([["M",d,b],["L",d+(k?0:-f),b+(k?f:0)]],e)};b.prototype.handleOverflow=function(d){var b=this.axis,f=b.options.labels,e=d.x,l=b.chart.chartWidth,k=b.chart.spacing,m=q(b.labelLeft,Math.min(b.pos,k[3]));k=q(b.labelRight,Math.max(b.isRadial?0:b.pos+b.len,l-k[1]));var c=this.label,g=this.rotation,
a={left:0,center:.5,right:1}[b.labelAlign||c.attr("align")],h=c.getBBox().width,r=b.getSlotWidth(this),A=r,y=1,L,P={};if(g||"justify"!==f.overflow)0>g&&e-a*h<m?L=Math.round(e/Math.cos(g*D)-m):0<g&&e+a*h>k&&(L=Math.round((l-e)/Math.cos(g*D)));else if(l=e+(1-a)*h,e-a*h<m?A=d.x+A*(1-a)-m:l>k&&(A=k-d.x+A*a,y=-1),A=Math.min(r,A),A<r&&"center"===b.labelAlign&&(d.x+=y*(r-A-a*(r-Math.min(h,A)))),h>A||b.autoRotation&&(c.styles||{}).width)L=A;L&&(this.shortenLabel?this.shortenLabel():(P.width=Math.floor(L)+
"px",(f.style||{}).textOverflow||(P.textOverflow="ellipsis"),c.css(P)))};b.prototype.moveLabel=function(b,f){var e=this,n=e.label,l=!1,k=e.axis,m=k.reversed;n&&n.textStr===b?(e.movedLabel=n,l=!0,delete e.label):d(k.ticks,function(c){l||c.isNew||c===e||!c.label||c.label.textStr!==b||(e.movedLabel=c.label,l=!0,c.labelPos=e.movedLabel.xy,delete c.label)});if(!l&&(e.labelPos||n)){var c=e.labelPos||n.xy;n=k.horiz?m?0:k.width+k.left:c.x;k=k.horiz?c.y:m?k.width+k.left:0;e.movedLabel=e.createLabel({x:n,y:k},
b,f);e.movedLabel&&e.movedLabel.attr({opacity:0})}};b.prototype.render=function(d,b,f){var e=this.axis,l=e.horiz,k=this.pos,m=q(this.tickmarkOffset,e.tickmarkOffset);k=this.getPosition(l,k,m,b);m=k.x;var c=k.y;e=l&&m===e.pos+e.len||!l&&c===e.pos?-1:1;l=q(f,this.label&&this.label.newOpacity,1);f=q(f,1);this.isActive=!0;this.renderGridLine(b,f,e);this.renderMark(k,f,e);this.renderLabel(k,b,l,d);this.isNew=!1;w(this,"afterRender")};b.prototype.renderGridLine=function(d,b,f){var e=this.axis,l=e.options,
k=this.gridLine,m={},c=this.pos,g=this.type,a=q(this.tickmarkOffset,e.tickmarkOffset),h=e.chart.renderer,r=l.gridLineWidth,A=l.gridLineColor,y=l.gridLineDashStyle;"minor"===this.type&&(r=l.minorGridLineWidth,A=l.minorGridLineColor,y=l.minorGridLineDashStyle);k||(e.chart.styledMode||(m.stroke=A,m["stroke-width"]=r||0,m.dashstyle=y),g||(m.zIndex=1),d&&(b=0),this.gridLine=k=h.path().attr(m).addClass("highcharts-"+(g?g+"-":"")+"grid-line").add(e.gridGroup));if(k&&(f=e.getPlotLinePath({value:c+a,lineWidth:k.strokeWidth()*
f,force:"pass",old:d})))k[d||this.isNew?"attr":"animate"]({d:f,opacity:b})};b.prototype.renderMark=function(d,b,f){var e=this.axis,l=e.options,k=e.chart.renderer,m=this.type,c=e.tickSize(m?m+"Tick":"tick"),g=this.mark,a=!g,h=d.x;d=d.y;var r=q(l["minor"!==m?"tickWidth":"minorTickWidth"],!m&&e.isXAxis?1:0);l=l["minor"!==m?"tickColor":"minorTickColor"];c&&(e.opposite&&(c[0]=-c[0]),a&&(this.mark=g=k.path().addClass("highcharts-"+(m?m+"-":"")+"tick").add(e.axisGroup),e.chart.styledMode||g.attr({stroke:l,
"stroke-width":r})),g[a?"attr":"animate"]({d:this.getMarkPath(h,d,c[0],g.strokeWidth()*f,e.horiz,k),opacity:b}))};b.prototype.renderLabel=function(d,b,f,e){var l=this.axis,n=l.horiz,m=l.options,c=this.label,g=m.labels,a=g.step;l=q(this.tickmarkOffset,l.tickmarkOffset);var h=!0,r=d.x;d=d.y;c&&v(r)&&(c.xy=d=this.getLabelPosition(r,d,c,n,g,l,e,a),this.isFirst&&!this.isLast&&!m.showFirstLabel||this.isLast&&!this.isFirst&&!m.showLastLabel?h=!1:!n||g.step||g.rotation||b||0===f||this.handleOverflow(d),a&&
e%a&&(h=!1),h&&v(d.y)?(d.opacity=f,c[this.isNewLabel?"attr":"animate"](d),this.isNewLabel=!1):(c.attr("y",-9999),this.isNewLabel=!0))};b.prototype.replaceMovedLabel=function(){var d=this.label,b=this.axis,f=b.reversed;if(d&&!this.isNew){var e=b.horiz?f?b.left:b.width+b.left:d.xy.x;f=b.horiz?d.xy.y:f?b.width+b.top:b.top;d.animate({x:e,y:f,opacity:0},void 0,d.destroy);delete this.label}b.isDirty=!0;this.label=this.movedLabel;delete this.movedLabel};return b}();b.Tick=I;return b.Tick});O(e,"Core/Axis/Axis.js",
[e["Core/Animation/AnimationUtilities.js"],e["Core/Color/Color.js"],e["Core/Globals.js"],e["Core/Color/Palette.js"],e["Core/Options.js"],e["Core/Axis/Tick.js"],e["Core/Utilities.js"]],function(e,b,I,z,H,G,C){var B=e.animObject,x=H.defaultOptions,w=C.addEvent,v=C.arrayMax,f=C.arrayMin,d=C.clamp,q=C.correctFloat,k=C.defined,l=C.destroyObjectProperties,N=C.erase,u=C.error,n=C.extend,J=C.fireEvent,E=C.getMagnitude,m=C.isArray,c=C.isFunction,g=C.isNumber,a=C.isString,h=C.merge,r=C.normalizeTickInterval,
A=C.objectEach,y=C.pick,L=C.relativeLength,P=C.removeEvent,R=C.splat,V=C.syncTimeout;"";var Q=I.deg2rad;e=function(){function e(a,c){this.zoomEnabled=this.width=this.visible=this.userOptions=this.translationSlope=this.transB=this.transA=this.top=this.ticks=this.tickRotCorr=this.tickPositions=this.tickmarkOffset=this.tickInterval=this.tickAmount=this.side=this.series=this.right=this.positiveValuesOnly=this.pos=this.pointRangePadding=this.pointRange=this.plotLinesAndBandsGroups=this.plotLinesAndBands=
this.paddedTicks=this.overlap=this.options=this.offset=this.names=this.minPixelPadding=this.minorTicks=this.minorTickInterval=this.min=this.maxLabelLength=this.max=this.len=this.left=this.labelFormatter=this.labelEdge=this.isLinked=this.height=this.hasVisibleSeries=this.hasNames=this.coll=this.closestPointRange=this.chart=this.categories=this.bottom=this.alternateBands=void 0;this.init(a,c)}e.prototype.init=function(a,d){var b=d.isX,h=this;h.chart=a;h.horiz=a.inverted&&!h.isZAxis?!b:b;h.isXAxis=b;
h.coll=h.coll||(b?"xAxis":"yAxis");J(this,"init",{userOptions:d});h.opposite=y(d.opposite,h.opposite);h.side=y(d.side,h.side,h.horiz?h.opposite?0:2:h.opposite?1:3);h.setOptions(d);var p=this.options,t=p.labels,r=p.type;h.userOptions=d;h.minPixelPadding=0;h.reversed=y(p.reversed,h.reversed);h.visible=p.visible;h.zoomEnabled=p.zoomEnabled;h.hasNames="category"===r||!0===p.categories;h.categories=p.categories||h.hasNames;h.names||(h.names=[],h.names.keys={});h.plotLinesAndBandsGroups={};h.positiveValuesOnly=
!!h.logarithmic;h.isLinked=k(p.linkedTo);h.ticks={};h.labelEdge=[];h.minorTicks={};h.plotLinesAndBands=[];h.alternateBands={};h.len=0;h.minRange=h.userMinRange=p.minRange||p.maxZoom;h.range=p.range;h.offset=p.offset||0;h.max=null;h.min=null;d=y(p.crosshair,R(a.options.tooltip.crosshairs)[b?0:1]);h.crosshair=!0===d?{}:d;d=h.options.events;-1===a.axes.indexOf(h)&&(b?a.axes.splice(a.xAxis.length,0,h):a.axes.push(h),a[h.coll].push(h));h.series=h.series||[];a.inverted&&!h.isZAxis&&b&&"undefined"===typeof h.reversed&&
(h.reversed=!0);h.labelRotation=g(t.rotation)?t.rotation:void 0;A(d,function(a,d){c(a)&&w(h,d,a)});J(this,"afterInit")};e.prototype.setOptions=function(a){this.options=h(e.defaultOptions,"yAxis"===this.coll&&e.defaultYAxisOptions,[e.defaultTopAxisOptions,e.defaultRightAxisOptions,e.defaultBottomAxisOptions,e.defaultLeftAxisOptions][this.side],h(x[this.coll],a));J(this,"afterSetOptions",{userOptions:a})};e.prototype.defaultLabelFormatter=function(){var a=this.axis,c=g(this.value)?this.value:NaN,d=
a.chart.time,h=this.dateTimeLabelFormat,b=x.lang,r=b.numericSymbols;b=b.numericSymbolMagnitude||1E3;var e=r&&r.length,f=a.logarithmic?Math.abs(c):a.tickInterval,m=this.chart.numberFormatter;if(a.categories)var A=""+this.value;else if(h)A=d.dateFormat(h,c);else if(e&&1E3<=f)for(;e--&&"undefined"===typeof A;)a=Math.pow(b,e+1),f>=a&&0===10*c%a&&null!==r[e]&&0!==c&&(A=m(c/a,-1)+r[e]);"undefined"===typeof A&&(A=1E4<=Math.abs(c)?m(c,-1):m(c,-1,void 0,""));return A};e.prototype.getSeriesExtremes=function(){var a=
this,c=a.chart,d;J(this,"getSeriesExtremes",null,function(){a.hasVisibleSeries=!1;a.dataMin=a.dataMax=a.threshold=null;a.softThreshold=!a.isXAxis;a.stacking&&a.stacking.buildStacks();a.series.forEach(function(h){if(h.visible||!c.options.chart.ignoreHiddenSeries){var b=h.options,p=b.threshold;a.hasVisibleSeries=!0;a.positiveValuesOnly&&0>=p&&(p=null);if(a.isXAxis){if(b=h.xData,b.length){b=a.logarithmic?b.filter(a.validatePositiveValue):b;d=h.getXExtremes(b);var t=d.min;var r=d.max;g(t)||t instanceof
Date||(b=b.filter(g),d=h.getXExtremes(b),t=d.min,r=d.max);b.length&&(a.dataMin=Math.min(y(a.dataMin,t),t),a.dataMax=Math.max(y(a.dataMax,r),r))}}else if(h=h.applyExtremes(),g(h.dataMin)&&(t=h.dataMin,a.dataMin=Math.min(y(a.dataMin,t),t)),g(h.dataMax)&&(r=h.dataMax,a.dataMax=Math.max(y(a.dataMax,r),r)),k(p)&&(a.threshold=p),!b.softThreshold||a.positiveValuesOnly)a.softThreshold=!1}})});J(this,"afterGetSeriesExtremes")};e.prototype.translate=function(a,c,d,h,b,r){var p=this.linkedParent||this,t=1,e=
0,f=h&&p.old?p.old.transA:p.transA;h=h&&p.old?p.old.min:p.min;var F=p.minPixelPadding;b=(p.isOrdinal||p.brokenAxis&&p.brokenAxis.hasBreaks||p.logarithmic&&b)&&p.lin2val;f||(f=p.transA);d&&(t*=-1,e=p.len);p.reversed&&(t*=-1,e-=t*(p.sector||p.len));c?(a=(a*t+e-F)/f+h,b&&(a=p.lin2val(a))):(b&&(a=p.val2lin(a)),a=g(h)?t*(a-h)*f+e+t*F+(g(r)?f*r:0):void 0);return a};e.prototype.toPixels=function(a,c){return this.translate(a,!1,!this.horiz,null,!0)+(c?0:this.pos)};e.prototype.toValue=function(a,c){return this.translate(a-
(c?0:this.pos),!0,!this.horiz,null,!0)};e.prototype.getPlotLinePath=function(a){function c(a,c,g){if("pass"!==l&&a<c||a>g)l?a=d(a,c,g):v=!0;return a}var h=this,b=h.chart,t=h.left,r=h.top,e=a.old,f=a.value,m=a.translatedValue,A=a.lineWidth,l=a.force,n,k,u,L,q=e&&b.oldChartHeight||b.chartHeight,P=e&&b.oldChartWidth||b.chartWidth,v,da=h.transB;a={value:f,lineWidth:A,old:e,force:l,acrossPanes:a.acrossPanes,translatedValue:m};J(this,"getPlotLinePath",a,function(a){m=y(m,h.translate(f,null,null,e));m=d(m,
-1E5,1E5);n=u=Math.round(m+da);k=L=Math.round(q-m-da);g(m)?h.horiz?(k=r,L=q-h.bottom,n=u=c(n,t,t+h.width)):(n=t,u=P-h.right,k=L=c(k,r,r+h.height)):(v=!0,l=!1);a.path=v&&!l?null:b.renderer.crispLine([["M",n,k],["L",u,L]],A||1)});return a.path};e.prototype.getLinearTickPositions=function(a,c,d){var g=q(Math.floor(c/a)*a);d=q(Math.ceil(d/a)*a);var h=[],b;q(g+a)===g&&(b=20);if(this.single)return[c];for(c=g;c<=d;){h.push(c);c=q(c+a,b);if(c===p)break;var p=c}return h};e.prototype.getMinorTickInterval=function(){var a=
this.options;return!0===a.minorTicks?y(a.minorTickInterval,"auto"):!1===a.minorTicks?null:a.minorTickInterval};e.prototype.getMinorTickPositions=function(){var a=this.options,c=this.tickPositions,d=this.minorTickInterval,g=[],h=this.pointRangePadding||0,b=this.min-h;h=this.max+h;var r=h-b;if(r&&r/d<this.len/3){var e=this.logarithmic;if(e)this.paddedTicks.forEach(function(a,c,h){c&&g.push.apply(g,e.getLogTickPositions(d,h[c-1],h[c],!0))});else if(this.dateTime&&"auto"===this.getMinorTickInterval())g=
g.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(d),b,h,a.startOfWeek));else for(a=b+(c[0]-b)%d;a<=h&&a!==g[0];a+=d)g.push(a)}0!==g.length&&this.trimTicks(g);return g};e.prototype.adjustForMinRange=function(){var a=this.options,c=this.min,d=this.max,g=this.logarithmic,h=0,b,r,e,m;this.isXAxis&&"undefined"===typeof this.minRange&&!g&&(k(a.min)||k(a.max)?this.minRange=null:(this.series.forEach(function(a){e=a.xData;m=a.xIncrement?1:e.length-1;if(1<e.length)for(b=m;0<b;b--)if(r=e[b]-
e[b-1],!h||r<h)h=r}),this.minRange=Math.min(5*h,this.dataMax-this.dataMin)));if(d-c<this.minRange){var A=this.dataMax-this.dataMin>=this.minRange;var l=this.minRange;var n=(l-d+c)/2;n=[c-n,y(a.min,c-n)];A&&(n[2]=this.logarithmic?this.logarithmic.log2lin(this.dataMin):this.dataMin);c=v(n);d=[c+l,y(a.max,c+l)];A&&(d[2]=g?g.log2lin(this.dataMax):this.dataMax);d=f(d);d-c<l&&(n[0]=d-l,n[1]=y(a.min,d-l),c=v(n))}this.min=c;this.max=d};e.prototype.getClosest=function(){var a;this.categories?a=1:this.series.forEach(function(c){var d=
c.closestPointRange,g=c.visible||!c.chart.options.chart.ignoreHiddenSeries;!c.noSharedTooltip&&k(d)&&g&&(a=k(a)?Math.min(a,d):d)});return a};e.prototype.nameToX=function(a){var c=m(this.categories),d=c?this.categories:this.names,g=a.options.x;a.series.requireSorting=!1;k(g)||(g=this.options.uniqueNames?c?d.indexOf(a.name):y(d.keys[a.name],-1):a.series.autoIncrement());if(-1===g){if(!c)var h=d.length}else h=g;"undefined"!==typeof h&&(this.names[h]=a.name,this.names.keys[a.name]=h);return h};e.prototype.updateNames=
function(){var a=this,c=this.names;0<c.length&&(Object.keys(c.keys).forEach(function(a){delete c.keys[a]}),c.length=0,this.minRange=this.userMinRange,(this.series||[]).forEach(function(c){c.xIncrement=null;if(!c.points||c.isDirtyData)a.max=Math.max(a.max,c.xData.length-1),c.processData(),c.generatePoints();c.data.forEach(function(d,g){if(d&&d.options&&"undefined"!==typeof d.name){var h=a.nameToX(d);"undefined"!==typeof h&&h!==d.x&&(d.x=h,c.xData[g]=h)}})}))};e.prototype.setAxisTranslation=function(){var c=
this,d=c.max-c.min,g=c.axisPointRange||0,h=0,b=0,r=c.linkedParent,e=!!c.categories,f=c.transA,m=c.isXAxis;if(m||e||g){var A=c.getClosest();r?(h=r.minPointOffset,b=r.pointRangePadding):c.series.forEach(function(d){var p=e?1:m?y(d.options.pointRange,A,0):c.axisPointRange||0,r=d.options.pointPlacement;g=Math.max(g,p);if(!c.single||e)d=d.is("xrange")?!m:m,h=Math.max(h,d&&a(r)?0:p/2),b=Math.max(b,d&&"on"===r?0:p)});r=c.ordinal&&c.ordinal.slope&&A?c.ordinal.slope/A:1;c.minPointOffset=h*=r;c.pointRangePadding=
b*=r;c.pointRange=Math.min(g,c.single&&e?1:d);m&&(c.closestPointRange=A)}c.translationSlope=c.transA=f=c.staticScale||c.len/(d+b||1);c.transB=c.horiz?c.left:c.bottom;c.minPixelPadding=f*h;J(this,"afterSetAxisTranslation")};e.prototype.minFromRange=function(){return this.max-this.range};e.prototype.setTickInterval=function(a){var c=this,d=c.chart,h=c.logarithmic,b=c.options,e=c.isXAxis,t=c.isLinked,f=b.maxPadding,m=b.minPadding,A=b.tickInterval,l=b.tickPixelInterval,n=c.categories,L=g(c.threshold)?
c.threshold:null,P=c.softThreshold;c.dateTime||n||t||this.getTickAmount();var v=y(c.userMin,b.min);var w=y(c.userMax,b.max);if(t){c.linkedParent=d[c.coll][b.linkedTo];var R=c.linkedParent.getExtremes();c.min=y(R.min,R.dataMin);c.max=y(R.max,R.dataMax);b.type!==c.linkedParent.options.type&&u(11,1,d)}else{if(P&&k(L))if(c.dataMin>=L)R=L,m=0;else if(c.dataMax<=L){var Q=L;f=0}c.min=y(v,R,c.dataMin);c.max=y(w,Q,c.dataMax)}h&&(c.positiveValuesOnly&&!a&&0>=Math.min(c.min,y(c.dataMin,c.min))&&u(10,1,d),c.min=
q(h.log2lin(c.min),16),c.max=q(h.log2lin(c.max),16));c.range&&k(c.max)&&(c.userMin=c.min=v=Math.max(c.dataMin,c.minFromRange()),c.userMax=w=c.max,c.range=null);J(c,"foundExtremes");c.beforePadding&&c.beforePadding();c.adjustForMinRange();!(n||c.axisPointRange||c.stacking&&c.stacking.usePercentage||t)&&k(c.min)&&k(c.max)&&(d=c.max-c.min)&&(!k(v)&&m&&(c.min-=d*m),!k(w)&&f&&(c.max+=d*f));g(c.userMin)||(g(b.softMin)&&b.softMin<c.min&&(c.min=v=b.softMin),g(b.floor)&&(c.min=Math.max(c.min,b.floor)));g(c.userMax)||
(g(b.softMax)&&b.softMax>c.max&&(c.max=w=b.softMax),g(b.ceiling)&&(c.max=Math.min(c.max,b.ceiling)));P&&k(c.dataMin)&&(L=L||0,!k(v)&&c.min<L&&c.dataMin>=L?c.min=c.options.minRange?Math.min(L,c.max-c.minRange):L:!k(w)&&c.max>L&&c.dataMax<=L&&(c.max=c.options.minRange?Math.max(L,c.min+c.minRange):L));g(c.min)&&g(c.max)&&!this.chart.polar&&c.min>c.max&&(k(c.options.min)?c.max=c.min:k(c.options.max)&&(c.min=c.max));c.tickInterval=c.min===c.max||"undefined"===typeof c.min||"undefined"===typeof c.max?1:
t&&c.linkedParent&&!A&&l===c.linkedParent.options.tickPixelInterval?A=c.linkedParent.tickInterval:y(A,this.tickAmount?(c.max-c.min)/Math.max(this.tickAmount-1,1):void 0,n?1:(c.max-c.min)*l/Math.max(c.len,l));e&&!a&&c.series.forEach(function(a){a.processData(c.min!==(c.old&&c.old.min)||c.max!==(c.old&&c.old.max))});c.setAxisTranslation();J(this,"initialAxisTranslation");c.pointRange&&!A&&(c.tickInterval=Math.max(c.pointRange,c.tickInterval));a=y(b.minTickInterval,c.dateTime&&!c.series.some(function(a){return a.noSharedTooltip})?
c.closestPointRange:0);!A&&c.tickInterval<a&&(c.tickInterval=a);c.dateTime||c.logarithmic||A||(c.tickInterval=r(c.tickInterval,void 0,E(c.tickInterval),y(b.allowDecimals,.5>c.tickInterval||void 0!==this.tickAmount),!!this.tickAmount));this.tickAmount||(c.tickInterval=c.unsquish());this.setTickPositions()};e.prototype.setTickPositions=function(){var a=this.options,c=a.tickPositions;var d=this.getMinorTickInterval();var g=a.tickPositioner,h=this.hasVerticalPanning(),b="colorAxis"===this.coll,r=(b||
!h)&&a.startOnTick;h=(b||!h)&&a.endOnTick;this.tickmarkOffset=this.categories&&"between"===a.tickmarkPlacement&&1===this.tickInterval?.5:0;this.minorTickInterval="auto"===d&&this.tickInterval?this.tickInterval/5:d;this.single=this.min===this.max&&k(this.min)&&!this.tickAmount&&(parseInt(this.min,10)===this.min||!1!==a.allowDecimals);this.tickPositions=d=c&&c.slice();!d&&(this.ordinal&&this.ordinal.positions||!((this.max-this.min)/this.tickInterval>Math.max(2*this.len,200))?d=this.dateTime?this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval,
a.units),this.min,this.max,a.startOfWeek,this.ordinal&&this.ordinal.positions,this.closestPointRange,!0):this.logarithmic?this.logarithmic.getLogTickPositions(this.tickInterval,this.min,this.max):this.getLinearTickPositions(this.tickInterval,this.min,this.max):(d=[this.min,this.max],u(19,!1,this.chart)),d.length>this.len&&(d=[d[0],d.pop()],d[0]===d[1]&&(d.length=1)),this.tickPositions=d,g&&(g=g.apply(this,[this.min,this.max])))&&(this.tickPositions=d=g);this.paddedTicks=d.slice(0);this.trimTicks(d,
r,h);this.isLinked||(this.single&&2>d.length&&!this.categories&&!this.series.some(function(a){return a.is("heatmap")&&"between"===a.options.pointPlacement})&&(this.min-=.5,this.max+=.5),c||g||this.adjustTickAmount());J(this,"afterSetTickPositions")};e.prototype.trimTicks=function(a,c,d){var g=a[0],h=a[a.length-1],b=!this.isOrdinal&&this.minPointOffset||0;J(this,"trimTicks");if(!this.isLinked){if(c&&-Infinity!==g)this.min=g;else for(;this.min-b>a[0];)a.shift();if(d)this.max=h;else for(;this.max+b<
a[a.length-1];)a.pop();0===a.length&&k(g)&&!this.options.tickPositions&&a.push((h+g)/2)}};e.prototype.alignToOthers=function(){var a={},c,d=this.options;!1!==this.chart.options.chart.alignTicks&&d.alignTicks&&!1!==d.startOnTick&&!1!==d.endOnTick&&!this.logarithmic&&this.chart[this.coll].forEach(function(d){var g=d.options;g=[d.horiz?g.left:g.top,g.width,g.height,g.pane].join();d.series.length&&(a[g]?c=!0:a[g]=1)});return c};e.prototype.getTickAmount=function(){var a=this.options,c=a.tickAmount,d=
a.tickPixelInterval;!k(a.tickInterval)&&!c&&this.len<d&&!this.isRadial&&!this.logarithmic&&a.startOnTick&&a.endOnTick&&(c=2);!c&&this.alignToOthers()&&(c=Math.ceil(this.len/d)+1);4>c&&(this.finalTickAmt=c,c=5);this.tickAmount=c};e.prototype.adjustTickAmount=function(){var a=this.options,c=this.tickInterval,d=this.tickPositions,h=this.tickAmount,b=this.finalTickAmt,r=d&&d.length,e=y(this.threshold,this.softThreshold?0:null);if(this.hasData()&&g(this.min)&&g(this.max)){if(r<h){for(;d.length<h;)d.length%
2||this.min===e?d.push(q(d[d.length-1]+c)):d.unshift(q(d[0]-c));this.transA*=(r-1)/(h-1);this.min=a.startOnTick?d[0]:Math.min(this.min,d[0]);this.max=a.endOnTick?d[d.length-1]:Math.max(this.max,d[d.length-1])}else r>h&&(this.tickInterval*=2,this.setTickPositions());if(k(b)){for(c=a=d.length;c--;)(3===b&&1===c%2||2>=b&&0<c&&c<a-1)&&d.splice(c,1);this.finalTickAmt=void 0}}};e.prototype.setScale=function(){var a,c=!1,d=!1;this.series.forEach(function(a){c=c||a.isDirtyData||a.isDirty;d=d||a.xAxis&&a.xAxis.isDirty||
!1});this.setAxisSize();(a=this.len!==(this.old&&this.old.len))||c||d||this.isLinked||this.forceRedraw||this.userMin!==(this.old&&this.old.userMin)||this.userMax!==(this.old&&this.old.userMax)||this.alignToOthers()?(this.stacking&&this.stacking.resetStacks(),this.forceRedraw=!1,this.getSeriesExtremes(),this.setTickInterval(),this.isDirty||(this.isDirty=a||this.min!==(this.old&&this.old.min)||this.max!==(this.old&&this.old.max))):this.stacking&&this.stacking.cleanStacks();c&&this.panningState&&(this.panningState.isDirty=
!0);J(this,"afterSetScale")};e.prototype.setExtremes=function(a,c,d,g,h){var b=this,r=b.chart;d=y(d,!0);b.series.forEach(function(a){delete a.kdTree});h=n(h,{min:a,max:c});J(b,"setExtremes",h,function(){b.userMin=a;b.userMax=c;b.eventArgs=h;d&&r.redraw(g)})};e.prototype.zoom=function(a,c){var d=this,g=this.dataMin,h=this.dataMax,b=this.options,r=Math.min(g,y(b.min,g)),e=Math.max(h,y(b.max,h));a={newMin:a,newMax:c};J(this,"zoom",a,function(a){var c=a.newMin,b=a.newMax;if(c!==d.min||b!==d.max)d.allowZoomOutside||
(k(g)&&(c<r&&(c=r),c>e&&(c=e)),k(h)&&(b<r&&(b=r),b>e&&(b=e))),d.displayBtn="undefined"!==typeof c||"undefined"!==typeof b,d.setExtremes(c,b,!1,void 0,{trigger:"zoom"});a.zoomed=!0});return a.zoomed};e.prototype.setAxisSize=function(){var a=this.chart,c=this.options,d=c.offsets||[0,0,0,0],g=this.horiz,h=this.width=Math.round(L(y(c.width,a.plotWidth-d[3]+d[1]),a.plotWidth)),b=this.height=Math.round(L(y(c.height,a.plotHeight-d[0]+d[2]),a.plotHeight)),r=this.top=Math.round(L(y(c.top,a.plotTop+d[0]),a.plotHeight,
a.plotTop));c=this.left=Math.round(L(y(c.left,a.plotLeft+d[3]),a.plotWidth,a.plotLeft));this.bottom=a.chartHeight-b-r;this.right=a.chartWidth-h-c;this.len=Math.max(g?h:b,0);this.pos=g?c:r};e.prototype.getExtremes=function(){var a=this.logarithmic;return{min:a?q(a.lin2log(this.min)):this.min,max:a?q(a.lin2log(this.max)):this.max,dataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,userMax:this.userMax}};e.prototype.getThreshold=function(a){var c=this.logarithmic,d=c?c.lin2log(this.min):this.min;
c=c?c.lin2log(this.max):this.max;null===a||-Infinity===a?a=d:Infinity===a?a=c:d>a?a=d:c<a&&(a=c);return this.translate(a,0,1,0,1)};e.prototype.autoLabelAlign=function(a){var c=(y(a,0)-90*this.side+720)%360;a={align:"center"};J(this,"autoLabelAlign",a,function(a){15<c&&165>c?a.align="right":195<c&&345>c&&(a.align="left")});return a.align};e.prototype.tickSize=function(a){var c=this.options,d=c["tick"===a?"tickLength":"minorTickLength"],g=y(c["tick"===a?"tickWidth":"minorTickWidth"],"tick"===a&&this.isXAxis&&
!this.categories?1:0);if(g&&d){"inside"===c[a+"Position"]&&(d=-d);var h=[d,g]}a={tickSize:h};J(this,"afterTickSize",a);return a.tickSize};e.prototype.labelMetrics=function(){var a=this.tickPositions&&this.tickPositions[0]||0;return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize,this.ticks[a]&&this.ticks[a].label)};e.prototype.unsquish=function(){var a=this.options.labels,c=this.horiz,d=this.tickInterval,h=d,b=this.len/(((this.categories?1:0)+this.max-this.min)/d),r,e=a.rotation,
f=this.labelMetrics(),m,A=Number.MAX_VALUE,l=Math.max(this.max-this.min,0),n=function(a){var c=a/(b||1);c=1<c?Math.ceil(c):1;c*d>l&&Infinity!==a&&Infinity!==b&&l&&(c=Math.ceil(l/d));return q(c*d)};if(c){if(!a.staggerLines&&!a.step)if(g(e))var k=[e];else b<a.autoRotationLimit&&(k=a.autoRotation);k&&k.forEach(function(a){if(a===e||a&&-90<=a&&90>=a){m=n(Math.abs(f.h/Math.sin(Q*a)));var c=m+Math.abs(a/360);c<A&&(A=c,r=a,h=m)}})}else a.step||(h=n(f.h));this.autoRotation=k;this.labelRotation=y(r,g(e)?e:
0);return h};e.prototype.getSlotWidth=function(a){var c=this.chart,d=this.horiz,h=this.options.labels,b=Math.max(this.tickPositions.length-(this.categories?0:1),1),r=c.margin[3];if(a&&g(a.slotWidth))return a.slotWidth;if(d&&2>h.step)return h.rotation?0:(this.staggerLines||1)*this.len/b;if(!d){a=h.style.width;if(void 0!==a)return parseInt(String(a),10);if(r)return r-c.spacing[3]}return.33*c.chartWidth};e.prototype.renderUnsquish=function(){var c=this.chart,d=c.renderer,g=this.tickPositions,h=this.ticks,
b=this.options.labels,r=b.style,e=this.horiz,f=this.getSlotWidth(),m=Math.max(1,Math.round(f-2*b.padding)),A={},y=this.labelMetrics(),l=r.textOverflow,n=0;a(b.rotation)||(A.rotation=b.rotation||0);g.forEach(function(a){a=h[a];a.movedLabel&&a.replaceMovedLabel();a&&a.label&&a.label.textPxLength>n&&(n=a.label.textPxLength)});this.maxLabelLength=n;if(this.autoRotation)n>m&&n>y.h?A.rotation=this.labelRotation:this.labelRotation=0;else if(f){var k=m;if(!l){var L="clip";for(m=g.length;!e&&m--;){var u=g[m];
if(u=h[u].label)u.styles&&"ellipsis"===u.styles.textOverflow?u.css({textOverflow:"clip"}):u.textPxLength>f&&u.css({width:f+"px"}),u.getBBox().height>this.len/g.length-(y.h-y.f)&&(u.specificTextOverflow="ellipsis")}}}A.rotation&&(k=n>.5*c.chartHeight?.33*c.chartHeight:n,l||(L="ellipsis"));if(this.labelAlign=b.align||this.autoLabelAlign(this.labelRotation))A.align=this.labelAlign;g.forEach(function(a){var c=(a=h[a])&&a.label,d=r.width,g={};c&&(c.attr(A),a.shortenLabel?a.shortenLabel():k&&!d&&"nowrap"!==
r.whiteSpace&&(k<c.textPxLength||"SPAN"===c.element.tagName)?(g.width=k+"px",l||(g.textOverflow=c.specificTextOverflow||L),c.css(g)):c.styles&&c.styles.width&&!g.width&&!d&&c.css({width:null}),delete c.specificTextOverflow,a.rotation=A.rotation)},this);this.tickRotCorr=d.rotCorr(y.b,this.labelRotation||0,0!==this.side)};e.prototype.hasData=function(){return this.series.some(function(a){return a.hasData()})||this.options.showEmpty&&k(this.min)&&k(this.max)};e.prototype.addTitle=function(a){var c=this.chart.renderer,
d=this.horiz,g=this.opposite,b=this.options.title,r,e=this.chart.styledMode;this.axisTitle||((r=b.textAlign)||(r=(d?{low:"left",middle:"center",high:"right"}:{low:g?"right":"left",middle:"center",high:g?"left":"right"})[b.align]),this.axisTitle=c.text(b.text||"",0,0,b.useHTML).attr({zIndex:7,rotation:b.rotation,align:r}).addClass("highcharts-axis-title"),e||this.axisTitle.css(h(b.style)),this.axisTitle.add(this.axisGroup),this.axisTitle.isNew=!0);e||b.style.width||this.isRadial||this.axisTitle.css({width:this.len+
"px"});this.axisTitle[a?"show":"hide"](a)};e.prototype.generateTick=function(a){var c=this.ticks;c[a]?c[a].addLabel():c[a]=new G(this,a)};e.prototype.getOffset=function(){var a=this,c=this,d=c.chart,g=d.renderer,h=c.options,b=c.tickPositions,r=c.ticks,e=c.horiz,f=c.side,m=d.inverted&&!c.isZAxis?[1,0,3,2][f]:f,l,n=0,L=0,u=h.title,P=h.labels,q=0,v=d.axisOffset;d=d.clipOffset;var w=[-1,1,1,-1][f],da=h.className,ia=c.axisParent;var E=c.hasData();c.showAxis=l=E||h.showEmpty;c.staggerLines=c.horiz&&P.staggerLines||
void 0;if(!c.axisGroup){var R=function(c,d,h){return g.g(c).attr({zIndex:h}).addClass("highcharts-"+a.coll.toLowerCase()+d+" "+(a.isRadial?"highcharts-radial-axis"+d+" ":"")+(da||"")).add(ia)};c.gridGroup=R("grid","-grid",h.gridZIndex);c.axisGroup=R("axis","",h.zIndex);c.labelGroup=R("axis-labels","-labels",P.zIndex)}E||c.isLinked?(b.forEach(function(a,d){c.generateTick(a,d)}),c.renderUnsquish(),c.reserveSpaceDefault=0===f||2===f||{1:"left",3:"right"}[f]===c.labelAlign,y(P.reserveSpace,"center"===
c.labelAlign?!0:null,c.reserveSpaceDefault)&&b.forEach(function(a){q=Math.max(r[a].getLabelSize(),q)}),c.staggerLines&&(q*=c.staggerLines),c.labelOffset=q*(c.opposite?-1:1)):A(r,function(a,c){a.destroy();delete r[c]});if(u&&u.text&&!1!==u.enabled&&(c.addTitle(l),l&&!1!==u.reserveSpace)){c.titleOffset=n=c.axisTitle.getBBox()[e?"height":"width"];var Q=u.offset;L=k(Q)?0:y(u.margin,e?5:10)}c.renderLine();c.offset=w*y(h.offset,v[f]?v[f]+(h.margin||0):0);c.tickRotCorr=c.tickRotCorr||{x:0,y:0};u=0===f?-c.labelMetrics().h:
2===f?c.tickRotCorr.y:0;L=Math.abs(q)+L;q&&(L=L-u+w*(e?y(P.y,c.tickRotCorr.y+8*w):P.x));c.axisTitleMargin=y(Q,L);c.getMaxLabelDimensions&&(c.maxLabelDimensions=c.getMaxLabelDimensions(r,b));e=this.tickSize("tick");v[f]=Math.max(v[f],(c.axisTitleMargin||0)+n+w*c.offset,L,b&&b.length&&e?e[0]+w*c.offset:0);h=h.offset?0:2*Math.floor(c.axisLine.strokeWidth()/2);d[m]=Math.max(d[m],h);J(this,"afterGetOffset")};e.prototype.getLinePath=function(a){var c=this.chart,d=this.opposite,g=this.offset,h=this.horiz,
b=this.left+(d?this.width:0)+g;g=c.chartHeight-this.bottom-(d?this.height:0)+g;d&&(a*=-1);return c.renderer.crispLine([["M",h?this.left:b,h?g:this.top],["L",h?c.chartWidth-this.right:b,h?g:c.chartHeight-this.bottom]],a)};e.prototype.renderLine=function(){this.axisLine||(this.axisLine=this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup),this.chart.styledMode||this.axisLine.attr({stroke:this.options.lineColor,"stroke-width":this.options.lineWidth,zIndex:7}))};e.prototype.getTitlePosition=
function(){var a=this.horiz,c=this.left,d=this.top,g=this.len,h=this.options.title,b=a?c:d,r=this.opposite,e=this.offset,f=h.x,m=h.y,A=this.axisTitle,y=this.chart.renderer.fontMetrics(h.style.fontSize,A);A=Math.max(A.getBBox(null,0).height-y.h-1,0);g={low:b+(a?0:g),middle:b+g/2,high:b+(a?g:0)}[h.align];c=(a?d+this.height:c)+(a?1:-1)*(r?-1:1)*this.axisTitleMargin+[-A,A,y.f,-A][this.side];a={x:a?g+f:c+(r?this.width:0)+e+f,y:a?c+m-(r?this.height:0)+e:g+m};J(this,"afterGetTitlePosition",{titlePosition:a});
return a};e.prototype.renderMinorTick=function(a){var c=this.chart.hasRendered&&this.old,d=this.minorTicks;d[a]||(d[a]=new G(this,a,"minor"));c&&d[a].isNew&&d[a].render(null,!0);d[a].render(null,!1,1)};e.prototype.renderTick=function(a,c){var d=this.ticks,g=this.chart.hasRendered&&this.old;if(!this.isLinked||a>=this.min&&a<=this.max||this.grid&&this.grid.isColumn)d[a]||(d[a]=new G(this,a)),g&&d[a].isNew&&d[a].render(c,!0,-1),d[a].render(c)};e.prototype.render=function(){var a=this,c=a.chart,d=a.logarithmic,
h=a.options,b=a.isLinked,r=a.tickPositions,e=a.axisTitle,f=a.ticks,m=a.minorTicks,y=a.alternateBands,l=h.stackLabels,n=h.alternateGridColor,k=a.tickmarkOffset,L=a.axisLine,u=a.showAxis,q=B(c.renderer.globalAnimation),P,v;a.labelEdge.length=0;a.overlap=!1;[f,m,y].forEach(function(a){A(a,function(a){a.isActive=!1})});if(a.hasData()||b)a.minorTickInterval&&!a.categories&&a.getMinorTickPositions().forEach(function(c){a.renderMinorTick(c)}),r.length&&(r.forEach(function(c,d){a.renderTick(c,d)}),k&&(0===
a.min||a.single)&&(f[-1]||(f[-1]=new G(a,-1,null,!0)),f[-1].render(-1))),n&&r.forEach(function(g,h){v="undefined"!==typeof r[h+1]?r[h+1]+k:a.max-k;0===h%2&&g<a.max&&v<=a.max+(c.polar?-k:k)&&(y[g]||(y[g]=new I.PlotLineOrBand(a)),P=g+k,y[g].options={from:d?d.lin2log(P):P,to:d?d.lin2log(v):v,color:n,className:"highcharts-alternate-grid"},y[g].render(),y[g].isActive=!0)}),a._addedPlotLB||(a._addedPlotLB=!0,(h.plotLines||[]).concat(h.plotBands||[]).forEach(function(c){a.addPlotBandOrLine(c)}));[f,m,y].forEach(function(a){var d,
g=[],h=q.duration;A(a,function(a,c){a.isActive||(a.render(c,!1,0),a.isActive=!1,g.push(c))});V(function(){for(d=g.length;d--;)a[g[d]]&&!a[g[d]].isActive&&(a[g[d]].destroy(),delete a[g[d]])},a!==y&&c.hasRendered&&h?h:0)});L&&(L[L.isPlaced?"animate":"attr"]({d:this.getLinePath(L.strokeWidth())}),L.isPlaced=!0,L[u?"show":"hide"](u));e&&u&&(h=a.getTitlePosition(),g(h.y)?(e[e.isNew?"attr":"animate"](h),e.isNew=!1):(e.attr("y",-9999),e.isNew=!0));l&&l.enabled&&a.stacking&&a.stacking.renderStackTotals();
a.old={len:a.len,max:a.max,min:a.min,transA:a.transA,userMax:a.userMax,userMin:a.userMin};a.isDirty=!1;J(this,"afterRender")};e.prototype.redraw=function(){this.visible&&(this.render(),this.plotLinesAndBands.forEach(function(a){a.render()}));this.series.forEach(function(a){a.isDirty=!0})};e.prototype.getKeepProps=function(){return this.keepProps||e.keepProps};e.prototype.destroy=function(a){var c=this,d=c.plotLinesAndBands,g;J(this,"destroy",{keepEvents:a});a||P(c);[c.ticks,c.minorTicks,c.alternateBands].forEach(function(a){l(a)});
if(d)for(a=d.length;a--;)d[a].destroy();"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function(a){c[a]&&(c[a]=c[a].destroy())});for(g in c.plotLinesAndBandsGroups)c.plotLinesAndBandsGroups[g]=c.plotLinesAndBandsGroups[g].destroy();A(c,function(a,d){-1===c.getKeepProps().indexOf(d)&&delete c[d]})};e.prototype.drawCrosshair=function(a,c){var d=this.crosshair,g=y(d&&d.snap,!0),h,r=this.cross,e=this.chart;J(this,"drawCrosshair",{e:a,point:c});a||(a=this.cross&&
this.cross.e);if(d&&!1!==(k(c)||!g)){g?k(c)&&(h=y("colorAxis"!==this.coll?c.crosshairPos:null,this.isXAxis?c.plotX:this.len-c.plotY)):h=a&&(this.horiz?a.chartX-this.pos:this.len-a.chartY+this.pos);if(k(h)){var f={value:c&&(this.isXAxis?c.x:y(c.stackY,c.y)),translatedValue:h};e.polar&&n(f,{isCrosshair:!0,chartX:a&&a.chartX,chartY:a&&a.chartY,point:c});f=this.getPlotLinePath(f)||null}if(!k(f)){this.hideCrosshair();return}g=this.categories&&!this.isRadial;r||(this.cross=r=e.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-"+
(g?"category ":"thin ")+(d.className||"")).attr({zIndex:y(d.zIndex,2)}).add(),e.styledMode||(r.attr({stroke:d.color||(g?b.parse(z.highlightColor20).setOpacity(.25).get():z.neutralColor20),"stroke-width":y(d.width,1)}).css({"pointer-events":"none"}),d.dashStyle&&r.attr({dashstyle:d.dashStyle})));r.show().attr({d:f});g&&!d.width&&r.attr({"stroke-width":this.transA});this.cross.e=a}else this.hideCrosshair();J(this,"afterDrawCrosshair",{e:a,point:c})};e.prototype.hideCrosshair=function(){this.cross&&
this.cross.hide();J(this,"afterHideCrosshair")};e.prototype.hasVerticalPanning=function(){var a=this.chart.options.chart.panning;return!!(a&&a.enabled&&/y/.test(a.type))};e.prototype.validatePositiveValue=function(a){return g(a)&&0<a};e.prototype.update=function(a,c){var d=this.chart,g=a&&a.events||{};a=h(this.userOptions,a);A(d.options[this.coll].events,function(a,c){"undefined"===typeof g[c]&&(g[c]=void 0)});this.destroy(!0);this.init(d,n(a,{events:g}));d.isDirtyBox=!0;y(c,!0)&&d.redraw()};e.prototype.remove=
function(a){for(var c=this.chart,d=this.coll,g=this.series,h=g.length;h--;)g[h]&&g[h].remove(!1);N(c.axes,this);N(c[d],this);c[d].forEach(function(a,c){a.options.index=a.userOptions.index=c});this.destroy();c.isDirtyBox=!0;y(a,!0)&&c.redraw()};e.prototype.setTitle=function(a,c){this.update({title:a},c)};e.prototype.setCategories=function(a,c){this.update({categories:a},c)};e.defaultOptions={alignTicks:!0,allowDecimals:void 0,zIndex:2,zoomEnabled:!0,dateTimeLabelFormats:{millisecond:{main:"%H:%M:%S.%L",
range:!1},second:{main:"%H:%M:%S",range:!1},minute:{main:"%H:%M",range:!1},hour:{main:"%H:%M",range:!1},day:{main:"%e. %b"},week:{main:"%e. %b"},month:{main:"%b '%y"},year:{main:"%Y"}},endOnTick:!1,gridLineDashStyle:"Solid",gridZIndex:1,labels:{autoRotation:void 0,autoRotationLimit:80,distance:void 0,enabled:!0,indentation:10,overflow:"justify",padding:5,reserveSpace:void 0,rotation:void 0,staggerLines:0,step:0,useHTML:!1,x:0,zIndex:7,style:{color:z.neutralColor60,cursor:"default",fontSize:"11px"}},
maxPadding:.01,minorGridLineDashStyle:"Solid",minorTickLength:2,minorTickPosition:"outside",minPadding:.01,offset:void 0,opposite:!1,reversed:void 0,reversedStacks:!1,showEmpty:!0,showFirstLabel:!0,showLastLabel:!0,startOfWeek:1,startOnTick:!1,tickLength:10,tickPixelInterval:100,tickmarkPlacement:"between",tickPosition:"outside",title:{align:"middle",rotation:0,useHTML:!1,x:0,y:0,style:{color:z.neutralColor60}},type:"linear",uniqueNames:!0,visible:!0,minorGridLineColor:z.neutralColor5,minorGridLineWidth:1,
minorTickColor:z.neutralColor40,lineColor:z.highlightColor20,lineWidth:1,gridLineColor:z.neutralColor10,gridLineWidth:void 0,tickColor:z.highlightColor20};e.defaultYAxisOptions={reversedStacks:!0,endOnTick:!0,maxPadding:.05,minPadding:.05,tickPixelInterval:72,showLastLabel:!0,labels:{x:-8},startOnTick:!0,title:{rotation:270,text:"Values"},stackLabels:{animation:{},allowOverlap:!1,enabled:!1,crop:!0,overflow:"justify",formatter:function(){var a=this.axis.chart.numberFormatter;return a(this.total,-1)},
style:{color:z.neutralColor100,fontSize:"11px",fontWeight:"bold",textOutline:"1px contrast"}},gridLineWidth:1,lineWidth:0};e.defaultLeftAxisOptions={labels:{x:-15},title:{rotation:270}};e.defaultRightAxisOptions={labels:{x:15},title:{rotation:90}};e.defaultBottomAxisOptions={labels:{autoRotation:[-45],x:0},margin:15,title:{rotation:0}};e.defaultTopAxisOptions={labels:{autoRotation:[-45],x:0},margin:15,title:{rotation:0}};e.keepProps="extKey hcEvents names series userMax userMin".split(" ");return e}();
I.Axis=e;return I.Axis});O(e,"Core/Axis/DateTimeAxis.js",[e["Core/Axis/Axis.js"],e["Core/Utilities.js"]],function(e,b){var D=b.addEvent,z=b.getMagnitude,H=b.normalizeTickInterval,G=b.timeUnits,C=function(){function b(b){this.axis=b}b.prototype.normalizeTimeTickInterval=function(b,e){var v=e||[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1,2]],["week",[1,2]],["month",[1,2,3,4,6]],["year",null]];e=v[v.length-
1];var f=G[e[0]],d=e[1],q;for(q=0;q<v.length&&!(e=v[q],f=G[e[0]],d=e[1],v[q+1]&&b<=(f*d[d.length-1]+G[v[q+1][0]])/2);q++);f===G.year&&b<5*f&&(d=[1,2,5]);b=H(b/f,d,"year"===e[0]?Math.max(z(b/f),1):1);return{unitRange:f,count:b,unitName:e[0]}};return b}();b=function(){function b(){}b.compose=function(b){b.keepProps.push("dateTime");b.prototype.getTimeTicks=function(){return this.chart.time.getTimeTicks.apply(this.chart.time,arguments)};D(b,"init",function(b){"datetime"!==b.userOptions.type?this.dateTime=
void 0:this.dateTime||(this.dateTime=new C(this))})};b.AdditionsClass=C;return b}();b.compose(e);return b});O(e,"Core/Axis/LogarithmicAxis.js",[e["Core/Axis/Axis.js"],e["Core/Utilities.js"]],function(e,b){var D=b.addEvent,z=b.getMagnitude,H=b.normalizeTickInterval,G=b.pick,C=function(){function b(b){this.axis=b}b.prototype.getLogTickPositions=function(b,e,v,f){var d=this.axis,q=d.len,k=d.options,l=[];f||(this.minorAutoInterval=void 0);if(.5<=b)b=Math.round(b),l=d.getLinearTickPositions(b,e,v);else if(.08<=
b){var w=Math.floor(e),u,n=k=void 0;for(q=.3<b?[1,2,4]:.15<b?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9];w<v+1&&!n;w++){var J=q.length;for(u=0;u<J&&!n;u++){var E=this.log2lin(this.lin2log(w)*q[u]);E>e&&(!f||k<=v)&&"undefined"!==typeof k&&l.push(k);k>v&&(n=!0);k=E}}}else e=this.lin2log(e),v=this.lin2log(v),b=f?d.getMinorTickInterval():k.tickInterval,b=G("auto"===b?null:b,this.minorAutoInterval,k.tickPixelInterval/(f?5:1)*(v-e)/((f?q/d.tickPositions.length:q)||1)),b=H(b,void 0,z(b)),l=d.getLinearTickPositions(b,
e,v).map(this.log2lin),f||(this.minorAutoInterval=b/5);f||(d.tickInterval=b);return l};b.prototype.lin2log=function(b){return Math.pow(10,b)};b.prototype.log2lin=function(b){return Math.log(b)/Math.LN10};return b}();b=function(){function b(){}b.compose=function(b){b.keepProps.push("logarithmic");D(b,"init",function(b){var e=this.logarithmic;"logarithmic"!==b.userOptions.type?this.logarithmic=void 0:e||(this.logarithmic=new C(this))});D(b,"afterInit",function(){var b=this.logarithmic;b&&(this.lin2val=
function(e){return b.lin2log(e)},this.val2lin=function(e){return b.log2lin(e)})})};return b}();b.compose(e);return b});O(e,"Core/Axis/PlotLineOrBand.js",[e["Core/Axis/Axis.js"],e["Core/Globals.js"],e["Core/Color/Palette.js"],e["Core/Utilities.js"]],function(e,b,I,z){var D=z.arrayMax,G=z.arrayMin,C=z.defined,B=z.destroyObjectProperties,x=z.erase,w=z.extend,v=z.fireEvent,f=z.isNumber,d=z.merge,q=z.objectEach,k=z.pick;z=function(){function b(d,b){this.axis=d;b&&(this.options=b,this.id=b.id)}b.prototype.render=
function(){v(this,"render");var b=this,e=b.axis,f=e.horiz,l=e.logarithmic,E=b.options,m=E.label,c=b.label,g=E.to,a=E.from,h=E.value,r=C(a)&&C(g),A=C(h),y=b.svgElem,L=!y,P=[],R=E.color,w=k(E.zIndex,0),Q=E.events;P={"class":"highcharts-plot-"+(r?"band ":"line ")+(E.className||"")};var M={},t=e.chart.renderer,p=r?"bands":"lines";l&&(a=l.log2lin(a),g=l.log2lin(g),h=l.log2lin(h));e.chart.styledMode||(A?(P.stroke=R||I.neutralColor40,P["stroke-width"]=k(E.width,1),E.dashStyle&&(P.dashstyle=E.dashStyle)):
r&&(P.fill=R||I.highlightColor10,E.borderWidth&&(P.stroke=E.borderColor,P["stroke-width"]=E.borderWidth)));M.zIndex=w;p+="-"+w;(l=e.plotLinesAndBandsGroups[p])||(e.plotLinesAndBandsGroups[p]=l=t.g("plot-"+p).attr(M).add());L&&(b.svgElem=y=t.path().attr(P).add(l));if(A)P=e.getPlotLinePath({value:h,lineWidth:y.strokeWidth(),acrossPanes:E.acrossPanes});else if(r)P=e.getPlotBandPath(a,g,E);else return;!b.eventsAdded&&Q&&(q(Q,function(a,c){y.on(c,function(a){Q[c].apply(b,[a])})}),b.eventsAdded=!0);(L||
!y.d)&&P&&P.length?y.attr({d:P}):y&&(P?(y.show(!0),y.animate({d:P})):y.d&&(y.hide(),c&&(b.label=c=c.destroy())));m&&(C(m.text)||C(m.formatter))&&P&&P.length&&0<e.width&&0<e.height&&!P.isFlat?(m=d({align:f&&r&&"center",x:f?!r&&4:10,verticalAlign:!f&&r&&"middle",y:f?r?16:10:r?6:-4,rotation:f&&!r&&90},m),this.renderLabel(m,P,r,w)):c&&c.hide();return b};b.prototype.renderLabel=function(d,b,e,f){var l=this.label,m=this.axis.chart.renderer;l||(l={align:d.textAlign||d.align,rotation:d.rotation,"class":"highcharts-plot-"+
(e?"band":"line")+"-label "+(d.className||"")},l.zIndex=f,f=this.getLabelText(d),this.label=l=m.text(f,0,0,d.useHTML).attr(l).add(),this.axis.chart.styledMode||l.css(d.style));m=b.xBounds||[b[0][1],b[1][1],e?b[2][1]:b[0][1]];b=b.yBounds||[b[0][2],b[1][2],e?b[2][2]:b[0][2]];e=G(m);f=G(b);l.align(d,!1,{x:e,y:f,width:D(m)-e,height:D(b)-f});l.show(!0)};b.prototype.getLabelText=function(d){return C(d.formatter)?d.formatter.call(this):d.text};b.prototype.destroy=function(){x(this.axis.plotLinesAndBands,
this);delete this.axis;B(this)};return b}();w(e.prototype,{getPlotBandPath:function(d,b,e){void 0===e&&(e=this.options);var l=this.getPlotLinePath({value:b,force:!0,acrossPanes:e.acrossPanes});e=this.getPlotLinePath({value:d,force:!0,acrossPanes:e.acrossPanes});var k=[],q=this.horiz,m=1;d=!f(this.min)||!f(this.max)||d<this.min&&b<this.min||d>this.max&&b>this.max;if(e&&l){if(d){var c=e.toString()===l.toString();m=0}for(d=0;d<e.length;d+=2){b=e[d];var g=e[d+1],a=l[d],h=l[d+1];"M"!==b[0]&&"L"!==b[0]||
"M"!==g[0]&&"L"!==g[0]||"M"!==a[0]&&"L"!==a[0]||"M"!==h[0]&&"L"!==h[0]||(q&&a[1]===b[1]?(a[1]+=m,h[1]+=m):q||a[2]!==b[2]||(a[2]+=m,h[2]+=m),k.push(["M",b[1],b[2]],["L",g[1],g[2]],["L",h[1],h[2]],["L",a[1],a[2]],["Z"]));k.isFlat=c}}return k},addPlotBand:function(d){return this.addPlotBandOrLine(d,"plotBands")},addPlotLine:function(d){return this.addPlotBandOrLine(d,"plotLines")},addPlotBandOrLine:function(d,e){var f=this,l=new b.PlotLineOrBand(this,d),k=this.userOptions;this.visible&&(l=l.render());
if(l){this._addedPlotLB||(this._addedPlotLB=!0,(k.plotLines||[]).concat(k.plotBands||[]).forEach(function(d){f.addPlotBandOrLine(d)}));if(e){var q=k[e]||[];q.push(d);k[e]=q}this.plotLinesAndBands.push(l)}return l},removePlotBandOrLine:function(d){for(var b=this.plotLinesAndBands,e=this.options,f=this.userOptions,l=b.length;l--;)b[l].id===d&&b[l].destroy();[e.plotLines||[],f.plotLines||[],e.plotBands||[],f.plotBands||[]].forEach(function(b){for(l=b.length;l--;)(b[l]||{}).id===d&&x(b,b[l])})},removePlotBand:function(d){this.removePlotBandOrLine(d)},
removePlotLine:function(d){this.removePlotBandOrLine(d)}});b.PlotLineOrBand=z;return b.PlotLineOrBand});O(e,"Core/Tooltip.js",[e["Core/FormatUtilities.js"],e["Core/Globals.js"],e["Core/Color/Palette.js"],e["Core/Utilities.js"]],function(e,b,I,z){var D=e.format,G=b.doc,C=z.clamp,B=z.css,x=z.defined,w=z.discardElement,v=z.extend,f=z.fireEvent,d=z.isArray,q=z.isNumber,k=z.isString,l=z.merge,N=z.pick,u=z.splat,n=z.syncTimeout,J=z.timeUnits;"";e=function(){function e(d,c){this.container=void 0;this.crosshairs=
[];this.distance=0;this.isHidden=!0;this.isSticky=!1;this.now={};this.options={};this.outside=!1;this.chart=d;this.init(d,c)}e.prototype.applyFilter=function(){var d=this.chart;d.renderer.definition({tagName:"filter",attributes:{id:"drop-shadow-"+d.index,opacity:.5},children:[{tagName:"feGaussianBlur",attributes:{"in":"SourceAlpha",stdDeviation:1}},{tagName:"feOffset",attributes:{dx:1,dy:1}},{tagName:"feComponentTransfer",children:[{tagName:"feFuncA",attributes:{type:"linear",slope:.3}}]},{tagName:"feMerge",
children:[{tagName:"feMergeNode"},{tagName:"feMergeNode",attributes:{"in":"SourceGraphic"}}]}]});d.renderer.definition({tagName:"style",textContent:".highcharts-tooltip-"+d.index+"{filter:url(#drop-shadow-"+d.index+")}"})};e.prototype.bodyFormatter=function(d){return d.map(function(c){var d=c.series.tooltipOptions;return(d[(c.point.formatPrefix||"point")+"Formatter"]||c.point.tooltipFormatter).call(c.point,d[(c.point.formatPrefix||"point")+"Format"]||"")})};e.prototype.cleanSplit=function(d){this.chart.series.forEach(function(c){var b=
c&&c.tt;b&&(!b.isActive||d?c.tt=b.destroy():b.isActive=!1)})};e.prototype.defaultFormatter=function(d){var c=this.points||u(this);var b=[d.tooltipFooterHeaderFormatter(c[0])];b=b.concat(d.bodyFormatter(c));b.push(d.tooltipFooterHeaderFormatter(c[0],!0));return b};e.prototype.destroy=function(){this.label&&(this.label=this.label.destroy());this.split&&this.tt&&(this.cleanSplit(this.chart,!0),this.tt=this.tt.destroy());this.renderer&&(this.renderer=this.renderer.destroy(),w(this.container));z.clearTimeout(this.hideTimer);
z.clearTimeout(this.tooltipTimeout)};e.prototype.getAnchor=function(d,c){var b=this.chart;var a=b.pointer;var h=b.inverted,e=b.plotTop,f=b.plotLeft,m=0,l=0,k,n;d=u(d);this.followPointer&&c?("undefined"===typeof c.chartX&&(c=a.normalize(c)),a=[c.chartX-f,c.chartY-e]):d[0].tooltipPos?a=d[0].tooltipPos:(d.forEach(function(a){k=a.series.yAxis;n=a.series.xAxis;m+=a.plotX||0;l+=a.plotLow?(a.plotLow+(a.plotHigh||0))/2:a.plotY||0;n&&k&&(h?(m+=e+b.plotHeight-n.len-n.pos,l+=f+b.plotWidth-k.len-k.pos):(m+=n.pos-
f,l+=k.pos-e))}),m/=d.length,l/=d.length,a=[h?b.plotWidth-l:m,h?b.plotHeight-m:l],this.shared&&1<d.length&&c&&(h?a[0]=c.chartX-f:a[1]=c.chartY-e));return a.map(Math.round)};e.prototype.getDateFormat=function(d,c,b,a){var h=this.chart.time,g=h.dateFormat("%m-%d %H:%M:%S.%L",c),e={millisecond:15,second:12,minute:9,hour:6,day:3},f="millisecond";for(m in J){if(d===J.week&&+h.dateFormat("%w",c)===b&&"00:00:00.000"===g.substr(6)){var m="week";break}if(J[m]>d){m=f;break}if(e[m]&&g.substr(e[m])!=="01-01 00:00:00.000".substr(e[m]))break;
"week"!==m&&(f=m)}if(m)var l=h.resolveDTLFormat(a[m]).main;return l};e.prototype.getLabel=function(){var d=this,c=this.chart.renderer,g=this.chart.styledMode,a=this.options,h="tooltip"+(x(a.className)?" "+a.className:""),e=a.style&&a.style.pointerEvents||(!this.followPointer&&a.stickOnContact?"auto":"none"),f,y=function(){d.inContact=!0},l=function(){var a=d.chart.hoverSeries;d.inContact=!1;if(a&&a.onMouseOut)a.onMouseOut()};if(!this.label){if(this.outside){var k=this.chart.options.chart.style;this.container=
f=b.doc.createElement("div");f.className="highcharts-tooltip-container";B(f,{position:"absolute",top:"1px",pointerEvents:e,zIndex:Math.max(this.options.style&&this.options.style.zIndex||0,(k&&k.zIndex||0)+3)});b.doc.body.appendChild(f);this.renderer=c=new b.Renderer(f,0,0,k,void 0,void 0,c.styledMode)}this.split?this.label=c.g(h):(this.label=c.label("",0,0,a.shape||"callout",null,null,a.useHTML,null,h).attr({padding:a.padding,r:a.borderRadius}),g||this.label.attr({fill:a.backgroundColor,"stroke-width":a.borderWidth}).css(a.style).css({pointerEvents:e}).shadow(a.shadow));
g&&(this.applyFilter(),this.label.addClass("highcharts-tooltip-"+this.chart.index));if(d.outside&&!d.split){var n=this.label,q=n.xSetter,u=n.ySetter;n.xSetter=function(a){q.call(n,d.distance);f.style.left=a+"px"};n.ySetter=function(a){u.call(n,d.distance);f.style.top=a+"px"}}this.label.on("mouseenter",y).on("mouseleave",l).attr({zIndex:8}).add()}return this.label};e.prototype.getPosition=function(d,c,b){var a=this.chart,h=this.distance,g={},e=a.inverted&&b.h||0,f,m=this.outside,l=m?G.documentElement.clientWidth-
2*h:a.chartWidth,k=m?Math.max(G.body.scrollHeight,G.documentElement.scrollHeight,G.body.offsetHeight,G.documentElement.offsetHeight,G.documentElement.clientHeight):a.chartHeight,n=a.pointer.getChartPosition(),q=function(g){var e="x"===g;return[g,e?l:k,e?d:c].concat(m?[e?d*n.scaleX:c*n.scaleY,e?n.left-h+(b.plotX+a.plotLeft)*n.scaleX:n.top-h+(b.plotY+a.plotTop)*n.scaleY,0,e?l:k]:[e?d:c,e?b.plotX+a.plotLeft:b.plotY+a.plotTop,e?a.plotLeft:a.plotTop,e?a.plotLeft+a.plotWidth:a.plotTop+a.plotHeight])},u=
q("y"),t=q("x"),p=!this.followPointer&&N(b.ttBelow,!a.inverted===!!b.negative),v=function(a,c,d,b,r,f,A){var y=m?"y"===a?h*n.scaleY:h*n.scaleX:h,l=(d-b)/2,F=b<r-h,k=r+h+b<c,K=r-y-d+l;r=r+y-l;if(p&&k)g[a]=r;else if(!p&&F)g[a]=K;else if(F)g[a]=Math.min(A-b,0>K-e?K:K-e);else if(k)g[a]=Math.max(f,r+e+d>c?r:r+e);else return!1},w=function(a,c,d,b,e){var r;e<h||e>c-h?r=!1:g[a]=e<d/2?1:e>c-b/2?c-b-2:e-d/2;return r},E=function(a){var c=u;u=t;t=c;f=a},F=function(){!1!==v.apply(0,u)?!1!==w.apply(0,t)||f||(E(!0),
F()):f?g.x=g.y=0:(E(!0),F())};(a.inverted||1<this.len)&&E();F();return g};e.prototype.getXDateFormat=function(d,c,b){c=c.dateTimeLabelFormats;var a=b&&b.closestPointRange;return(a?this.getDateFormat(a,d.x,b.options.startOfWeek,c):c.day)||c.year};e.prototype.hide=function(d){var c=this;z.clearTimeout(this.hideTimer);d=N(d,this.options.hideDelay,500);this.isHidden||(this.hideTimer=n(function(){c.getLabel().fadeOut(d?void 0:d);c.isHidden=!0},d))};e.prototype.init=function(d,c){this.chart=d;this.options=
c;this.crosshairs=[];this.now={x:0,y:0};this.isHidden=!0;this.split=c.split&&!d.inverted&&!d.polar;this.shared=c.shared||this.split;this.outside=N(c.outside,!(!d.scrollablePixelsX&&!d.scrollablePixelsY))};e.prototype.isStickyOnContact=function(){return!(this.followPointer||!this.options.stickOnContact||!this.inContact)};e.prototype.move=function(d,c,b,a){var h=this,g=h.now,e=!1!==h.options.animation&&!h.isHidden&&(1<Math.abs(d-g.x)||1<Math.abs(c-g.y)),f=h.followPointer||1<h.len;v(g,{x:e?(2*g.x+d)/
3:d,y:e?(g.y+c)/2:c,anchorX:f?void 0:e?(2*g.anchorX+b)/3:b,anchorY:f?void 0:e?(g.anchorY+a)/2:a});h.getLabel().attr(g);h.drawTracker();e&&(z.clearTimeout(this.tooltipTimeout),this.tooltipTimeout=setTimeout(function(){h&&h.move(d,c,b,a)},32))};e.prototype.refresh=function(b,c){var g=this.chart,a=this.options,h=u(b),e=h[0],m={},y=[],l=a.formatter||this.defaultFormatter;m=this.shared;var k=g.styledMode;if(a.enabled){z.clearTimeout(this.hideTimer);this.followPointer=!this.split&&e.series.tooltipOptions.followPointer;
var n=this.getAnchor(b,c);var q=n[0];var v=n[1];!m||!d(b)&&b.series&&b.series.noSharedTooltip?m=e.getLabelConfig():(g.pointer.applyInactiveState(h),h.forEach(function(a){a.setState("hover");y.push(a.getLabelConfig())}),m={x:e.category,y:e.y},m.points=y);this.len=y.length;b=l.call(m,this);l=e.series;this.distance=N(l.tooltipOptions.distance,16);if(!1===b)this.hide();else{if(this.split)this.renderSplit(b,h);else if(h=q,m=v,c&&g.pointer.isDirectTouch&&(h=c.chartX-g.plotLeft,m=c.chartY-g.plotTop),g.polar||
!1===l.options.clip||l.shouldShowTooltip(h,m))c=this.getLabel(),a.style.width&&!k||c.css({width:this.chart.spacingBox.width+"px"}),c.attr({text:b&&b.join?b.join(""):b}),c.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-"+N(e.colorIndex,l.colorIndex)),k||c.attr({stroke:a.borderColor||e.color||l.color||I.neutralColor60}),this.updatePosition({plotX:q,plotY:v,negative:e.negative,ttBelow:e.ttBelow,h:n[2]||0});else{this.hide();return}this.isHidden&&this.label&&this.label.attr({opacity:1}).show();
this.isHidden=!1}f(this,"refresh")}};e.prototype.renderSplit=function(d,c){function g(c,d,b,g,h){void 0===h&&(h=!0);b?(d=X?0:ba,c=C(c-g/2,S.left,S.right-g-(a.outside?U:0))):(d-=B,c=h?c-g-J:c+J,c=C(c,h?c:S.left,S.right));return{x:c,y:d}}var a=this,h=a.chart,e=a.chart,f=e.chartWidth,m=e.chartHeight,l=e.plotHeight,n=e.plotLeft,q=e.plotTop,u=e.pointer,w=e.scrollablePixelsY;w=void 0===w?0:w;var E=e.scrollablePixelsX,t=e.scrollingContainer;t=void 0===t?{scrollLeft:0,scrollTop:0}:t;var p=t.scrollLeft;t=
t.scrollTop;var x=e.styledMode,J=a.distance,D=a.options,F=a.options.positioner,S=a.outside&&"number"!==typeof E?G.documentElement.getBoundingClientRect():{left:p,right:p+f,top:t,bottom:t+m},K=a.getLabel(),T=this.renderer||h.renderer,X=!(!h.xAxis[0]||!h.xAxis[0].opposite);h=u.getChartPosition();var U=h.left;h=h.top;var B=q+t,z=0,ba=l-w;k(d)&&(d=[!1,d]);d=d.slice(0,c.length+1).reduce(function(d,b,h){if(!1!==b&&""!==b){h=c[h-1]||{isHeader:!0,plotX:c[0].plotX,plotY:l,series:{}};var e=h.isHeader,r=e?a:
h.series;b=b.toString();var f=r.tt,m=h.isHeader;var A=h.series;var y="highcharts-color-"+N(h.colorIndex,A.colorIndex,"none");f||(f={padding:D.padding,r:D.borderRadius},x||(f.fill=D.backgroundColor,f["stroke-width"]=D.borderWidth),f=T.label("",0,0,D[m?"headerShape":"shape"]||"callout",void 0,void 0,D.useHTML).addClass((m?"highcharts-tooltip-header ":"")+"highcharts-tooltip-box "+y).attr(f).add(K));f.isActive=!0;f.attr({text:b});x||f.css(D.style).shadow(D.shadow).attr({stroke:D.borderColor||h.color||
A.color||I.neutralColor80});r=r.tt=f;m=r.getBBox();b=m.width+r.strokeWidth();e&&(z=m.height,ba+=z,X&&(B-=z));A=h.plotX;A=void 0===A?0:A;y=h.plotY;y=void 0===y?0:y;f=h.series;if(h.isHeader){A=n+A;var k=q+l/2}else{var p=f.xAxis,t=f.yAxis;A=p.pos+C(A,-J,p.len+J);f.shouldShowTooltip(0,t.pos-q+y,{ignoreX:!0})&&(k=t.pos+y)}A=C(A,S.left-J,S.right+J);"number"===typeof k?(m=m.height+1,y=F?F.call(a,b,m,h):g(A,k,e,b),d.push({align:F?0:void 0,anchorX:A,anchorY:k,boxWidth:b,point:h,rank:N(y.rank,e?1:0),size:m,
target:y.y,tt:r,x:y.x})):r.isActive=!1}return d},[]);!F&&d.some(function(c){var d=(a.outside?U:0)+c.anchorX;return d<S.left&&d+c.boxWidth<S.right?!0:d<U-S.left+c.boxWidth&&S.right-d>d})&&(d=d.map(function(a){var c=g(a.anchorX,a.anchorY,a.point.isHeader,a.boxWidth,!1);return v(a,{target:c.y,x:c.x})}));a.cleanSplit();b.distribute(d,ba);var H=U,ca=U;d.forEach(function(c){var d=c.x,b=c.boxWidth;c=c.isHeader;c||(a.outside&&U+d<H&&(H=U+d),!c&&a.outside&&H+b>ca&&(ca=U+d))});d.forEach(function(c){var d=c.x,
b=c.anchorX,h=c.pos,g=c.point.isHeader;h={visibility:"undefined"===typeof h?"hidden":"inherit",x:d,y:h+B,anchorX:b,anchorY:c.anchorY};if(a.outside&&d<b){var e=U-H;0<e&&(g||(h.x=d+e,h.anchorX=b+e),g&&(h.x=(ca-H)/2,h.anchorX=b+e))}c.tt.attr(h)});d=a.container;w=a.renderer;a.outside&&d&&w&&(e=K.getBBox(),w.setSize(e.width+e.x,e.height+e.y,!1),d.style.left=H+"px",d.style.top=h+"px")};e.prototype.drawTracker=function(){if(this.followPointer||!this.options.stickOnContact)this.tracker&&this.tracker.destroy();
else{var d=this.chart,c=this.label,b=d.hoverPoint;if(c&&b){var a={x:0,y:0,width:0,height:0};b=this.getAnchor(b);var h=c.getBBox();b[0]+=d.plotLeft-c.translateX;b[1]+=d.plotTop-c.translateY;a.x=Math.min(0,b[0]);a.y=Math.min(0,b[1]);a.width=0>b[0]?Math.max(Math.abs(b[0]),h.width-b[0]):Math.max(Math.abs(b[0]),h.width);a.height=0>b[1]?Math.max(Math.abs(b[1]),h.height-Math.abs(b[1])):Math.max(Math.abs(b[1]),h.height);this.tracker?this.tracker.attr(a):(this.tracker=c.renderer.rect(a).addClass("highcharts-tracker").add(c),
d.styledMode||this.tracker.attr({fill:"rgba(0,0,0,0)"}))}}};e.prototype.styledModeFormat=function(d){return d.replace('style="font-size: 10px"','class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g,'class="highcharts-color-{$1.colorIndex}"')};e.prototype.tooltipFooterHeaderFormatter=function(d,c){var b=c?"footer":"header",a=d.series,h=a.tooltipOptions,e=h.xDateFormat,m=a.xAxis,l=m&&"datetime"===m.options.type&&q(d.key),k=h[b+"Format"];c={isFooter:c,labelConfig:d};f(this,"headerFormatter",
c,function(c){l&&!e&&(e=this.getXDateFormat(d,h,m));l&&e&&(d.point&&d.point.tooltipDateKeys||["key"]).forEach(function(a){k=k.replace("{point."+a+"}","{point."+a+":"+e+"}")});a.chart.styledMode&&(k=this.styledModeFormat(k));c.text=D(k,{point:d,series:a},this.chart)});return c.text};e.prototype.update=function(d){this.destroy();l(!0,this.chart.options.tooltip.userOptions,d);this.init(this.chart,l(!0,this.options,d))};e.prototype.updatePosition=function(d){var c=this.chart,b=c.pointer,a=this.getLabel(),
h=d.plotX+c.plotLeft;c=d.plotY+c.plotTop;b=b.getChartPosition();d=(this.options.positioner||this.getPosition).call(this,a.width,a.height,d);if(this.outside){var e=(this.options.borderWidth||0)+2*this.distance;this.renderer.setSize(a.width+e,a.height+e,!1);if(1!==b.scaleX||1!==b.scaleY)B(this.container,{transform:"scale("+b.scaleX+", "+b.scaleY+")"}),h*=b.scaleX,c*=b.scaleY;h+=b.left-d.x;c+=b.top-d.y}this.move(Math.round(d.x),Math.round(d.y||0),h,c)};return e}();b.Tooltip=e;return b.Tooltip});O(e,
"Core/Pointer.js",[e["Core/Color/Color.js"],e["Core/Globals.js"],e["Core/Color/Palette.js"],e["Core/Tooltip.js"],e["Core/Utilities.js"]],function(e,b,I,z,H){var D=e.parse,C=b.charts,B=b.noop,x=H.addEvent,w=H.attr,v=H.css,f=H.defined,d=H.extend,q=H.find,k=H.fireEvent,l=H.isNumber,N=H.isObject,u=H.objectEach,n=H.offset,J=H.pick,E=H.splat;"";e=function(){function e(c,d){this.lastValidTouch={};this.pinchDown=[];this.runChartClick=!1;this.eventsToUnbind=[];this.chart=c;this.hasDragged=!1;this.options=
d;this.init(c,d)}e.prototype.applyInactiveState=function(c){var d=[],a;(c||[]).forEach(function(c){a=c.series;d.push(a);a.linkedParent&&d.push(a.linkedParent);a.linkedSeries&&(d=d.concat(a.linkedSeries));a.navigatorSeries&&d.push(a.navigatorSeries)});this.chart.series.forEach(function(a){-1===d.indexOf(a)?a.setState("inactive",!0):a.options.inactiveOtherPoints&&a.setAllPointsToState("inactive")})};e.prototype.destroy=function(){var c=this;this.eventsToUnbind.forEach(function(c){return c()});this.eventsToUnbind=
[];b.chartCount||(b.unbindDocumentMouseUp&&(b.unbindDocumentMouseUp=b.unbindDocumentMouseUp()),b.unbindDocumentTouchEnd&&(b.unbindDocumentTouchEnd=b.unbindDocumentTouchEnd()));clearInterval(c.tooltipTimeout);u(c,function(d,a){c[a]=void 0})};e.prototype.drag=function(c){var d=this.chart,a=d.options.chart,b=c.chartX,e=c.chartY,f=this.zoomHor,l=this.zoomVert,m=d.plotLeft,k=d.plotTop,n=d.plotWidth,q=d.plotHeight,u=this.selectionMarker,v=this.mouseDownX||0,t=this.mouseDownY||0,p=N(a.panning)?a.panning&&
a.panning.enabled:a.panning,w=a.panKey&&c[a.panKey+"Key"];if(!u||!u.touch)if(b<m?b=m:b>m+n&&(b=m+n),e<k?e=k:e>k+q&&(e=k+q),this.hasDragged=Math.sqrt(Math.pow(v-b,2)+Math.pow(t-e,2)),10<this.hasDragged){var E=d.isInsidePlot(v-m,t-k,{visiblePlotOnly:!0});d.hasCartesianSeries&&(this.zoomX||this.zoomY)&&E&&!w&&!u&&(this.selectionMarker=u=d.renderer.rect(m,k,f?1:n,l?1:q,0).attr({"class":"highcharts-selection-marker",zIndex:7}).add(),d.styledMode||u.attr({fill:a.selectionMarkerFill||D(I.highlightColor80).setOpacity(.25).get()}));
u&&f&&(b-=v,u.attr({width:Math.abs(b),x:(0<b?0:b)+v}));u&&l&&(b=e-t,u.attr({height:Math.abs(b),y:(0<b?0:b)+t}));E&&!u&&p&&d.pan(c,a.panning)}};e.prototype.dragStart=function(c){var d=this.chart;d.mouseIsDown=c.type;d.cancelClick=!1;d.mouseDownX=this.mouseDownX=c.chartX;d.mouseDownY=this.mouseDownY=c.chartY};e.prototype.drop=function(c){var b=this,a=this.chart,h=this.hasPinched;if(this.selectionMarker){var e={originalEvent:c,xAxis:[],yAxis:[]},A=this.selectionMarker,m=A.attr?A.attr("x"):A.x,n=A.attr?
A.attr("y"):A.y,q=A.attr?A.attr("width"):A.width,u=A.attr?A.attr("height"):A.height,w;if(this.hasDragged||h)a.axes.forEach(function(a){if(a.zoomEnabled&&f(a.min)&&(h||b[{xAxis:"zoomX",yAxis:"zoomY"}[a.coll]])&&l(m)&&l(n)){var d=a.horiz,g="touchend"===c.type?a.minPixelPadding:0,r=a.toValue((d?m:n)+g);d=a.toValue((d?m+q:n+u)-g);e[a.coll].push({axis:a,min:Math.min(r,d),max:Math.max(r,d)});w=!0}}),w&&k(a,"selection",e,function(c){a.zoom(d(c,h?{animation:!1}:null))});l(a.index)&&(this.selectionMarker=
this.selectionMarker.destroy());h&&this.scaleGroups()}a&&l(a.index)&&(v(a.container,{cursor:a._cursor}),a.cancelClick=10<this.hasDragged,a.mouseIsDown=this.hasDragged=this.hasPinched=!1,this.pinchDown=[])};e.prototype.findNearestKDPoint=function(c,d,a){var b=this.chart,g=b.hoverPoint;b=b.tooltip;if(g&&b&&b.isStickyOnContact())return g;var e;c.forEach(function(c){var b=!(c.noSharedTooltip&&d)&&0>c.options.findNearestPointBy.indexOf("y");c=c.searchPoint(a,b);if((b=N(c,!0)&&c.series)&&!(b=!N(e,!0))){b=
e.distX-c.distX;var h=e.dist-c.dist,g=(c.series.group&&c.series.group.zIndex)-(e.series.group&&e.series.group.zIndex);b=0<(0!==b&&d?b:0!==h?h:0!==g?g:e.series.index>c.series.index?-1:1)}b&&(e=c)});return e};e.prototype.getChartCoordinatesFromPoint=function(c,d){var a=c.series,b=a.xAxis;a=a.yAxis;var g=c.shapeArgs;if(b&&a){var e=J(c.clientX,c.plotX),f=c.plotY||0;c.isNode&&g&&l(g.x)&&l(g.y)&&(e=g.x,f=g.y);return d?{chartX:a.len+a.pos-f,chartY:b.len+b.pos-e}:{chartX:e+b.pos,chartY:f+a.pos}}if(g&&g.x&&
g.y)return{chartX:g.x,chartY:g.y}};e.prototype.getChartPosition=function(){if(this.chartPosition)return this.chartPosition;var c=this.chart.container,d=n(c);this.chartPosition={left:d.left,top:d.top,scaleX:1,scaleY:1};var a=c.offsetWidth;c=c.offsetHeight;2<a&&2<c&&(this.chartPosition.scaleX=d.width/a,this.chartPosition.scaleY=d.height/c);return this.chartPosition};e.prototype.getCoordinates=function(c){var d={xAxis:[],yAxis:[]};this.chart.axes.forEach(function(a){d[a.isXAxis?"xAxis":"yAxis"].push({axis:a,
value:a.toValue(c[a.horiz?"chartX":"chartY"])})});return d};e.prototype.getHoverData=function(c,d,a,b,e,f){var h,g=[];b=!(!b||!c);var r=d&&!d.stickyTracking,l={chartX:f?f.chartX:void 0,chartY:f?f.chartY:void 0,shared:e};k(this,"beforeGetHoverData",l);r=r?[d]:a.filter(function(a){return l.filter?l.filter(a):a.visible&&!(!e&&a.directTouch)&&J(a.options.enableMouseTracking,!0)&&a.stickyTracking});d=(h=b||!f?c:this.findNearestKDPoint(r,e,f))&&h.series;h&&(e&&!d.noSharedTooltip?(r=a.filter(function(a){return l.filter?
l.filter(a):a.visible&&!(!e&&a.directTouch)&&J(a.options.enableMouseTracking,!0)&&!a.noSharedTooltip}),r.forEach(function(a){var c=q(a.points,function(a){return a.x===h.x&&!a.isNull});N(c)&&(a.chart.isBoosting&&(c=a.getPoint(c)),g.push(c))})):g.push(h));l={hoverPoint:h};k(this,"afterGetHoverData",l);return{hoverPoint:l.hoverPoint,hoverSeries:d,hoverPoints:g}};e.prototype.getPointFromEvent=function(c){c=c.target;for(var d;c&&!d;)d=c.point,c=c.parentNode;return d};e.prototype.onTrackerMouseOut=function(c){c=
c.relatedTarget||c.toElement;var d=this.chart.hoverSeries;this.isDirectTouch=!1;if(!(!d||!c||d.stickyTracking||this.inClass(c,"highcharts-tooltip")||this.inClass(c,"highcharts-series-"+d.index)&&this.inClass(c,"highcharts-tracker")))d.onMouseOut()};e.prototype.inClass=function(c,d){for(var a;c;){if(a=w(c,"class")){if(-1!==a.indexOf(d))return!0;if(-1!==a.indexOf("highcharts-container"))return!1}c=c.parentNode}};e.prototype.init=function(c,d){this.options=d;this.chart=c;this.runChartClick=!(!d.chart.events||
!d.chart.events.click);this.pinchDown=[];this.lastValidTouch={};z&&(c.tooltip=new z(c,d.tooltip),this.followTouchMove=J(d.tooltip.followTouchMove,!0));this.setDOMEvents()};e.prototype.normalize=function(c,b){var a=c.touches,h=a?a.length?a.item(0):J(a.changedTouches,c.changedTouches)[0]:c;b||(b=this.getChartPosition());a=h.pageX-b.left;h=h.pageY-b.top;a/=b.scaleX;h/=b.scaleY;return d(c,{chartX:Math.round(a),chartY:Math.round(h)})};e.prototype.onContainerClick=function(c){var b=this.chart,a=b.hoverPoint;
c=this.normalize(c);var h=b.plotLeft,e=b.plotTop;b.cancelClick||(a&&this.inClass(c.target,"highcharts-tracker")?(k(a.series,"click",d(c,{point:a})),b.hoverPoint&&a.firePointEvent("click",c)):(d(c,this.getCoordinates(c)),b.isInsidePlot(c.chartX-h,c.chartY-e,{visiblePlotOnly:!0})&&k(b,"click",c)))};e.prototype.onContainerMouseDown=function(c){var d=1===((c.buttons||c.button)&1);c=this.normalize(c);if(b.isFirefox&&0!==c.button)this.onContainerMouseMove(c);if("undefined"===typeof c.button||d)this.zoomOption(c),
d&&c.preventDefault&&c.preventDefault(),this.dragStart(c)};e.prototype.onContainerMouseLeave=function(c){var d=C[J(b.hoverChartIndex,-1)],a=this.chart.tooltip;c=this.normalize(c);d&&(c.relatedTarget||c.toElement)&&(d.pointer.reset(),d.pointer.chartPosition=void 0);a&&!a.isHidden&&this.reset()};e.prototype.onContainerMouseEnter=function(c){delete this.chartPosition};e.prototype.onContainerMouseMove=function(c){var d=this.chart;c=this.normalize(c);this.setHoverChartIndex();c.preventDefault||(c.returnValue=
!1);("mousedown"===d.mouseIsDown||this.touchSelect(c))&&this.drag(c);d.openMenu||!this.inClass(c.target,"highcharts-tracker")&&!d.isInsidePlot(c.chartX-d.plotLeft,c.chartY-d.plotTop,{visiblePlotOnly:!0})||this.runPointActions(c)};e.prototype.onDocumentTouchEnd=function(c){C[b.hoverChartIndex]&&C[b.hoverChartIndex].pointer.drop(c)};e.prototype.onContainerTouchMove=function(c){if(this.touchSelect(c))this.onContainerMouseMove(c);else this.touch(c)};e.prototype.onContainerTouchStart=function(c){if(this.touchSelect(c))this.onContainerMouseDown(c);
else this.zoomOption(c),this.touch(c,!0)};e.prototype.onDocumentMouseMove=function(c){var d=this.chart,a=this.chartPosition;c=this.normalize(c,a);var b=d.tooltip;!a||b&&b.isStickyOnContact()||d.isInsidePlot(c.chartX-d.plotLeft,c.chartY-d.plotTop,{visiblePlotOnly:!0})||this.inClass(c.target,"highcharts-tracker")||this.reset()};e.prototype.onDocumentMouseUp=function(c){var d=C[J(b.hoverChartIndex,-1)];d&&d.pointer.drop(c)};e.prototype.pinch=function(c){var b=this,a=b.chart,h=b.pinchDown,e=c.touches||
[],f=e.length,l=b.lastValidTouch,m=b.hasZoom,k=b.selectionMarker,n={},q=1===f&&(b.inClass(c.target,"highcharts-tracker")&&a.runTrackerClick||b.runChartClick),u={};1<f&&(b.initiated=!0);m&&b.initiated&&!q&&!1!==c.cancelable&&c.preventDefault();[].map.call(e,function(a){return b.normalize(a)});"touchstart"===c.type?([].forEach.call(e,function(a,c){h[c]={chartX:a.chartX,chartY:a.chartY}}),l.x=[h[0].chartX,h[1]&&h[1].chartX],l.y=[h[0].chartY,h[1]&&h[1].chartY],a.axes.forEach(function(c){if(c.zoomEnabled){var d=
a.bounds[c.horiz?"h":"v"],b=c.minPixelPadding,h=c.toPixels(Math.min(J(c.options.min,c.dataMin),c.dataMin)),e=c.toPixels(Math.max(J(c.options.max,c.dataMax),c.dataMax)),g=Math.max(h,e);d.min=Math.min(c.pos,Math.min(h,e)-b);d.max=Math.max(c.pos+c.len,g+b)}}),b.res=!0):b.followTouchMove&&1===f?this.runPointActions(b.normalize(c)):h.length&&(k||(b.selectionMarker=k=d({destroy:B,touch:!0},a.plotBox)),b.pinchTranslate(h,e,n,k,u,l),b.hasPinched=m,b.scaleGroups(n,u),b.res&&(b.res=!1,this.reset(!1,0)))};e.prototype.pinchTranslate=
function(c,d,a,b,e,f){this.zoomHor&&this.pinchTranslateDirection(!0,c,d,a,b,e,f);this.zoomVert&&this.pinchTranslateDirection(!1,c,d,a,b,e,f)};e.prototype.pinchTranslateDirection=function(c,d,a,b,e,f,l,m){var h=this.chart,g=c?"x":"y",r=c?"X":"Y",k="chart"+r,n=c?"width":"height",A=h["plot"+(c?"Left":"Top")],y,q,u=m||1,L=h.inverted,F=h.bounds[c?"h":"v"],v=1===d.length,K=d[0][k],w=a[0][k],E=!v&&d[1][k],x=!v&&a[1][k];a=function(){"number"===typeof x&&20<Math.abs(K-E)&&(u=m||Math.abs(w-x)/Math.abs(K-E));
q=(A-w)/u+K;y=h["plot"+(c?"Width":"Height")]/u};a();d=q;if(d<F.min){d=F.min;var J=!0}else d+y>F.max&&(d=F.max-y,J=!0);J?(w-=.8*(w-l[g][0]),"number"===typeof x&&(x-=.8*(x-l[g][1])),a()):l[g]=[w,x];L||(f[g]=q-A,f[n]=y);f=L?1/u:u;e[n]=y;e[g]=d;b[L?c?"scaleY":"scaleX":"scale"+r]=u;b["translate"+r]=f*A+(w-f*K)};e.prototype.reset=function(c,d){var a=this.chart,b=a.hoverSeries,e=a.hoverPoint,g=a.hoverPoints,f=a.tooltip,l=f&&f.shared?g:e;c&&l&&E(l).forEach(function(a){a.series.isCartesian&&"undefined"===
typeof a.plotX&&(c=!1)});if(c)f&&l&&E(l).length&&(f.refresh(l),f.shared&&g?g.forEach(function(a){a.setState(a.state,!0);a.series.isCartesian&&(a.series.xAxis.crosshair&&a.series.xAxis.drawCrosshair(null,a),a.series.yAxis.crosshair&&a.series.yAxis.drawCrosshair(null,a))}):e&&(e.setState(e.state,!0),a.axes.forEach(function(a){a.crosshair&&e.series[a.coll]===a&&a.drawCrosshair(null,e)})));else{if(e)e.onMouseOut();g&&g.forEach(function(a){a.setState()});if(b)b.onMouseOut();f&&f.hide(d);this.unDocMouseMove&&
(this.unDocMouseMove=this.unDocMouseMove());a.axes.forEach(function(a){a.hideCrosshair()});this.hoverX=a.hoverPoints=a.hoverPoint=null}};e.prototype.runPointActions=function(c,d){var a=this.chart,h=a.tooltip&&a.tooltip.options.enabled?a.tooltip:void 0,e=h?h.shared:!1,g=d||a.hoverPoint,f=g&&g.series||a.hoverSeries;f=this.getHoverData(g,f,a.series,(!c||"touchmove"!==c.type)&&(!!d||f&&f.directTouch&&this.isDirectTouch),e,c);g=f.hoverPoint;var l=f.hoverPoints;d=(f=f.hoverSeries)&&f.tooltipOptions.followPointer&&
!f.tooltipOptions.split;e=e&&f&&!f.noSharedTooltip;if(g&&(g!==a.hoverPoint||h&&h.isHidden)){(a.hoverPoints||[]).forEach(function(a){-1===l.indexOf(a)&&a.setState()});if(a.hoverSeries!==f)f.onMouseOver();this.applyInactiveState(l);(l||[]).forEach(function(a){a.setState("hover")});a.hoverPoint&&a.hoverPoint.firePointEvent("mouseOut");if(!g.series)return;a.hoverPoints=l;a.hoverPoint=g;g.firePointEvent("mouseOver");h&&h.refresh(e?l:g,c)}else d&&h&&!h.isHidden&&(g=h.getAnchor([{}],c),a.isInsidePlot(g[0],
g[1],{visiblePlotOnly:!0})&&h.updatePosition({plotX:g[0],plotY:g[1]}));this.unDocMouseMove||(this.unDocMouseMove=x(a.container.ownerDocument,"mousemove",function(a){var c=C[b.hoverChartIndex];if(c)c.pointer.onDocumentMouseMove(a)}),this.eventsToUnbind.push(this.unDocMouseMove));a.axes.forEach(function(d){var b=J((d.crosshair||{}).snap,!0),h;b&&((h=a.hoverPoint)&&h.series[d.coll]===d||(h=q(l,function(a){return a.series[d.coll]===d})));h||!b?d.drawCrosshair(c,h):d.hideCrosshair()})};e.prototype.scaleGroups=
function(c,d){var a=this.chart,b;a.series.forEach(function(h){b=c||h.getPlotBox();h.xAxis&&h.xAxis.zoomEnabled&&h.group&&(h.group.attr(b),h.markerGroup&&(h.markerGroup.attr(b),h.markerGroup.clip(d?a.clipRect:null)),h.dataLabelsGroup&&h.dataLabelsGroup.attr(b))});a.clipRect.attr(d||a.clipBox)};e.prototype.setDOMEvents=function(){var c=this,d=this.chart.container,a=d.ownerDocument;d.onmousedown=this.onContainerMouseDown.bind(this);d.onmousemove=this.onContainerMouseMove.bind(this);d.onclick=this.onContainerClick.bind(this);
this.eventsToUnbind.push(x(d,"mouseenter",this.onContainerMouseEnter.bind(this)));this.eventsToUnbind.push(x(d,"mouseleave",this.onContainerMouseLeave.bind(this)));b.unbindDocumentMouseUp||(b.unbindDocumentMouseUp=x(a,"mouseup",this.onDocumentMouseUp.bind(this)));for(var h=this.chart.renderTo.parentElement;h&&"BODY"!==h.tagName;)this.eventsToUnbind.push(x(h,"scroll",function(){delete c.chartPosition})),h=h.parentElement;b.hasTouch&&(this.eventsToUnbind.push(x(d,"touchstart",this.onContainerTouchStart.bind(this),
{passive:!1})),this.eventsToUnbind.push(x(d,"touchmove",this.onContainerTouchMove.bind(this),{passive:!1})),b.unbindDocumentTouchEnd||(b.unbindDocumentTouchEnd=x(a,"touchend",this.onDocumentTouchEnd.bind(this),{passive:!1})))};e.prototype.setHoverChartIndex=function(){var c=this.chart,d=b.charts[J(b.hoverChartIndex,-1)];if(d&&d!==c)d.pointer.onContainerMouseLeave({relatedTarget:!0});d&&d.mouseIsDown||(b.hoverChartIndex=c.index)};e.prototype.touch=function(c,d){var a=this.chart,b;this.setHoverChartIndex();
if(1===c.touches.length)if(c=this.normalize(c),(b=a.isInsidePlot(c.chartX-a.plotLeft,c.chartY-a.plotTop,{visiblePlotOnly:!0}))&&!a.openMenu){d&&this.runPointActions(c);if("touchmove"===c.type){d=this.pinchDown;var e=d[0]?4<=Math.sqrt(Math.pow(d[0].chartX-c.chartX,2)+Math.pow(d[0].chartY-c.chartY,2)):!1}J(e,!0)&&this.pinch(c)}else d&&this.reset();else 2===c.touches.length&&this.pinch(c)};e.prototype.touchSelect=function(c){return!(!this.chart.options.chart.zoomBySingleTouch||!c.touches||1!==c.touches.length)};
e.prototype.zoomOption=function(c){var d=this.chart,a=d.options.chart,b=a.zoomType||"";d=d.inverted;/touch/.test(c.type)&&(b=J(a.pinchType,b));this.zoomX=c=/x/.test(b);this.zoomY=b=/y/.test(b);this.zoomHor=c&&!d||b&&d;this.zoomVert=b&&!d||c&&d;this.hasZoom=c||b};return e}();return b.Pointer=e});O(e,"Core/MSPointer.js",[e["Core/Globals.js"],e["Core/Pointer.js"],e["Core/Utilities.js"]],function(e,b,I){function D(){var d=[];d.item=function(d){return this[d]};f(q,function(b){d.push({pageX:b.pageX,pageY:b.pageY,
target:b.target})});return d}function H(d,b,f,k){"touch"!==d.pointerType&&d.pointerType!==d.MSPOINTER_TYPE_TOUCH||!C[e.hoverChartIndex]||(k(d),k=C[e.hoverChartIndex].pointer,k[b]({type:f,target:d.currentTarget,preventDefault:x,touches:D()}))}var G=this&&this.__extends||function(){var d=function(b,e){d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var e in b)b.hasOwnProperty(e)&&(d[e]=b[e])};return d(b,e)};return function(b,e){function f(){this.constructor=
b}d(b,e);b.prototype=null===e?Object.create(e):(f.prototype=e.prototype,new f)}}(),C=e.charts,B=e.doc,x=e.noop,w=I.addEvent,v=I.css,f=I.objectEach,d=I.removeEvent,q={},k=!!e.win.PointerEvent;return function(b){function e(){return null!==b&&b.apply(this,arguments)||this}G(e,b);e.prototype.batchMSEvents=function(d){d(this.chart.container,k?"pointerdown":"MSPointerDown",this.onContainerPointerDown);d(this.chart.container,k?"pointermove":"MSPointerMove",this.onContainerPointerMove);d(B,k?"pointerup":
"MSPointerUp",this.onDocumentPointerUp)};e.prototype.destroy=function(){this.batchMSEvents(d);b.prototype.destroy.call(this)};e.prototype.init=function(d,e){b.prototype.init.call(this,d,e);this.hasZoom&&v(d.container,{"-ms-touch-action":"none","touch-action":"none"})};e.prototype.onContainerPointerDown=function(d){H(d,"onContainerTouchStart","touchstart",function(d){q[d.pointerId]={pageX:d.pageX,pageY:d.pageY,target:d.currentTarget}})};e.prototype.onContainerPointerMove=function(d){H(d,"onContainerTouchMove",
"touchmove",function(d){q[d.pointerId]={pageX:d.pageX,pageY:d.pageY};q[d.pointerId].target||(q[d.pointerId].target=d.currentTarget)})};e.prototype.onDocumentPointerUp=function(d){H(d,"onDocumentTouchEnd","touchend",function(d){delete q[d.pointerId]})};e.prototype.setDOMEvents=function(){b.prototype.setDOMEvents.call(this);(this.hasZoom||this.followTouchMove)&&this.batchMSEvents(w)};return e}(b)});O(e,"Core/Series/Point.js",[e["Core/Renderer/HTML/AST.js"],e["Core/Animation/AnimationUtilities.js"],
e["Core/FormatUtilities.js"],e["Core/Globals.js"],e["Core/Options.js"],e["Core/Utilities.js"]],function(e,b,I,z,H,G){var D=b.animObject,B=I.format,x=H.defaultOptions,w=G.addEvent,v=G.defined,f=G.erase,d=G.extend,q=G.fireEvent,k=G.getNestedProperty,l=G.isArray,N=G.isFunction,u=G.isNumber,n=G.isObject,J=G.merge,E=G.objectEach,m=G.pick,c=G.syncTimeout,g=G.removeEvent,a=G.uniqueKey;"";b=function(){function b(){this.colorIndex=this.category=void 0;this.formatPrefix="point";this.id=void 0;this.isNull=!1;
this.percentage=this.options=this.name=void 0;this.selected=!1;this.total=this.series=void 0;this.visible=!0;this.x=void 0}b.prototype.animateBeforeDestroy=function(){var a=this,c={x:a.startXPos,opacity:0},b,e=a.getGraphicalProps();e.singular.forEach(function(d){b="dataLabel"===d;a[d]=a[d].animate(b?{x:a[d].startXPos,y:a[d].startYPos,opacity:0}:c)});e.plural.forEach(function(c){a[c].forEach(function(c){c.element&&c.animate(d({x:a.startXPos},c.startYPos?{x:c.startXPos,y:c.startYPos}:{}))})})};b.prototype.applyOptions=
function(a,c){var e=this.series,h=e.options.pointValKey||e.pointValKey;a=b.prototype.optionsToObject.call(this,a);d(this,a);this.options=this.options?d(this.options,a):a;a.group&&delete this.group;a.dataLabels&&delete this.dataLabels;h&&(this.y=b.prototype.getNestedProperty.call(this,h));this.formatPrefix=(this.isNull=m(this.isValid&&!this.isValid(),null===this.x||!u(this.y)))?"null":"point";this.selected&&(this.state="select");"name"in this&&"undefined"===typeof c&&e.xAxis&&e.xAxis.hasNames&&(this.x=
e.xAxis.nameToX(this));"undefined"===typeof this.x&&e&&(this.x="undefined"===typeof c?e.autoIncrement(this):c);return this};b.prototype.destroy=function(){function a(){if(d.graphic||d.dataLabel||d.dataLabels)g(d),d.destroyElements();for(m in d)d[m]=null}var d=this,b=d.series,e=b.chart;b=b.options.dataSorting;var h=e.hoverPoints,l=D(d.series.chart.renderer.globalAnimation),m;d.legendItem&&e.legend.destroyItem(d);h&&(d.setState(),f(h,d),h.length||(e.hoverPoints=null));if(d===e.hoverPoint)d.onMouseOut();
b&&b.enabled?(this.animateBeforeDestroy(),c(a,l.duration)):a();e.pointCount--};b.prototype.destroyElements=function(a){var c=this;a=c.getGraphicalProps(a);a.singular.forEach(function(a){c[a]=c[a].destroy()});a.plural.forEach(function(a){c[a].forEach(function(a){a.element&&a.destroy()});delete c[a]})};b.prototype.firePointEvent=function(a,c,d){var b=this,e=this.series.options;(e.point.events[a]||b.options&&b.options.events&&b.options.events[a])&&b.importEvents();"click"===a&&e.allowPointSelect&&(d=
function(a){b.select&&b.select(null,a.ctrlKey||a.metaKey||a.shiftKey)});q(b,a,c,d)};b.prototype.getClassName=function(){return"highcharts-point"+(this.selected?" highcharts-point-select":"")+(this.negative?" highcharts-negative":"")+(this.isNull?" highcharts-null-point":"")+("undefined"!==typeof this.colorIndex?" highcharts-color-"+this.colorIndex:"")+(this.options.className?" "+this.options.className:"")+(this.zone&&this.zone.className?" "+this.zone.className.replace("highcharts-negative",""):"")};
b.prototype.getGraphicalProps=function(a){var c=this,d=[],b,e={singular:[],plural:[]};a=a||{graphic:1,dataLabel:1};a.graphic&&d.push("graphic","upperGraphic","shadowGroup");a.dataLabel&&d.push("dataLabel","dataLabelUpper","connector");for(b=d.length;b--;){var h=d[b];c[h]&&e.singular.push(h)}["dataLabel","connector"].forEach(function(d){var b=d+"s";a[d]&&c[b]&&e.plural.push(b)});return e};b.prototype.getLabelConfig=function(){return{x:this.category,y:this.y,color:this.color,colorIndex:this.colorIndex,
key:this.name||this.category,series:this.series,point:this,percentage:this.percentage,total:this.total||this.stackTotal}};b.prototype.getNestedProperty=function(a){if(a)return 0===a.indexOf("custom.")?k(a,this.options):this[a]};b.prototype.getZone=function(){var a=this.series,c=a.zones;a=a.zoneAxis||"y";var d=0,b;for(b=c[d];this[a]>=b.value;)b=c[++d];this.nonZonedColor||(this.nonZonedColor=this.color);this.color=b&&b.color&&!this.options.color?b.color:this.nonZonedColor;return b};b.prototype.hasNewShapeType=
function(){return(this.graphic&&(this.graphic.symbolName||this.graphic.element.nodeName))!==this.shapeType};b.prototype.init=function(c,d,b){this.series=c;this.applyOptions(d,b);this.id=v(this.id)?this.id:a();this.resolveColor();c.chart.pointCount++;q(this,"afterInit");return this};b.prototype.optionsToObject=function(a){var c={},d=this.series,e=d.options.keys,h=e||d.pointArrayMap||["y"],g=h.length,f=0,r=0;if(u(a)||null===a)c[h[0]]=a;else if(l(a))for(!e&&a.length>g&&(d=typeof a[0],"string"===d?c.name=
a[0]:"number"===d&&(c.x=a[0]),f++);r<g;)e&&"undefined"===typeof a[f]||(0<h[r].indexOf(".")?b.prototype.setNestedProperty(c,a[f],h[r]):c[h[r]]=a[f]),f++,r++;else"object"===typeof a&&(c=a,a.dataLabels&&(d._hasPointLabels=!0),a.marker&&(d._hasPointMarkers=!0));return c};b.prototype.resolveColor=function(){var a=this.series;var c=a.chart.options.chart.colorCount;var d=a.chart.styledMode;delete this.nonZonedColor;if(a.options.colorByPoint){if(!d){c=a.options.colors||a.chart.options.colors;var b=c[a.colorCounter];
c=c.length}d=a.colorCounter;a.colorCounter++;a.colorCounter===c&&(a.colorCounter=0)}else d||(b=a.color),d=a.colorIndex;this.colorIndex=m(this.options.colorIndex,d);this.color=m(this.options.color,b)};b.prototype.setNestedProperty=function(a,c,d){d.split(".").reduce(function(a,d,b,e){a[d]=e.length-1===b?c:n(a[d],!0)?a[d]:{};return a[d]},a);return a};b.prototype.tooltipFormatter=function(a){var c=this.series,d=c.tooltipOptions,b=m(d.valueDecimals,""),e=d.valuePrefix||"",h=d.valueSuffix||"";c.chart.styledMode&&
(a=c.chart.tooltip.styledModeFormat(a));(c.pointArrayMap||["y"]).forEach(function(c){c="{point."+c;if(e||h)a=a.replace(RegExp(c+"}","g"),e+c+"}"+h);a=a.replace(RegExp(c+"}","g"),c+":,."+b+"f}")});return B(a,{point:this,series:this.series},c.chart)};b.prototype.update=function(a,c,d,b){function e(){h.applyOptions(a);var b=f&&h.hasDummyGraphic;b=null===h.y?!b:b;f&&b&&(h.graphic=f.destroy(),delete h.hasDummyGraphic);n(a,!0)&&(f&&f.element&&a&&a.marker&&"undefined"!==typeof a.marker.symbol&&(h.graphic=
f.destroy()),a&&a.dataLabels&&h.dataLabel&&(h.dataLabel=h.dataLabel.destroy()),h.connector&&(h.connector=h.connector.destroy()));r=h.index;g.updateParallelArrays(h,r);k.data[r]=n(k.data[r],!0)||n(a,!0)?h.options:m(a,k.data[r]);g.isDirty=g.isDirtyData=!0;!g.fixedBox&&g.hasCartesianSeries&&(l.isDirtyBox=!0);"point"===k.legendType&&(l.isDirtyLegend=!0);c&&l.redraw(d)}var h=this,g=h.series,f=h.graphic,r,l=g.chart,k=g.options;c=m(c,!0);!1===b?e():h.firePointEvent("update",{options:a},e)};b.prototype.remove=
function(a,c){this.series.removePoint(this.series.data.indexOf(this),a,c)};b.prototype.select=function(a,c){var d=this,b=d.series,e=b.chart;this.selectedStaging=a=m(a,!d.selected);d.firePointEvent(a?"select":"unselect",{accumulate:c},function(){d.selected=d.options.selected=a;b.options.data[b.data.indexOf(d)]=d.options;d.setState(a&&"select");c||e.getSelectedPoints().forEach(function(a){var c=a.series;a.selected&&a!==d&&(a.selected=a.options.selected=!1,c.options.data[c.data.indexOf(a)]=a.options,
a.setState(e.hoverPoints&&c.options.inactiveOtherPoints?"inactive":""),a.firePointEvent("unselect"))})});delete this.selectedStaging};b.prototype.onMouseOver=function(a){var c=this.series.chart,d=c.pointer;a=a?d.normalize(a):d.getChartCoordinatesFromPoint(this,c.inverted);d.runPointActions(a,this)};b.prototype.onMouseOut=function(){var a=this.series.chart;this.firePointEvent("mouseOut");this.series.options.inactiveOtherPoints||(a.hoverPoints||[]).forEach(function(a){a.setState()});a.hoverPoints=a.hoverPoint=
null};b.prototype.importEvents=function(){if(!this.hasImportedEvents){var a=this,c=J(a.series.options.point,a.options).events;a.events=c;E(c,function(c,d){N(c)&&w(a,d,c)});this.hasImportedEvents=!0}};b.prototype.setState=function(a,c){var b=this.series,h=this.state,g=b.options.states[a||"normal"]||{},f=x.plotOptions[b.type].marker&&b.options.marker,r=f&&!1===f.enabled,l=f&&f.states&&f.states[a||"normal"]||{},k=!1===l.enabled,n=b.stateMarkerGraphic,p=this.marker||{},A=b.chart,v=b.halo,w,F=f&&b.markerAttribs;
a=a||"";if(!(a===this.state&&!c||this.selected&&"select"!==a||!1===g.enabled||a&&(k||r&&!1===l.enabled)||a&&p.states&&p.states[a]&&!1===p.states[a].enabled)){this.state=a;F&&(w=b.markerAttribs(this,a));if(this.graphic&&!this.hasDummyGraphic){h&&this.graphic.removeClass("highcharts-point-"+h);a&&this.graphic.addClass("highcharts-point-"+a);if(!A.styledMode){var S=b.pointAttribs(this,a);var K=m(A.options.chart.animation,g.animation);b.options.inactiveOtherPoints&&u(S.opacity)&&((this.dataLabels||[]).forEach(function(a){a&&
a.animate({opacity:S.opacity},K)}),this.connector&&this.connector.animate({opacity:S.opacity},K));this.graphic.animate(S,K)}w&&this.graphic.animate(w,m(A.options.chart.animation,l.animation,f.animation));n&&n.hide()}else{if(a&&l){h=p.symbol||b.symbol;n&&n.currentSymbol!==h&&(n=n.destroy());if(w)if(n)n[c?"animate":"attr"]({x:w.x,y:w.y});else h&&(b.stateMarkerGraphic=n=A.renderer.symbol(h,w.x,w.y,w.width,w.height).add(b.markerGroup),n.currentSymbol=h);!A.styledMode&&n&&n.attr(b.pointAttribs(this,a))}n&&
(n[a&&this.isInside?"show":"hide"](),n.element.point=this)}g=g.halo;w=(n=this.graphic||n)&&n.visibility||"inherit";g&&g.size&&n&&"hidden"!==w&&!this.isCluster?(v||(b.halo=v=A.renderer.path().add(n.parentGroup)),v.show()[c?"animate":"attr"]({d:this.haloPath(g.size)}),v.attr({"class":"highcharts-halo highcharts-color-"+m(this.colorIndex,b.colorIndex)+(this.className?" "+this.className:""),visibility:w,zIndex:-1}),v.point=this,A.styledMode||v.attr(d({fill:this.color||b.color,"fill-opacity":g.opacity},
e.filterUserAttributes(g.attributes||{})))):v&&v.point&&v.point.haloPath&&v.animate({d:v.point.haloPath(0)},null,v.hide);q(this,"afterSetState",{state:a})}};b.prototype.haloPath=function(a){return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX)-a,this.plotY-a,2*a,2*a)};return b}();return z.Point=b});O(e,"Core/Legend.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/FormatUtilities.js"],e["Core/Globals.js"],e["Core/Series/Point.js"],e["Core/Utilities.js"]],function(e,b,I,z,H){var D=
e.animObject,C=e.setAnimation,B=b.format;e=I.isFirefox;var x=I.marginNames;b=I.win;var w=H.addEvent,v=H.createElement,f=H.css,d=H.defined,q=H.discardElement,k=H.find,l=H.fireEvent,N=H.isNumber,u=H.merge,n=H.pick,J=H.relativeLength,E=H.stableSort,m=H.syncTimeout;H=H.wrap;var c=function(){function c(a,c){this.allItems=[];this.contentGroup=this.box=void 0;this.display=!1;this.group=void 0;this.offsetWidth=this.maxLegendWidth=this.maxItemWidth=this.legendWidth=this.legendHeight=this.lastLineHeight=this.lastItemY=
this.itemY=this.itemX=this.itemMarginTop=this.itemMarginBottom=this.itemHeight=this.initialItemY=0;this.options={};this.padding=0;this.pages=[];this.proximate=!1;this.scrollGroup=void 0;this.widthOption=this.totalItemWidth=this.titleHeight=this.symbolWidth=this.symbolHeight=0;this.chart=a;this.init(a,c)}c.prototype.init=function(a,c){this.chart=a;this.setOptions(c);c.enabled&&(this.render(),w(this.chart,"endResize",function(){this.legend.positionCheckboxes()}),this.proximate?this.unchartrender=w(this.chart,
"render",function(){this.legend.proximatePositions();this.legend.positionItems()}):this.unchartrender&&this.unchartrender())};c.prototype.setOptions=function(a){var c=n(a.padding,8);this.options=a;this.chart.styledMode||(this.itemStyle=a.itemStyle,this.itemHiddenStyle=u(this.itemStyle,a.itemHiddenStyle));this.itemMarginTop=a.itemMarginTop||0;this.itemMarginBottom=a.itemMarginBottom||0;this.padding=c;this.initialItemY=c-5;this.symbolWidth=n(a.symbolWidth,16);this.pages=[];this.proximate="proximate"===
a.layout&&!this.chart.inverted;this.baseline=void 0};c.prototype.update=function(a,c){var d=this.chart;this.setOptions(u(!0,this.options,a));this.destroy();d.isDirtyLegend=d.isDirtyBox=!0;n(c,!0)&&d.redraw();l(this,"afterUpdate")};c.prototype.colorizeItem=function(a,c){a.legendGroup[c?"removeClass":"addClass"]("highcharts-legend-item-hidden");if(!this.chart.styledMode){var d=this.options,b=a.legendItem,e=a.legendLine,h=a.legendSymbol,g=this.itemHiddenStyle.color;d=c?d.itemStyle.color:g;var f=c?a.color||
g:g,m=a.options&&a.options.marker,k={fill:f};b&&b.css({fill:d,color:d});e&&e.attr({stroke:f});h&&(m&&h.isMarker&&(k=a.pointAttribs(),c||(k.stroke=k.fill=g)),h.attr(k))}l(this,"afterColorizeItem",{item:a,visible:c})};c.prototype.positionItems=function(){this.allItems.forEach(this.positionItem,this);this.chart.isResizing||this.positionCheckboxes()};c.prototype.positionItem=function(a){var c=this,b=this.options,e=b.symbolPadding,g=!b.rtl,f=a._legendItemPos;b=f[0];f=f[1];var k=a.checkbox,m=a.legendGroup;
m&&m.element&&(e={translateX:g?b:this.legendWidth-b-2*e-4,translateY:f},g=function(){l(c,"afterPositionItem",{item:a})},d(m.translateY)?m.animate(e,void 0,g):(m.attr(e),g()));k&&(k.x=b,k.y=f)};c.prototype.destroyItem=function(a){var c=a.checkbox;["legendItem","legendLine","legendSymbol","legendGroup"].forEach(function(c){a[c]&&(a[c]=a[c].destroy())});c&&q(a.checkbox)};c.prototype.destroy=function(){function a(a){this[a]&&(this[a]=this[a].destroy())}this.getAllItems().forEach(function(c){["legendItem",
"legendGroup"].forEach(a,c)});"clipRect up down pager nav box title group".split(" ").forEach(a,this);this.display=null};c.prototype.positionCheckboxes=function(){var a=this.group&&this.group.alignAttr,c=this.clipHeight||this.legendHeight,d=this.titleHeight;if(a){var b=a.translateY;this.allItems.forEach(function(e){var h=e.checkbox;if(h){var g=b+d+h.y+(this.scrollOffset||0)+3;f(h,{left:a.translateX+e.checkboxOffset+h.x-20+"px",top:g+"px",display:this.proximate||g>b-6&&g<b+c-6?"":"none"})}},this)}};
c.prototype.renderTitle=function(){var a=this.options,c=this.padding,d=a.title,b=0;d.text&&(this.title||(this.title=this.chart.renderer.label(d.text,c-3,c-4,null,null,null,a.useHTML,null,"legend-title").attr({zIndex:1}),this.chart.styledMode||this.title.css(d.style),this.title.add(this.group)),d.width||this.title.css({width:this.maxLegendWidth+"px"}),a=this.title.getBBox(),b=a.height,this.offsetWidth=a.width,this.contentGroup.attr({translateY:b}));this.titleHeight=b};c.prototype.setText=function(a){var c=
this.options;a.legendItem.attr({text:c.labelFormat?B(c.labelFormat,a,this.chart):c.labelFormatter.call(a)})};c.prototype.renderItem=function(a){var c=this.chart,d=c.renderer,b=this.options,e=this.symbolWidth,g=b.symbolPadding||0,f=this.itemStyle,l=this.itemHiddenStyle,k="horizontal"===b.layout?n(b.itemDistance,20):0,m=!b.rtl,q=a.legendItem,t=!a.series,p=!t&&a.series.drawLegendSymbol?a.series:a,v=p.options,w=this.createCheckboxForItem&&v&&v.showCheckbox;v=e+g+k+(w?20:0);var E=b.useHTML,F=a.options.className;
q||(a.legendGroup=d.g("legend-item").addClass("highcharts-"+p.type+"-series highcharts-color-"+a.colorIndex+(F?" "+F:"")+(t?" highcharts-series-"+a.index:"")).attr({zIndex:1}).add(this.scrollGroup),a.legendItem=q=d.text("",m?e+g:-g,this.baseline||0,E),c.styledMode||q.css(u(a.visible?f:l)),q.attr({align:m?"left":"right",zIndex:2}).add(a.legendGroup),this.baseline||(this.fontMetrics=d.fontMetrics(c.styledMode?12:f.fontSize,q),this.baseline=this.fontMetrics.f+3+this.itemMarginTop,q.attr("y",this.baseline),
this.symbolHeight=b.symbolHeight||this.fontMetrics.f,b.squareSymbol&&(this.symbolWidth=n(b.symbolWidth,Math.max(this.symbolHeight,16)),v=this.symbolWidth+g+k+(w?20:0),m&&q.attr("x",this.symbolWidth+g))),p.drawLegendSymbol(this,a),this.setItemEvents&&this.setItemEvents(a,q,E));w&&!a.checkbox&&this.createCheckboxForItem&&this.createCheckboxForItem(a);this.colorizeItem(a,a.visible);!c.styledMode&&f.width||q.css({width:(b.itemWidth||this.widthOption||c.spacingBox.width)-v+"px"});this.setText(a);c=q.getBBox();
a.itemWidth=a.checkboxOffset=b.itemWidth||a.legendItemWidth||c.width+v;this.maxItemWidth=Math.max(this.maxItemWidth,a.itemWidth);this.totalItemWidth+=a.itemWidth;this.itemHeight=a.itemHeight=Math.round(a.legendItemHeight||c.height||this.symbolHeight)};c.prototype.layoutItem=function(a){var c=this.options,d=this.padding,b="horizontal"===c.layout,e=a.itemHeight,g=this.itemMarginBottom,f=this.itemMarginTop,l=b?n(c.itemDistance,20):0,m=this.maxLegendWidth;c=c.alignColumns&&this.totalItemWidth>m?this.maxItemWidth:
a.itemWidth;b&&this.itemX-d+c>m&&(this.itemX=d,this.lastLineHeight&&(this.itemY+=f+this.lastLineHeight+g),this.lastLineHeight=0);this.lastItemY=f+this.itemY+g;this.lastLineHeight=Math.max(e,this.lastLineHeight);a._legendItemPos=[this.itemX,this.itemY];b?this.itemX+=c:(this.itemY+=f+e+g,this.lastLineHeight=e);this.offsetWidth=this.widthOption||Math.max((b?this.itemX-d-(a.checkbox?0:l):c)+d,this.offsetWidth)};c.prototype.getAllItems=function(){var a=[];this.chart.series.forEach(function(c){var b=c&&
c.options;c&&n(b.showInLegend,d(b.linkedTo)?!1:void 0,!0)&&(a=a.concat(c.legendItems||("point"===b.legendType?c.data:c)))});l(this,"afterGetAllItems",{allItems:a});return a};c.prototype.getAlignment=function(){var a=this.options;return this.proximate?a.align.charAt(0)+"tv":a.floating?"":a.align.charAt(0)+a.verticalAlign.charAt(0)+a.layout.charAt(0)};c.prototype.adjustMargins=function(a,c){var b=this.chart,e=this.options,h=this.getAlignment();h&&[/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/].forEach(function(g,
f){g.test(h)&&!d(a[f])&&(b[x[f]]=Math.max(b[x[f]],b.legend[(f+1)%2?"legendHeight":"legendWidth"]+[1,-1,-1,1][f]*e[f%2?"x":"y"]+n(e.margin,12)+c[f]+(b.titleOffset[f]||0)))})};c.prototype.proximatePositions=function(){var a=this.chart,c=[],d="left"===this.options.align;this.allItems.forEach(function(b){var e;var h=d;if(b.yAxis){b.xAxis.options.reversed&&(h=!h);b.points&&(e=k(h?b.points:b.points.slice(0).reverse(),function(a){return N(a.plotY)}));h=this.itemMarginTop+b.legendItem.getBBox().height+this.itemMarginBottom;
var g=b.yAxis.top-a.plotTop;b.visible?(e=e?e.plotY:b.yAxis.height,e+=g-.3*h):e=g+b.yAxis.height;c.push({target:e,size:h,item:b})}},this);I.distribute(c,a.plotHeight);c.forEach(function(c){c.item._legendItemPos[1]=a.plotTop-a.spacing[0]+c.pos})};c.prototype.render=function(){var a=this.chart,c=a.renderer,d=this.group,b=this.box,e=this.options,g=this.padding;this.itemX=g;this.itemY=this.initialItemY;this.lastItemY=this.offsetWidth=0;this.widthOption=J(e.width,a.spacingBox.width-g);var f=a.spacingBox.width-
2*g-e.x;-1<["rm","lm"].indexOf(this.getAlignment().substring(0,2))&&(f/=2);this.maxLegendWidth=this.widthOption||f;d||(this.group=d=c.g("legend").attr({zIndex:7}).add(),this.contentGroup=c.g().attr({zIndex:1}).add(d),this.scrollGroup=c.g().add(this.contentGroup));this.renderTitle();var m=this.getAllItems();E(m,function(a,c){return(a.options&&a.options.legendIndex||0)-(c.options&&c.options.legendIndex||0)});e.reversed&&m.reverse();this.allItems=m;this.display=f=!!m.length;this.itemHeight=this.totalItemWidth=
this.maxItemWidth=this.lastLineHeight=0;m.forEach(this.renderItem,this);m.forEach(this.layoutItem,this);m=(this.widthOption||this.offsetWidth)+g;var k=this.lastItemY+this.lastLineHeight+this.titleHeight;k=this.handleOverflow(k);k+=g;b||(this.box=b=c.rect().addClass("highcharts-legend-box").attr({r:e.borderRadius}).add(d),b.isNew=!0);a.styledMode||b.attr({stroke:e.borderColor,"stroke-width":e.borderWidth||0,fill:e.backgroundColor||"none"}).shadow(e.shadow);0<m&&0<k&&(b[b.isNew?"attr":"animate"](b.crisp.call({},
{x:0,y:0,width:m,height:k},b.strokeWidth())),b.isNew=!1);b[f?"show":"hide"]();a.styledMode&&"none"===d.getStyle("display")&&(m=k=0);this.legendWidth=m;this.legendHeight=k;f&&this.align();this.proximate||this.positionItems();l(this,"afterRender")};c.prototype.align=function(a){void 0===a&&(a=this.chart.spacingBox);var c=this.chart,d=this.options,b=a.y;/(lth|ct|rth)/.test(this.getAlignment())&&0<c.titleOffset[0]?b+=c.titleOffset[0]:/(lbh|cb|rbh)/.test(this.getAlignment())&&0<c.titleOffset[2]&&(b-=c.titleOffset[2]);
b!==a.y&&(a=u(a,{y:b}));this.group.align(u(d,{width:this.legendWidth,height:this.legendHeight,verticalAlign:this.proximate?"top":d.verticalAlign}),!0,a)};c.prototype.handleOverflow=function(a){var c=this,d=this.chart,b=d.renderer,e=this.options,g=e.y,f=this.padding;g=d.spacingBox.height+("top"===e.verticalAlign?-g:g)-f;var m=e.maxHeight,k,l=this.clipRect,q=e.navigation,t=n(q.animation,!0),p=q.arrowSize||12,u=this.nav,v=this.pages,w,F=this.allItems,S=function(a){"number"===typeof a?l.attr({height:a}):
l&&(c.clipRect=l.destroy(),c.contentGroup.clip());c.contentGroup.div&&(c.contentGroup.div.style.clip=a?"rect("+f+"px,9999px,"+(f+a)+"px,0)":"auto")},K=function(a){c[a]=b.circle(0,0,1.3*p).translate(p/2,p/2).add(u);d.styledMode||c[a].attr("fill","rgba(0,0,0,0.0001)");return c[a]};"horizontal"!==e.layout||"middle"===e.verticalAlign||e.floating||(g/=2);m&&(g=Math.min(g,m));v.length=0;a&&0<g&&a>g&&!1!==q.enabled?(this.clipHeight=k=Math.max(g-20-this.titleHeight-f,0),this.currentPage=n(this.currentPage,
1),this.fullHeight=a,F.forEach(function(a,c){var d=a._legendItemPos[1],b=Math.round(a.legendItem.getBBox().height),e=v.length;if(!e||d-v[e-1]>k&&(w||d)!==v[e-1])v.push(w||d),e++;a.pageIx=e-1;w&&(F[c-1].pageIx=e-1);c===F.length-1&&d+b-v[e-1]>k&&d!==w&&(v.push(d),a.pageIx=e);d!==w&&(w=d)}),l||(l=c.clipRect=b.clipRect(0,f,9999,0),c.contentGroup.clip(l)),S(k),u||(this.nav=u=b.g().attr({zIndex:1}).add(this.group),this.up=b.symbol("triangle",0,0,p,p).add(u),K("upTracker").on("click",function(){c.scroll(-1,
t)}),this.pager=b.text("",15,10).addClass("highcharts-legend-navigation"),d.styledMode||this.pager.css(q.style),this.pager.add(u),this.down=b.symbol("triangle-down",0,0,p,p).add(u),K("downTracker").on("click",function(){c.scroll(1,t)})),c.scroll(0),a=g):u&&(S(),this.nav=u.destroy(),this.scrollGroup.attr({translateY:1}),this.clipHeight=0);return a};c.prototype.scroll=function(a,c){var d=this,b=this.chart,e=this.pages,h=e.length,g=this.currentPage+a;a=this.clipHeight;var f=this.options.navigation,k=
this.pager,q=this.padding;g>h&&(g=h);0<g&&("undefined"!==typeof c&&C(c,b),this.nav.attr({translateX:q,translateY:a+this.padding+7+this.titleHeight,visibility:"visible"}),[this.up,this.upTracker].forEach(function(a){a.attr({"class":1===g?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"})}),k.attr({text:g+"/"+h}),[this.down,this.downTracker].forEach(function(a){a.attr({x:18+this.pager.getBBox().width,"class":g===h?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"})},this),
b.styledMode||(this.up.attr({fill:1===g?f.inactiveColor:f.activeColor}),this.upTracker.css({cursor:1===g?"default":"pointer"}),this.down.attr({fill:g===h?f.inactiveColor:f.activeColor}),this.downTracker.css({cursor:g===h?"default":"pointer"})),this.scrollOffset=-e[g-1]+this.initialItemY,this.scrollGroup.animate({translateY:this.scrollOffset}),this.currentPage=g,this.positionCheckboxes(),c=D(n(c,b.renderer.globalAnimation,!0)),m(function(){l(d,"afterScroll",{currentPage:g})},c.duration))};c.prototype.setItemEvents=
function(a,c,d){var b=this,e=b.chart.renderer.boxWrapper,h=a instanceof z,g="highcharts-legend-"+(h?"point":"series")+"-active",f=b.chart.styledMode;(d?[c,a.legendSymbol]:[a.legendGroup]).forEach(function(d){if(d)d.on("mouseover",function(){a.visible&&b.allItems.forEach(function(c){a!==c&&c.setState("inactive",!h)});a.setState("hover");a.visible&&e.addClass(g);f||c.css(b.options.itemHoverStyle)}).on("mouseout",function(){b.chart.styledMode||c.css(u(a.visible?b.itemStyle:b.itemHiddenStyle));b.allItems.forEach(function(c){a!==
c&&c.setState("",!h)});e.removeClass(g);a.setState()}).on("click",function(c){var d=function(){a.setVisible&&a.setVisible();b.allItems.forEach(function(c){a!==c&&c.setState(a.visible?"inactive":"",!h)})};e.removeClass(g);c={browserEvent:c};a.firePointEvent?a.firePointEvent("legendItemClick",c,d):l(a,"legendItemClick",c,d)})})};c.prototype.createCheckboxForItem=function(a){a.checkbox=v("input",{type:"checkbox",className:"highcharts-legend-checkbox",checked:a.selected,defaultChecked:a.selected},this.options.itemCheckboxStyle,
this.chart.container);w(a.checkbox,"click",function(c){l(a.series||a,"checkboxClick",{checked:c.target.checked,item:a},function(){a.select()})})};return c}();(/Trident\/7\.0/.test(b.navigator&&b.navigator.userAgent)||e)&&H(c.prototype,"positionItem",function(c,a){var d=this,b=function(){a._legendItemPos&&c.call(d,a)};b();d.bubbleLegend||setTimeout(b)});I.Legend=c;return I.Legend});O(e,"Core/Series/SeriesRegistry.js",[e["Core/Globals.js"],e["Core/Options.js"],e["Core/Series/Point.js"],e["Core/Utilities.js"]],
function(e,b,I,z){var D=b.defaultOptions,G=z.error,C=z.extendClass,B=z.merge,x;(function(b){function v(e,d){var f=D.plotOptions||{},k=d.defaultOptions;d.prototype.pointClass||(d.prototype.pointClass=I);d.prototype.type=e;k&&(f[e]=k);b.seriesTypes[e]=d}b.seriesTypes=e.seriesTypes;b.getSeries=function(e,d){void 0===d&&(d={});var f=e.options.chart;f=d.type||f.type||f.defaultSeriesType||"";var k=b.seriesTypes[f];b||G(17,!0,e,{missingModuleFor:f});f=new k;"function"===typeof f.init&&f.init(e,d);return f};
b.registerSeriesType=v;b.seriesType=function(e,d,q,k,l){var f=D.plotOptions||{};d=d||"";f[e]=B(f[d],q);v(e,C(b.seriesTypes[d]||function(){},k));b.seriesTypes[e].prototype.type=e;l&&(b.seriesTypes[e].prototype.pointClass=C(I,l));return b.seriesTypes[e]}})(x||(x={}));e.seriesType=x.seriesType;return x});O(e,"Core/Chart/Chart.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Axis/Axis.js"],e["Core/FormatUtilities.js"],e["Core/Globals.js"],e["Core/Legend.js"],e["Core/MSPointer.js"],e["Core/Options.js"],
e["Core/Color/Palette.js"],e["Core/Pointer.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Time.js"],e["Core/Utilities.js"],e["Core/Renderer/HTML/AST.js"]],function(e,b,I,z,H,G,C,B,x,w,v,f,d){var q=e.animate,k=e.animObject,l=e.setAnimation,D=I.numberFormat,u=z.charts,n=z.doc,J=z.win,E=C.defaultOptions,m=C.defaultTime,c=w.seriesTypes,g=f.addEvent,a=f.attr,h=f.cleanRecursively,r=f.createElement,A=f.css,y=f.defined,L=f.discardElement,P=f.erase,R=f.error,V=f.extend,Q=f.find,M=f.fireEvent,t=f.getStyle,
p=f.isArray,O=f.isFunction,Z=f.isNumber,ea=f.isObject,F=f.isString,S=f.merge,K=f.objectEach,T=f.pick,X=f.pInt,U=f.relativeLength,fa=f.removeEvent,Y=f.splat,ba=f.syncTimeout,ha=f.uniqueKey,ca=z.marginNames,aa=function(){function e(a,c,d){this.series=this.renderTo=this.renderer=this.pointer=this.pointCount=this.plotWidth=this.plotTop=this.plotLeft=this.plotHeight=this.plotBox=this.options=this.numberFormatter=this.margin=this.legend=this.labelCollectors=this.isResizing=this.index=this.container=this.colorCounter=
this.clipBox=this.chartWidth=this.chartHeight=this.bounds=this.axisOffset=this.axes=void 0;this.sharedClips={};this.yAxis=this.xAxis=this.userOptions=this.titleOffset=this.time=this.symbolCounter=this.spacingBox=this.spacing=void 0;this.getArgs(a,c,d)}e.prototype.getArgs=function(a,c,d){F(a)||a.nodeName?(this.renderTo=a,this.init(c,d)):this.init(a,c)};e.prototype.init=function(a,c){var d=a.plotOptions||{};M(this,"init",{args:arguments},function(){var b=S(E,a),e=b.chart;K(b.plotOptions,function(a,
c){ea(a)&&(a.tooltip=d[c]&&S(d[c].tooltip)||void 0)});b.tooltip.userOptions=a.chart&&a.chart.forExport&&a.tooltip.userOptions||a.tooltip;this.userOptions=a;var h=e.events;this.margin=[];this.spacing=[];this.bounds={h:{},v:{}};this.labelCollectors=[];this.callback=c;this.isResizing=0;this.options=b;this.axes=[];this.series=[];this.time=a.time&&Object.keys(a.time).length?new v(a.time):z.time;this.numberFormatter=e.numberFormatter||D;this.styledMode=e.styledMode;this.hasCartesianSeries=e.showAxes;var f=
this;f.index=u.length;u.push(f);z.chartCount++;h&&K(h,function(a,c){O(a)&&g(f,c,a)});f.xAxis=[];f.yAxis=[];f.pointCount=f.colorCounter=f.symbolCounter=0;M(f,"afterInit");f.firstRender()})};e.prototype.initSeries=function(a){var d=this.options.chart;d=a.type||d.type||d.defaultSeriesType;var b=c[d];b||R(17,!0,this,{missingModuleFor:d});d=new b;"function"===typeof d.init&&d.init(this,a);return d};e.prototype.setSeriesData=function(){this.getSeriesOrderByLinks().forEach(function(a){a.points||a.data||
!a.enabledDataSorting||a.setData(a.options.data,!1)})};e.prototype.getSeriesOrderByLinks=function(){return this.series.concat().sort(function(a,c){return a.linkedSeries.length||c.linkedSeries.length?c.linkedSeries.length-a.linkedSeries.length:0})};e.prototype.orderSeries=function(a){var c=this.series;for(a=a||0;a<c.length;a++)c[a]&&(c[a].index=a,c[a].name=c[a].getName())};e.prototype.isInsidePlot=function(a,c,d){void 0===d&&(d={});var b=this.inverted,e=this.plotBox,h=this.plotLeft,g=this.plotTop,
f=this.scrollablePlotBox,m=this.scrollingContainer;m=void 0===m?{scrollLeft:0,scrollTop:0}:m;var k=m.scrollLeft;m=m.scrollTop;var l=d.series;e=d.visiblePlotOnly&&f||e;f=d.inverted?c:a;c=d.inverted?a:c;a={x:f,y:c,isInsidePlot:!0};if(!d.ignoreX){var F=l&&(b?l.yAxis:l.xAxis)||{pos:h,len:Infinity};f=d.paneCoordinates?F.pos+f:h+f;f>=Math.max(k+h,F.pos)&&f<=Math.min(k+h+e.width,F.pos+F.len)||(a.isInsidePlot=!1)}!d.ignoreY&&a.isInsidePlot&&(b=l&&(b?l.xAxis:l.yAxis)||{pos:g,len:Infinity},d=d.paneCoordinates?
b.pos+c:g+c,d>=Math.max(m+g,b.pos)&&d<=Math.min(m+g+e.height,b.pos+b.len)||(a.isInsidePlot=!1));M(this,"afterIsInsidePlot",a);return a.isInsidePlot};e.prototype.redraw=function(a){M(this,"beforeRedraw");var c=this.hasCartesianSeries?this.axes:this.colorAxis||[],d=this.series,b=this.pointer,e=this.legend,h=this.userOptions.legend,g=this.isDirtyLegend,f=this.isDirtyBox,m=this.renderer,k=m.isHidden(),F=[];this.setResponsive&&this.setResponsive(!1);l(this.hasRendered?a:!1,this);k&&this.temporaryDisplay();
this.layOutTitles();for(a=d.length;a--;){var n=d[a];if(n.options.stacking||n.options.centerInCategory){var r=!0;if(n.isDirty){var K=!0;break}}}if(K)for(a=d.length;a--;)n=d[a],n.options.stacking&&(n.isDirty=!0);d.forEach(function(a){a.isDirty&&("point"===a.options.legendType?("function"===typeof a.updateTotals&&a.updateTotals(),g=!0):h&&(h.labelFormatter||h.labelFormat)&&(g=!0));a.isDirtyData&&M(a,"updatedData")});g&&e&&e.options.enabled&&(e.render(),this.isDirtyLegend=!1);r&&this.getStacks();c.forEach(function(a){a.updateNames();
a.setScale()});this.getMargins();c.forEach(function(a){a.isDirty&&(f=!0)});c.forEach(function(a){var c=a.min+","+a.max;a.extKey!==c&&(a.extKey=c,F.push(function(){M(a,"afterSetExtremes",V(a.eventArgs,a.getExtremes()));delete a.eventArgs}));(f||r)&&a.redraw()});f&&this.drawChartBox();M(this,"predraw");d.forEach(function(a){(f||a.isDirty)&&a.visible&&a.redraw();a.isDirtyData=!1});b&&b.reset(!0);m.draw();M(this,"redraw");M(this,"render");k&&this.temporaryDisplay(!0);F.forEach(function(a){a.call()})};
e.prototype.get=function(a){function c(c){return c.id===a||c.options&&c.options.id===a}var d=this.series,b;var e=Q(this.axes,c)||Q(this.series,c);for(b=0;!e&&b<d.length;b++)e=Q(d[b].points||[],c);return e};e.prototype.getAxes=function(){var a=this,c=this.options,d=c.xAxis=Y(c.xAxis||{});c=c.yAxis=Y(c.yAxis||{});M(this,"getAxes");d.forEach(function(a,c){a.index=c;a.isX=!0});c.forEach(function(a,c){a.index=c});d.concat(c).forEach(function(c){new b(a,c)});M(this,"afterGetAxes")};e.prototype.getSelectedPoints=
function(){var a=[];this.series.forEach(function(c){a=a.concat(c.getPointsCollection().filter(function(a){return T(a.selectedStaging,a.selected)}))});return a};e.prototype.getSelectedSeries=function(){return this.series.filter(function(a){return a.selected})};e.prototype.setTitle=function(a,c,d){this.applyDescription("title",a);this.applyDescription("subtitle",c);this.applyDescription("caption",void 0);this.layOutTitles(d)};e.prototype.applyDescription=function(a,c){var d=this,b="title"===a?{color:B.neutralColor80,
fontSize:this.options.isStock?"16px":"18px"}:{color:B.neutralColor60};b=this.options[a]=S(!this.styledMode&&{style:b},this.options[a],c);var e=this[a];e&&c&&(this[a]=e=e.destroy());b&&!e&&(e=this.renderer.text(b.text,0,0,b.useHTML).attr({align:b.align,"class":"highcharts-"+a,zIndex:b.zIndex||4}).add(),e.update=function(c){d[{title:"setTitle",subtitle:"setSubtitle",caption:"setCaption"}[a]](c)},this.styledMode||e.css(b.style),this[a]=e)};e.prototype.layOutTitles=function(a){var c=[0,0,0],d=this.renderer,
b=this.spacingBox;["title","subtitle","caption"].forEach(function(a){var e=this[a],h=this.options[a],g=h.verticalAlign||"top";a="title"===a?-3:"top"===g?c[0]+2:0;if(e){if(!this.styledMode)var f=h.style.fontSize;f=d.fontMetrics(f,e).b;e.css({width:(h.width||b.width+(h.widthAdjust||0))+"px"});var m=Math.round(e.getBBox(h.useHTML).height);e.align(V({y:"bottom"===g?f:a+f,height:m},h),!1,"spacingBox");h.floating||("top"===g?c[0]=Math.ceil(c[0]+m):"bottom"===g&&(c[2]=Math.ceil(c[2]+m)))}},this);c[0]&&"top"===
(this.options.title.verticalAlign||"top")&&(c[0]+=this.options.title.margin);c[2]&&"bottom"===this.options.caption.verticalAlign&&(c[2]+=this.options.caption.margin);var e=!this.titleOffset||this.titleOffset.join(",")!==c.join(",");this.titleOffset=c;M(this,"afterLayOutTitles");!this.isDirtyBox&&e&&(this.isDirtyBox=this.isDirtyLegend=e,this.hasRendered&&T(a,!0)&&this.isDirtyBox&&this.redraw())};e.prototype.getChartSize=function(){var a=this.options.chart,c=a.width;a=a.height;var d=this.renderTo;y(c)||
(this.containerWidth=t(d,"width"));y(a)||(this.containerHeight=t(d,"height"));this.chartWidth=Math.max(0,c||this.containerWidth||600);this.chartHeight=Math.max(0,U(a,this.chartWidth)||(1<this.containerHeight?this.containerHeight:400))};e.prototype.temporaryDisplay=function(a){var c=this.renderTo;if(a)for(;c&&c.style;)c.hcOrigStyle&&(A(c,c.hcOrigStyle),delete c.hcOrigStyle),c.hcOrigDetached&&(n.body.removeChild(c),c.hcOrigDetached=!1),c=c.parentNode;else for(;c&&c.style;){n.body.contains(c)||c.parentNode||
(c.hcOrigDetached=!0,n.body.appendChild(c));if("none"===t(c,"display",!1)||c.hcOricDetached)c.hcOrigStyle={display:c.style.display,height:c.style.height,overflow:c.style.overflow},a={display:"block",overflow:"hidden"},c!==this.renderTo&&(a.height=0),A(c,a),c.offsetWidth||c.style.setProperty("display","block","important");c=c.parentNode;if(c===n.body)break}};e.prototype.setClassName=function(a){this.container.className="highcharts-container "+(a||"")};e.prototype.getContainer=function(){var c=this.options,
d=c.chart;var b=this.renderTo;var e=ha(),h,g;b||(this.renderTo=b=d.renderTo);F(b)&&(this.renderTo=b=n.getElementById(b));b||R(13,!0,this);var f=X(a(b,"data-highcharts-chart"));Z(f)&&u[f]&&u[f].hasRendered&&u[f].destroy();a(b,"data-highcharts-chart",this.index);b.innerHTML="";d.skipClone||b.offsetWidth||this.temporaryDisplay();this.getChartSize();f=this.chartWidth;var m=this.chartHeight;A(b,{overflow:"hidden"});this.styledMode||(h=V({position:"relative",overflow:"hidden",width:f+"px",height:m+"px",
textAlign:"left",lineHeight:"normal",zIndex:0,"-webkit-tap-highlight-color":"rgba(0,0,0,0)",userSelect:"none","touch-action":"manipulation",outline:"none"},d.style||{}));this.container=b=r("div",{id:e},h,b);this._cursor=b.style.cursor;this.renderer=new (z[d.renderer]||z.Renderer)(b,f,m,null,d.forExport,c.exporting&&c.exporting.allowHTML,this.styledMode);l(void 0,this);this.setClassName(d.className);if(this.styledMode)for(g in c.defs)this.renderer.definition(c.defs[g]);else this.renderer.setStyle(d.style);
this.renderer.chartIndex=this.index;M(this,"afterGetContainer")};e.prototype.getMargins=function(a){var c=this.spacing,d=this.margin,b=this.titleOffset;this.resetMargins();b[0]&&!y(d[0])&&(this.plotTop=Math.max(this.plotTop,b[0]+c[0]));b[2]&&!y(d[2])&&(this.marginBottom=Math.max(this.marginBottom,b[2]+c[2]));this.legend&&this.legend.display&&this.legend.adjustMargins(d,c);M(this,"getMargins");a||this.getAxisMargins()};e.prototype.getAxisMargins=function(){var a=this,c=a.axisOffset=[0,0,0,0],d=a.colorAxis,
b=a.margin,e=function(a){a.forEach(function(a){a.visible&&a.getOffset()})};a.hasCartesianSeries?e(a.axes):d&&d.length&&e(d);ca.forEach(function(d,e){y(b[e])||(a[d]+=c[e])});a.setChartSize()};e.prototype.reflow=function(a){var c=this,d=c.options.chart,b=c.renderTo,e=y(d.width)&&y(d.height),h=d.width||t(b,"width");d=d.height||t(b,"height");b=a?a.target:J;delete c.pointer.chartPosition;if(!e&&!c.isPrinting&&h&&d&&(b===J||b===n)){if(h!==c.containerWidth||d!==c.containerHeight)f.clearTimeout(c.reflowTimeout),
c.reflowTimeout=ba(function(){c.container&&c.setSize(void 0,void 0,!1)},a?100:0);c.containerWidth=h;c.containerHeight=d}};e.prototype.setReflow=function(a){var c=this;!1===a||this.unbindReflow?!1===a&&this.unbindReflow&&(this.unbindReflow=this.unbindReflow()):(this.unbindReflow=g(J,"resize",function(a){c.options&&c.reflow(a)}),g(this,"destroy",this.unbindReflow))};e.prototype.setSize=function(a,c,d){var b=this,e=b.renderer;b.isResizing+=1;l(d,b);d=e.globalAnimation;b.oldChartHeight=b.chartHeight;
b.oldChartWidth=b.chartWidth;"undefined"!==typeof a&&(b.options.chart.width=a);"undefined"!==typeof c&&(b.options.chart.height=c);b.getChartSize();b.styledMode||(d?q:A)(b.container,{width:b.chartWidth+"px",height:b.chartHeight+"px"},d);b.setChartSize(!0);e.setSize(b.chartWidth,b.chartHeight,d);b.axes.forEach(function(a){a.isDirty=!0;a.setScale()});b.isDirtyLegend=!0;b.isDirtyBox=!0;b.layOutTitles();b.getMargins();b.redraw(d);b.oldChartHeight=null;M(b,"resize");ba(function(){b&&M(b,"endResize",null,
function(){--b.isResizing})},k(d).duration)};e.prototype.setChartSize=function(a){var c=this.inverted,d=this.renderer,b=this.chartWidth,e=this.chartHeight,h=this.options.chart,g=this.spacing,f=this.clipOffset,m,l,k,F;this.plotLeft=m=Math.round(this.plotLeft);this.plotTop=l=Math.round(this.plotTop);this.plotWidth=k=Math.max(0,Math.round(b-m-this.marginRight));this.plotHeight=F=Math.max(0,Math.round(e-l-this.marginBottom));this.plotSizeX=c?F:k;this.plotSizeY=c?k:F;this.plotBorderWidth=h.plotBorderWidth||
0;this.spacingBox=d.spacingBox={x:g[3],y:g[0],width:b-g[3]-g[1],height:e-g[0]-g[2]};this.plotBox=d.plotBox={x:m,y:l,width:k,height:F};e=2*Math.floor(this.plotBorderWidth/2);c=Math.ceil(Math.max(e,f[3])/2);b=Math.ceil(Math.max(e,f[0])/2);this.clipBox={x:c,y:b,width:Math.floor(this.plotSizeX-Math.max(e,f[1])/2-c),height:Math.max(0,Math.floor(this.plotSizeY-Math.max(e,f[2])/2-b))};a||(this.axes.forEach(function(a){a.setAxisSize();a.setAxisTranslation()}),d.alignElements());M(this,"afterSetChartSize",
{skipAxes:a})};e.prototype.resetMargins=function(){M(this,"resetMargins");var a=this,c=a.options.chart;["margin","spacing"].forEach(function(d){var b=c[d],e=ea(b)?b:[b,b,b,b];["Top","Right","Bottom","Left"].forEach(function(b,h){a[d][h]=T(c[d+b],e[h])})});ca.forEach(function(c,d){a[c]=T(a.margin[d],a.spacing[d])});a.axisOffset=[0,0,0,0];a.clipOffset=[0,0,0,0]};e.prototype.drawChartBox=function(){var a=this.options.chart,c=this.renderer,d=this.chartWidth,b=this.chartHeight,e=this.chartBackground,h=
this.plotBackground,g=this.plotBorder,f=this.styledMode,m=this.plotBGImage,k=a.backgroundColor,l=a.plotBackgroundColor,F=a.plotBackgroundImage,n,r=this.plotLeft,K=this.plotTop,q=this.plotWidth,p=this.plotHeight,u=this.plotBox,v=this.clipRect,t=this.clipBox,w="animate";e||(this.chartBackground=e=c.rect().addClass("highcharts-background").add(),w="attr");if(f)var y=n=e.strokeWidth();else{y=a.borderWidth||0;n=y+(a.shadow?8:0);k={fill:k||"none"};if(y||e["stroke-width"])k.stroke=a.borderColor,k["stroke-width"]=
y;e.attr(k).shadow(a.shadow)}e[w]({x:n/2,y:n/2,width:d-n-y%2,height:b-n-y%2,r:a.borderRadius});w="animate";h||(w="attr",this.plotBackground=h=c.rect().addClass("highcharts-plot-background").add());h[w](u);f||(h.attr({fill:l||"none"}).shadow(a.plotShadow),F&&(m?(F!==m.attr("href")&&m.attr("href",F),m.animate(u)):this.plotBGImage=c.image(F,r,K,q,p).add()));v?v.animate({width:t.width,height:t.height}):this.clipRect=c.clipRect(t);w="animate";g||(w="attr",this.plotBorder=g=c.rect().addClass("highcharts-plot-border").attr({zIndex:1}).add());
f||g.attr({stroke:a.plotBorderColor,"stroke-width":a.plotBorderWidth||0,fill:"none"});g[w](g.crisp({x:r,y:K,width:q,height:p},-g.strokeWidth()));this.isDirtyBox=!1;M(this,"afterDrawChartBox")};e.prototype.propFromSeries=function(){var a=this,d=a.options.chart,b,e=a.options.series,h,g;["inverted","angular","polar"].forEach(function(f){b=c[d.type||d.defaultSeriesType];g=d[f]||b&&b.prototype[f];for(h=e&&e.length;!g&&h--;)(b=c[e[h].type])&&b.prototype[f]&&(g=!0);a[f]=g})};e.prototype.linkSeries=function(){var a=
this,c=a.series;c.forEach(function(a){a.linkedSeries.length=0});c.forEach(function(c){var d=c.options.linkedTo;F(d)&&(d=":previous"===d?a.series[c.index-1]:a.get(d))&&d.linkedParent!==c&&(d.linkedSeries.push(c),c.linkedParent=d,d.enabledDataSorting&&c.setDataSortingOptions(),c.visible=T(c.options.visible,d.options.visible,c.visible))});M(this,"afterLinkSeries")};e.prototype.renderSeries=function(){this.series.forEach(function(a){a.translate();a.render()})};e.prototype.renderLabels=function(){var a=
this,c=a.options.labels;c.items&&c.items.forEach(function(d){var b=V(c.style,d.style),e=X(b.left)+a.plotLeft,h=X(b.top)+a.plotTop+12;delete b.left;delete b.top;a.renderer.text(d.html,e,h).attr({zIndex:2}).css(b).add()})};e.prototype.render=function(){var a=this.axes,c=this.colorAxis,d=this.renderer,b=this.options,e=0,h=function(a){a.forEach(function(a){a.visible&&a.render()})};this.setTitle();this.legend=new H(this,b.legend);this.getStacks&&this.getStacks();this.getMargins(!0);this.setChartSize();
b=this.plotWidth;a.some(function(a){if(a.horiz&&a.visible&&a.options.labels.enabled&&a.series.length)return e=21,!0});var g=this.plotHeight=Math.max(this.plotHeight-e,0);a.forEach(function(a){a.setScale()});this.getAxisMargins();var f=1.1<b/this.plotWidth;var m=1.05<g/this.plotHeight;if(f||m)a.forEach(function(a){(a.horiz&&f||!a.horiz&&m)&&a.setTickInterval(!0)}),this.getMargins();this.drawChartBox();this.hasCartesianSeries?h(a):c&&c.length&&h(c);this.seriesGroup||(this.seriesGroup=d.g("series-group").attr({zIndex:3}).add());
this.renderSeries();this.renderLabels();this.addCredits();this.setResponsive&&this.setResponsive();this.hasRendered=!0};e.prototype.addCredits=function(a){var c=this,d=S(!0,this.options.credits,a);d.enabled&&!this.credits&&(this.credits=this.renderer.text(d.text+(this.mapCredits||""),0,0).addClass("highcharts-credits").on("click",function(){d.href&&(J.location.href=d.href)}).attr({align:d.position.align,zIndex:8}),c.styledMode||this.credits.css(d.style),this.credits.add().align(d.position),this.credits.update=
function(a){c.credits=c.credits.destroy();c.addCredits(a)})};e.prototype.destroy=function(){var a=this,c=a.axes,d=a.series,b=a.container,e,h=b&&b.parentNode;M(a,"destroy");a.renderer.forExport?P(u,a):u[a.index]=void 0;z.chartCount--;a.renderTo.removeAttribute("data-highcharts-chart");fa(a);for(e=c.length;e--;)c[e]=c[e].destroy();this.scroller&&this.scroller.destroy&&this.scroller.destroy();for(e=d.length;e--;)d[e]=d[e].destroy();"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function(c){var d=
a[c];d&&d.destroy&&(a[c]=d.destroy())});b&&(b.innerHTML="",fa(b),h&&L(b));K(a,function(c,d){delete a[d]})};e.prototype.firstRender=function(){var a=this,c=a.options;if(!a.isReadyToRender||a.isReadyToRender()){a.getContainer();a.resetMargins();a.setChartSize();a.propFromSeries();a.getAxes();(p(c.series)?c.series:[]).forEach(function(c){a.initSeries(c)});a.linkSeries();a.setSeriesData();M(a,"beforeRender");x&&(a.pointer=z.hasTouch||!J.PointerEvent&&!J.MSPointerEvent?new x(a,c):new G(a,c));a.render();
a.pointer.getChartPosition();if(!a.renderer.imgCount&&!a.hasLoaded)a.onload();a.temporaryDisplay(!0)}};e.prototype.onload=function(){this.callbacks.concat([this.callback]).forEach(function(a){a&&"undefined"!==typeof this.index&&a.apply(this,[this])},this);M(this,"load");M(this,"render");y(this.index)&&this.setReflow(this.options.chart.reflow);this.hasLoaded=!0};e.prototype.addSeries=function(a,c,d){var b,e=this;a&&(c=T(c,!0),M(e,"addSeries",{options:a},function(){b=e.initSeries(a);e.isDirtyLegend=
!0;e.linkSeries();b.enabledDataSorting&&b.setData(a.data,!1);M(e,"afterAddSeries",{series:b});c&&e.redraw(d)}));return b};e.prototype.addAxis=function(a,c,d,b){return this.createAxis(c?"xAxis":"yAxis",{axis:a,redraw:d,animation:b})};e.prototype.addColorAxis=function(a,c,d){return this.createAxis("colorAxis",{axis:a,redraw:c,animation:d})};e.prototype.createAxis=function(a,c){var d="colorAxis"===a,e=c.redraw,h=c.animation;a=S(c.axis,{index:this[a].length,isX:"xAxis"===a});a=d?new z.ColorAxis(this,
a):new b(this,a);d&&(this.isDirtyLegend=!0,this.axes.forEach(function(a){a.series=[]}),this.series.forEach(function(a){a.bindAxes();a.isDirtyData=!0}));T(e,!0)&&this.redraw(h);return a};e.prototype.showLoading=function(a){var c=this,b=c.options,e=c.loadingDiv,h=c.loadingSpan,f=b.loading,m=function(){e&&A(e,{left:c.plotLeft+"px",top:c.plotTop+"px",width:c.plotWidth+"px",height:c.plotHeight+"px"})};e||(c.loadingDiv=e=r("div",{className:"highcharts-loading highcharts-loading-hidden"},null,c.container));
h||(c.loadingSpan=h=r("span",{className:"highcharts-loading-inner"},null,e),g(c,"redraw",m));e.className="highcharts-loading";d.setElementHTML(h,T(a,b.lang.loading,""));c.styledMode||(A(e,V(f.style,{zIndex:10})),A(h,f.labelStyle),c.loadingShown||(A(e,{opacity:0,display:""}),q(e,{opacity:f.style.opacity||.5},{duration:f.showDuration||0})));c.loadingShown=!0;m()};e.prototype.hideLoading=function(){var a=this.options,c=this.loadingDiv;c&&(c.className="highcharts-loading highcharts-loading-hidden",this.styledMode||
q(c,{opacity:0},{duration:a.loading.hideDuration||100,complete:function(){A(c,{display:"none"})}}));this.loadingShown=!1};e.prototype.update=function(a,c,d,b){var e=this,g={credits:"addCredits",title:"setTitle",subtitle:"setSubtitle",caption:"setCaption"},f,k,l,n=a.isResponsiveOptions,r=[];M(e,"update",{options:a});n||e.setResponsive(!1,!0);a=h(a,e.options);e.userOptions=S(e.userOptions,a);if(f=a.chart){S(!0,e.options.chart,f);"className"in f&&e.setClassName(f.className);"reflow"in f&&e.setReflow(f.reflow);
if("inverted"in f||"polar"in f||"type"in f){e.propFromSeries();var q=!0}"alignTicks"in f&&(q=!0);K(f,function(a,c){-1!==e.propsRequireUpdateSeries.indexOf("chart."+c)&&(k=!0);-1!==e.propsRequireDirtyBox.indexOf(c)&&(e.isDirtyBox=!0);-1!==e.propsRequireReflow.indexOf(c)&&(n?e.isDirtyBox=!0:l=!0)});!e.styledMode&&"style"in f&&e.renderer.setStyle(f.style)}!e.styledMode&&a.colors&&(this.options.colors=a.colors);a.time&&(this.time===m&&(this.time=new v(a.time)),S(!0,e.options.time,a.time));K(a,function(c,
d){if(e[d]&&"function"===typeof e[d].update)e[d].update(c,!1);else if("function"===typeof e[g[d]])e[g[d]](c);else"colors"!==d&&-1===e.collectionsWithUpdate.indexOf(d)&&S(!0,e.options[d],a[d]);"chart"!==d&&-1!==e.propsRequireUpdateSeries.indexOf(d)&&(k=!0)});this.collectionsWithUpdate.forEach(function(c){if(a[c]){var b=[];e[c].forEach(function(a,c){a.options.isInternal||b.push(T(a.options.index,c))});Y(a[c]).forEach(function(a,h){var g=y(a.id),f;g&&(f=e.get(a.id));!f&&e[c]&&(f=e[c][b?b[h]:h])&&g&&
y(f.options.id)&&(f=void 0);f&&f.coll===c&&(f.update(a,!1),d&&(f.touched=!0));!f&&d&&e.collectionsWithInit[c]&&(e.collectionsWithInit[c][0].apply(e,[a].concat(e.collectionsWithInit[c][1]||[]).concat([!1])).touched=!0)});d&&e[c].forEach(function(a){a.touched||a.options.isInternal?delete a.touched:r.push(a)})}});r.forEach(function(a){a.chart&&a.remove(!1)});q&&e.axes.forEach(function(a){a.update({},!1)});k&&e.getSeriesOrderByLinks().forEach(function(a){a.chart&&a.update({},!1)},this);q=f&&f.width;f=
f&&f.height;F(f)&&(f=U(f,q||e.chartWidth));l||Z(q)&&q!==e.chartWidth||Z(f)&&f!==e.chartHeight?e.setSize(q,f,b):T(c,!0)&&e.redraw(b);M(e,"afterUpdate",{options:a,redraw:c,animation:b})};e.prototype.setSubtitle=function(a,c){this.applyDescription("subtitle",a);this.layOutTitles(c)};e.prototype.setCaption=function(a,c){this.applyDescription("caption",a);this.layOutTitles(c)};e.prototype.showResetZoom=function(){function a(){c.zoomOut()}var c=this,d=E.lang,b=c.options.chart.resetZoomButton,e=b.theme,
h=e.states,g="chart"===b.relativeTo||"spacingBox"===b.relativeTo?null:"scrollablePlotBox";M(this,"beforeShowResetZoom",null,function(){c.resetZoomButton=c.renderer.button(d.resetZoom,null,null,a,e,h&&h.hover).attr({align:b.position.align,title:d.resetZoomTitle}).addClass("highcharts-reset-zoom").add().align(b.position,!1,g)});M(this,"afterShowResetZoom")};e.prototype.zoomOut=function(){M(this,"selection",{resetSelection:!0},this.zoom)};e.prototype.zoom=function(a){var c=this,d,b=c.pointer,e=!1,h=
c.inverted?b.mouseDownX:b.mouseDownY;!a||a.resetSelection?(c.axes.forEach(function(a){d=a.zoom()}),b.initiated=!1):a.xAxis.concat(a.yAxis).forEach(function(a){var g=a.axis,f=c.inverted?g.left:g.top,m=c.inverted?f+g.width:f+g.height,k=g.isXAxis,l=!1;if(!k&&h>=f&&h<=m||k||!y(h))l=!0;b[k?"zoomX":"zoomY"]&&l&&(d=g.zoom(a.min,a.max),g.displayBtn&&(e=!0))});var g=c.resetZoomButton;e&&!g?c.showResetZoom():!e&&ea(g)&&(c.resetZoomButton=g.destroy());d&&c.redraw(T(c.options.chart.animation,a&&a.animation,100>
c.pointCount))};e.prototype.pan=function(a,c){var d=this,b=d.hoverPoints,e=d.options.chart,h=d.options.mapNavigation&&d.options.mapNavigation.enabled,g;c="object"===typeof c?c:{enabled:c,type:"x"};e&&e.panning&&(e.panning=c);var f=c.type;M(this,"pan",{originalEvent:a},function(){b&&b.forEach(function(a){a.setState()});var c=[1];"xy"===f?c=[1,0]:"y"===f&&(c=[0]);c.forEach(function(c){var b=d[c?"xAxis":"yAxis"][0],e=b.horiz,m=a[e?"chartX":"chartY"];e=e?"mouseDownX":"mouseDownY";var k=d[e],l=(b.pointRange||
0)/2,F=b.reversed&&!d.inverted||!b.reversed&&d.inverted?-1:1,n=b.getExtremes(),r=b.toValue(k-m,!0)+l*F;F=b.toValue(k+b.len-m,!0)-l*F;var K=F<r;k=K?F:r;r=K?r:F;F=b.hasVerticalPanning();var q=b.panningState;!F||c||q&&!q.isDirty||b.series.forEach(function(a){var c=a.getProcessedData(!0);c=a.getExtremes(c.yData,!0);q||(q={startMin:Number.MAX_VALUE,startMax:-Number.MAX_VALUE});Z(c.dataMin)&&Z(c.dataMax)&&(q.startMin=Math.min(T(a.options.threshold,Infinity),c.dataMin,q.startMin),q.startMax=Math.max(T(a.options.threshold,
-Infinity),c.dataMax,q.startMax))});c=Math.min(T(q&&q.startMin,n.dataMin),l?n.min:b.toValue(b.toPixels(n.min)-b.minPixelPadding));l=Math.max(T(q&&q.startMax,n.dataMax),l?n.max:b.toValue(b.toPixels(n.max)+b.minPixelPadding));b.panningState=q;b.isOrdinal||(F=c-k,0<F&&(r+=F,k=c),F=r-l,0<F&&(r=l,k-=F),b.series.length&&k!==n.min&&r!==n.max&&k>=c&&r<=l&&(b.setExtremes(k,r,!1,!1,{trigger:"pan"}),d.resetZoomButton||h||k===c||r===l||!f.match("y")||(d.showResetZoom(),b.displayBtn=!1),g=!0),d[e]=m)});g&&d.redraw(!1);
A(d.container,{cursor:"move"})})};return e}();V(aa.prototype,{callbacks:[],collectionsWithInit:{xAxis:[aa.prototype.addAxis,[!0]],yAxis:[aa.prototype.addAxis,[!1]],series:[aa.prototype.addSeries]},collectionsWithUpdate:["xAxis","yAxis","zAxis","series"],propsRequireDirtyBox:"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),propsRequireReflow:"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
propsRequireUpdateSeries:"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")});z.chart=function(a,c,d){return new aa(a,c,d)};z.Chart=aa;"";return aa});O(e,"Mixins/LegendSymbol.js",[e["Core/Globals.js"],e["Core/Utilities.js"]],function(e,b){var D=b.merge,z=b.pick;return e.LegendSymbolMixin={drawRectangle:function(b,e){var D=b.symbolHeight,B=b.options.squareSymbol;e.legendSymbol=this.chart.renderer.rect(B?(b.symbolWidth-D)/2:0,b.baseline-D+1,B?
D:b.symbolWidth,D,z(b.options.symbolRadius,D/2)).addClass("highcharts-point").attr({zIndex:3}).add(e.legendGroup)},drawLineMarker:function(b){var e=this.options,C=e.marker,B=b.symbolWidth,x=b.symbolHeight,w=x/2,v=this.chart.renderer,f=this.legendGroup;b=b.baseline-Math.round(.3*b.fontMetrics.b);var d={};this.chart.styledMode||(d={"stroke-width":e.lineWidth||0},e.dashStyle&&(d.dashstyle=e.dashStyle));this.legendLine=v.path([["M",0,b],["L",B,b]]).addClass("highcharts-graph").attr(d).add(f);C&&!1!==
C.enabled&&B&&(e=Math.min(z(C.radius,w),w),0===this.symbol.indexOf("url")&&(C=D(C,{width:x,height:x}),e=0),this.legendSymbol=C=v.symbol(this.symbol,B/2-e,b-e,2*e,2*e,C).addClass("highcharts-point").add(f),C.isMarker=!0)}}});O(e,"Core/Series/Series.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Globals.js"],e["Mixins/LegendSymbol.js"],e["Core/Options.js"],e["Core/Color/Palette.js"],e["Core/Series/Point.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Renderer/SVG/SVGElement.js"],e["Core/Utilities.js"]],
function(e,b,I,z,H,G,C,B,x){var w=e.animObject,v=e.setAnimation,f=b.hasTouch,d=b.svg,q=b.win,k=z.defaultOptions,l=C.seriesTypes,D=x.addEvent,u=x.arrayMax,n=x.arrayMin,J=x.clamp,E=x.cleanRecursively,m=x.correctFloat,c=x.defined,g=x.erase,a=x.error,h=x.extend,r=x.find,A=x.fireEvent,y=x.getNestedProperty,L=x.isArray,P=x.isFunction,R=x.isNumber,V=x.isString,Q=x.merge,M=x.objectEach,t=x.pick,p=x.removeEvent,O=x.splat,Z=x.syncTimeout;e=function(){function b(){this.zones=this.yAxis=this.xAxis=this.userOptions=
this.tooltipOptions=this.processedYData=this.processedXData=this.points=this.options=this.linkedSeries=this.index=this.eventsToUnbind=this.eventOptions=this.data=this.chart=this._i=void 0}b.prototype.init=function(a,c){A(this,"init",{options:c});var d=this,b=a.series,e;this.eventOptions=this.eventOptions||{};this.eventsToUnbind=[];d.chart=a;d.options=d.setOptions(c);var g=d.options;d.linkedSeries=[];d.bindAxes();h(d,{name:g.name,state:"",visible:!1!==g.visible,selected:!0===g.selected});c=g.events;
M(c,function(a,c){P(a)&&d.eventOptions[c]!==a&&(P(d.eventOptions[c])&&p(d,c,d.eventOptions[c]),d.eventOptions[c]=a,D(d,c,a))});if(c&&c.click||g.point&&g.point.events&&g.point.events.click||g.allowPointSelect)a.runTrackerClick=!0;d.getColor();d.getSymbol();d.parallelArrays.forEach(function(a){d[a+"Data"]||(d[a+"Data"]=[])});d.isCartesian&&(a.hasCartesianSeries=!0);b.length&&(e=b[b.length-1]);d._i=t(e&&e._i,-1)+1;d.opacity=d.options.opacity;a.orderSeries(this.insert(b));g.dataSorting&&g.dataSorting.enabled?
d.setDataSortingOptions():d.points||d.data||d.setData(g.data,!1);A(this,"afterInit")};b.prototype.is=function(a){return l[a]&&this instanceof l[a]};b.prototype.insert=function(a){var c=this.options.index,d;if(R(c)){for(d=a.length;d--;)if(c>=t(a[d].options.index,a[d]._i)){a.splice(d+1,0,this);break}-1===d&&a.unshift(this);d+=1}else a.push(this);return t(d,a.length-1)};b.prototype.bindAxes=function(){var c=this,d=c.options,b=c.chart,e;A(this,"bindAxes",null,function(){(c.axisTypes||[]).forEach(function(h){var g=
0;b[h].forEach(function(a){e=a.options;if(d[h]===g&&!e.isInternal||"undefined"!==typeof d[h]&&d[h]===e.id||"undefined"===typeof d[h]&&0===e.index)c.insert(a.series),c[h]=a,a.isDirty=!0;e.isInternal||g++});c[h]||c.optionalAxis===h||a(18,!0,b)})});A(this,"afterBindAxes")};b.prototype.updateParallelArrays=function(a,c){var d=a.series,b=arguments,e=R(c)?function(b){var e="y"===b&&d.toYData?d.toYData(a):a[b];d[b+"Data"][c]=e}:function(a){Array.prototype[c].apply(d[a+"Data"],Array.prototype.slice.call(b,
2))};d.parallelArrays.forEach(e)};b.prototype.hasData=function(){return this.visible&&"undefined"!==typeof this.dataMax&&"undefined"!==typeof this.dataMin||this.visible&&this.yData&&0<this.yData.length};b.prototype.autoIncrement=function(){var a=this.options,c=this.xIncrement,d,b=a.pointIntervalUnit,e=this.chart.time;c=t(c,a.pointStart,0);this.pointInterval=d=t(this.pointInterval,a.pointInterval,1);b&&(a=new e.Date(c),"day"===b?e.set("Date",a,e.get("Date",a)+d):"month"===b?e.set("Month",a,e.get("Month",
a)+d):"year"===b&&e.set("FullYear",a,e.get("FullYear",a)+d),d=a.getTime()-c);this.xIncrement=c+d;return c};b.prototype.setDataSortingOptions=function(){var a=this.options;h(this,{requireSorting:!1,sorted:!1,enabledDataSorting:!0,allowDG:!1});c(a.pointRange)||(a.pointRange=1)};b.prototype.setOptions=function(a){var d=this.chart,b=d.options,e=b.plotOptions,h=d.userOptions||{};a=Q(a);d=d.styledMode;var g={plotOptions:e,userOptions:a};A(this,"setOptions",g);var f=g.plotOptions[this.type],m=h.plotOptions||
{};this.userOptions=g.userOptions;h=Q(f,e.series,h.plotOptions&&h.plotOptions[this.type],a);this.tooltipOptions=Q(k.tooltip,k.plotOptions.series&&k.plotOptions.series.tooltip,k.plotOptions[this.type].tooltip,b.tooltip.userOptions,e.series&&e.series.tooltip,e[this.type].tooltip,a.tooltip);this.stickyTracking=t(a.stickyTracking,m[this.type]&&m[this.type].stickyTracking,m.series&&m.series.stickyTracking,this.tooltipOptions.shared&&!this.noSharedTooltip?!0:h.stickyTracking);null===f.marker&&delete h.marker;
this.zoneAxis=h.zoneAxis;b=this.zones=(h.zones||[]).slice();!h.negativeColor&&!h.negativeFillColor||h.zones||(e={value:h[this.zoneAxis+"Threshold"]||h.threshold||0,className:"highcharts-negative"},d||(e.color=h.negativeColor,e.fillColor=h.negativeFillColor),b.push(e));b.length&&c(b[b.length-1].value)&&b.push(d?{}:{color:this.color,fillColor:this.fillColor});A(this,"afterSetOptions",{options:h});return h};b.prototype.getName=function(){return t(this.options.name,"Series "+(this.index+1))};b.prototype.getCyclic=
function(a,d,b){var e=this.chart,h=this.userOptions,g=a+"Index",f=a+"Counter",m=b?b.length:t(e.options.chart[a+"Count"],e[a+"Count"]);if(!d){var k=t(h[g],h["_"+g]);c(k)||(e.series.length||(e[f]=0),h["_"+g]=k=e[f]%m,e[f]+=1);b&&(d=b[k])}"undefined"!==typeof k&&(this[g]=k);this[a]=d};b.prototype.getColor=function(){this.chart.styledMode?this.getCyclic("color"):this.options.colorByPoint?this.color=H.neutralColor20:this.getCyclic("color",this.options.color||k.plotOptions[this.type].color,this.chart.options.colors)};
b.prototype.getPointsCollection=function(){return(this.hasGroupedData?this.points:this.data)||[]};b.prototype.getSymbol=function(){this.getCyclic("symbol",this.options.marker.symbol,this.chart.options.symbols)};b.prototype.findPointIndex=function(a,c){var d=a.id,b=a.x,e=this.points,h,g=this.options.dataSorting;if(d)var f=this.chart.get(d);else if(this.linkedParent||this.enabledDataSorting){var m=g&&g.matchByName?"name":"index";f=r(e,function(c){return!c.touched&&c[m]===a[m]});if(!f)return}if(f){var k=
f&&f.index;"undefined"!==typeof k&&(h=!0)}"undefined"===typeof k&&R(b)&&(k=this.xData.indexOf(b,c));-1!==k&&"undefined"!==typeof k&&this.cropped&&(k=k>=this.cropStart?k-this.cropStart:k);!h&&e[k]&&e[k].touched&&(k=void 0);return k};b.prototype.updateData=function(a,d){var b=this.options,e=b.dataSorting,h=this.points,g=[],f,k,m,l=this.requireSorting,n=a.length===h.length,r=!0;this.xIncrement=null;a.forEach(function(a,d){var k=c(a)&&this.pointClass.prototype.optionsToObject.call({series:this},a)||{};
var r=k.x;if(k.id||R(r)){if(r=this.findPointIndex(k,m),-1===r||"undefined"===typeof r?g.push(a):h[r]&&a!==b.data[r]?(h[r].update(a,!1,null,!1),h[r].touched=!0,l&&(m=r+1)):h[r]&&(h[r].touched=!0),!n||d!==r||e&&e.enabled||this.hasDerivedData)f=!0}else g.push(a)},this);if(f)for(a=h.length;a--;)(k=h[a])&&!k.touched&&k.remove&&k.remove(!1,d);else!n||e&&e.enabled?r=!1:(a.forEach(function(a,c){h[c].update&&a!==h[c].y&&h[c].update(a,!1,null,!1)}),g.length=0);h.forEach(function(a){a&&(a.touched=!1)});if(!r)return!1;
g.forEach(function(a){this.addPoint(a,!1,null,null,!1)},this);null===this.xIncrement&&this.xData&&this.xData.length&&(this.xIncrement=u(this.xData),this.autoIncrement());return!0};b.prototype.setData=function(c,d,b,e){var h=this,g=h.points,f=g&&g.length||0,k,m=h.options,l=h.chart,r=m.dataSorting,n=null,q=h.xAxis;n=m.turboThreshold;var F=this.xData,p=this.yData,u=(k=h.pointArrayMap)&&k.length,v=m.keys,K=0,w=1,y;c=c||[];k=c.length;d=t(d,!0);r&&r.enabled&&(c=this.sortData(c));!1!==e&&k&&f&&!h.cropped&&
!h.hasGroupedData&&h.visible&&!h.isSeriesBoosting&&(y=this.updateData(c,b));if(!y){h.xIncrement=null;h.colorCounter=0;this.parallelArrays.forEach(function(a){h[a+"Data"].length=0});if(n&&k>n)if(n=h.getFirstValidPoint(c),R(n))for(b=0;b<k;b++)F[b]=this.autoIncrement(),p[b]=c[b];else if(L(n))if(u)for(b=0;b<k;b++)e=c[b],F[b]=e[0],p[b]=e.slice(1,u+1);else for(v&&(K=v.indexOf("x"),w=v.indexOf("y"),K=0<=K?K:0,w=0<=w?w:1),b=0;b<k;b++)e=c[b],F[b]=e[K],p[b]=e[w];else a(12,!1,l);else for(b=0;b<k;b++)"undefined"!==
typeof c[b]&&(e={series:h},h.pointClass.prototype.applyOptions.apply(e,[c[b]]),h.updateParallelArrays(e,b));p&&V(p[0])&&a(14,!0,l);h.data=[];h.options.data=h.userOptions.data=c;for(b=f;b--;)g[b]&&g[b].destroy&&g[b].destroy();q&&(q.minRange=q.userMinRange);h.isDirty=l.isDirtyBox=!0;h.isDirtyData=!!g;b=!1}"point"===m.legendType&&(this.processData(),this.generatePoints());d&&l.redraw(b)};b.prototype.sortData=function(a){var d=this,b=d.options.dataSorting.sortKey||"y",e=function(a,d){return c(d)&&a.pointClass.prototype.optionsToObject.call({series:a},
d)||{}};a.forEach(function(c,b){a[b]=e(d,c);a[b].index=b},this);a.concat().sort(function(a,c){a=y(b,a);c=y(b,c);return c<a?-1:c>a?1:0}).forEach(function(a,c){a.x=c},this);d.linkedSeries&&d.linkedSeries.forEach(function(c){var d=c.options,b=d.data;d.dataSorting&&d.dataSorting.enabled||!b||(b.forEach(function(d,h){b[h]=e(c,d);a[h]&&(b[h].x=a[h].x,b[h].index=h)}),c.setData(b,!1))});return a};b.prototype.getProcessedData=function(c){var d=this.xData,b=this.yData,e=d.length;var h=0;var g=this.xAxis,f=
this.options;var k=f.cropThreshold;var m=c||this.getExtremesFromAll||f.getExtremesFromAll,l=this.isCartesian;c=g&&g.val2lin;f=!(!g||!g.logarithmic);var n=this.requireSorting;if(g){g=g.getExtremes();var r=g.min;var q=g.max}if(l&&this.sorted&&!m&&(!k||e>k||this.forceCrop))if(d[e-1]<r||d[0]>q)d=[],b=[];else if(this.yData&&(d[0]<r||d[e-1]>q)){h=this.cropData(this.xData,this.yData,r,q);d=h.xData;b=h.yData;h=h.start;var F=!0}for(k=d.length||1;--k;)if(e=f?c(d[k])-c(d[k-1]):d[k]-d[k-1],0<e&&("undefined"===
typeof p||e<p))var p=e;else 0>e&&n&&(a(15,!1,this.chart),n=!1);return{xData:d,yData:b,cropped:F,cropStart:h,closestPointRange:p}};b.prototype.processData=function(a){var c=this.xAxis;if(this.isCartesian&&!this.isDirty&&!c.isDirty&&!this.yAxis.isDirty&&!a)return!1;a=this.getProcessedData();this.cropped=a.cropped;this.cropStart=a.cropStart;this.processedXData=a.xData;this.processedYData=a.yData;this.closestPointRange=this.basePointRange=a.closestPointRange};b.prototype.cropData=function(a,c,d,b,e){var h=
a.length,g=0,f=h,k;e=t(e,this.cropShoulder);for(k=0;k<h;k++)if(a[k]>=d){g=Math.max(0,k-e);break}for(d=k;d<h;d++)if(a[d]>b){f=d+e;break}return{xData:a.slice(g,f),yData:c.slice(g,f),start:g,end:f}};b.prototype.generatePoints=function(){var a=this.options,c=a.data,d=this.data,b,e=this.processedXData,g=this.processedYData,f=this.pointClass,k=e.length,m=this.cropStart||0,l=this.hasGroupedData,n=a.keys,r=[],q;a=a.dataGrouping&&a.dataGrouping.groupAll?m:0;d||l||(d=[],d.length=c.length,d=this.data=d);n&&
l&&(this.options.keys=!1);for(q=0;q<k;q++){var p=m+q;if(l){var u=(new f).init(this,[e[q]].concat(O(g[q])));u.dataGroup=this.groupMap[a+q];u.dataGroup.options&&(u.options=u.dataGroup.options,h(u,u.dataGroup.options),delete u.dataLabels)}else(u=d[p])||"undefined"===typeof c[p]||(d[p]=u=(new f).init(this,c[p],e[q]));u&&(u.index=l?a+q:p,r[q]=u)}this.options.keys=n;if(d&&(k!==(b=d.length)||l))for(q=0;q<b;q++)q!==m||l||(q+=k),d[q]&&(d[q].destroyElements(),d[q].plotX=void 0);this.data=d;this.points=r;A(this,
"afterGeneratePoints")};b.prototype.getXExtremes=function(a){return{min:n(a),max:u(a)}};b.prototype.getExtremes=function(a,c){var d=this.xAxis,b=this.yAxis,e=this.processedXData||this.xData,h=[],g=0,f=0;var k=0;var m=this.requireSorting?this.cropShoulder:0,l=b?b.positiveValuesOnly:!1,r;a=a||this.stackedYData||this.processedYData||[];b=a.length;d&&(k=d.getExtremes(),f=k.min,k=k.max);for(r=0;r<b;r++){var q=e[r];var p=a[r];var F=(R(p)||L(p))&&(p.length||0<p||!l);q=c||this.getExtremesFromAll||this.options.getExtremesFromAll||
this.cropped||!d||(e[r+m]||q)>=f&&(e[r-m]||q)<=k;if(F&&q)if(F=p.length)for(;F--;)R(p[F])&&(h[g++]=p[F]);else h[g++]=p}a={dataMin:n(h),dataMax:u(h)};A(this,"afterGetExtremes",{dataExtremes:a});return a};b.prototype.applyExtremes=function(){var a=this.getExtremes();this.dataMin=a.dataMin;this.dataMax=a.dataMax;return a};b.prototype.getFirstValidPoint=function(a){for(var c=null,d=a.length,b=0;null===c&&b<d;)c=a[b],b++;return c};b.prototype.translate=function(){this.processedXData||this.processData();
this.generatePoints();var a=this.options,d=a.stacking,b=this.xAxis,e=b.categories,h=this.enabledDataSorting,g=this.yAxis,f=this.points,k=f.length,l=!!this.modifyValue,r,n=this.pointPlacementToXValue(),q=!!n,p=a.threshold,u=a.startFromThreshold?p:0,v,w=this.zoneAxis||"y",y=Number.MAX_VALUE;for(r=0;r<k;r++){var E=f[r],x=E.x,D=E.y,B=E.low,P=d&&g.stacking&&g.stacking.stacks[(this.negStacks&&D<(u?0:p)?"-":"")+this.stackKey],N=void 0,C=void 0;if(g.positiveValuesOnly&&!g.validatePositiveValue(D)||b.positiveValuesOnly&&
!b.validatePositiveValue(x))E.isNull=!0;E.plotX=v=m(J(b.translate(x,0,0,0,1,n,"flags"===this.type),-1E5,1E5));if(d&&this.visible&&P&&P[x]){var z=this.getStackIndicator(z,x,this.index);E.isNull||(N=P[x],C=N.points[z.key])}L(C)&&(B=C[0],D=C[1],B===u&&z.key===P[x].base&&(B=t(R(p)&&p,g.min)),g.positiveValuesOnly&&0>=B&&(B=null),E.total=E.stackTotal=N.total,E.percentage=N.total&&E.y/N.total*100,E.stackY=D,this.irregularWidths||N.setOffset(this.pointXOffset||0,this.barW||0));E.yBottom=c(B)?J(g.translate(B,
0,1,0,1),-1E5,1E5):null;l&&(D=this.modifyValue(D,E));E.plotY=void 0;R(D)&&(D=g.translate(D,!1,!0,!1,!0),"undefined"!==typeof D&&(E.plotY=J(D,-1E5,1E5)));E.isInside=this.isPointInside(E);E.clientX=q?m(b.translate(x,0,0,0,1,n)):v;E.negative=E[w]<(a[w+"Threshold"]||p||0);E.category=e&&"undefined"!==typeof e[E.x]?e[E.x]:E.x;if(!E.isNull&&!1!==E.visible){"undefined"!==typeof M&&(y=Math.min(y,Math.abs(v-M)));var M=v}E.zone=this.zones.length&&E.getZone();!E.graphic&&this.group&&h&&(E.isNew=!0)}this.closestPointRangePx=
y;A(this,"afterTranslate")};b.prototype.getValidPoints=function(a,c,d){var b=this.chart;return(a||this.points||[]).filter(function(a){return c&&!b.isInsidePlot(a.plotX,a.plotY,{inverted:b.inverted})?!1:!1!==a.visible&&(d||!a.isNull)})};b.prototype.getClipBox=function(a,c){var d=this.options,b=this.chart,e=b.inverted,h=this.xAxis,g=h&&this.yAxis,f=b.options.chart.scrollablePlotArea||{};a&&!1===d.clip&&g?a=e?{y:-b.chartWidth+g.len+g.pos,height:b.chartWidth,width:b.chartHeight,x:-b.chartHeight+h.len+
h.pos}:{y:-g.pos,height:b.chartHeight,width:b.chartWidth,x:-h.pos}:(a=this.clipBox||b.clipBox,c&&(a.width=b.plotSizeX,a.x=(b.scrollablePixelsX||0)*(f.scrollPositionX||0)));return c?{width:a.width,x:a.x}:a};b.prototype.getSharedClipKey=function(a){if(this.sharedClipKey)return this.sharedClipKey;var c=[a&&a.duration,a&&a.easing,a&&a.defer,this.getClipBox(a).height,this.options.xAxis,this.options.yAxis].join();if(!1!==this.options.clip||a)this.sharedClipKey=c;return c};b.prototype.setClip=function(a){var c=
this.chart,d=this.options,b=c.renderer,e=c.inverted,h=this.clipBox,g=this.getClipBox(a),f=this.getSharedClipKey(a),k=c.sharedClips[f],m=c.sharedClips[f+"m"];a&&(g.width=0,e&&(g.x=c.plotHeight+(!1!==d.clip?0:c.plotTop)));k?c.hasLoaded||k.attr(g):(a&&(c.sharedClips[f+"m"]=m=b.clipRect(e?(c.plotSizeX||0)+99:-99,e?-c.plotLeft:-c.plotTop,99,e?c.chartWidth:c.chartHeight)),c.sharedClips[f]=k=b.clipRect(g),k.count={length:0});a&&!k.count[this.index]&&(k.count[this.index]=!0,k.count.length+=1);if(!1!==d.clip||
a)this.group.clip(a||h?k:c.clipRect),this.markerGroup.clip(m);a||(k.count[this.index]&&(delete k.count[this.index],--k.count.length),0===k.count.length&&(h||(c.sharedClips[f]=k.destroy()),m&&(c.sharedClips[f+"m"]=m.destroy())))};b.prototype.animate=function(a){var c=this.chart,d=w(this.options.animation),b=this.sharedClipKey;if(a)this.setClip(d);else if(b){a=c.sharedClips[b];b=c.sharedClips[b+"m"];var e=this.getClipBox(d,!0);a&&a.animate(e,d);b&&b.animate({width:e.width+99,x:e.x-(c.inverted?0:99)},
d)}};b.prototype.afterAnimate=function(){this.setClip();A(this,"afterAnimate");this.finishedAnimating=!0};b.prototype.drawPoints=function(){var a=this.points,c=this.chart,d,b,e=this.options.marker,h=this[this.specialGroup]||this.markerGroup,g=this.xAxis,f=t(e.enabled,!g||g.isRadial?!0:null,this.closestPointRangePx>=e.enabledThreshold*e.radius);if(!1!==e.enabled||this._hasPointMarkers)for(d=0;d<a.length;d++){var k=a[d];var m=(b=k.graphic)?"animate":"attr";var l=k.marker||{};var r=!!k.marker;if((f&&
"undefined"===typeof l.enabled||l.enabled)&&!k.isNull&&!1!==k.visible){var n=t(l.symbol,this.symbol);var q=this.markerAttribs(k,k.selected&&"select");this.enabledDataSorting&&(k.startXPos=g.reversed?-(q.width||0):g.width);var p=!1!==k.isInside;b?b[p?"show":"hide"](p).animate(q):p&&(0<(q.width||0)||k.hasImage)&&(k.graphic=b=c.renderer.symbol(n,q.x,q.y,q.width,q.height,r?l:e).add(h),this.enabledDataSorting&&c.hasRendered&&(b.attr({x:k.startXPos}),m="animate"));b&&"animate"===m&&b[p?"show":"hide"](p).animate(q);
if(b&&!c.styledMode)b[m](this.pointAttribs(k,k.selected&&"select"));b&&b.addClass(k.getClassName(),!0)}else b&&(k.graphic=b.destroy())}};b.prototype.markerAttribs=function(a,c){var d=this.options,b=d.marker,e=a.marker||{},h=e.symbol||b.symbol,g=t(e.radius,b.radius);c&&(b=b.states[c],c=e.states&&e.states[c],g=t(c&&c.radius,b&&b.radius,g+(b&&b.radiusPlus||0)));a.hasImage=h&&0===h.indexOf("url");a.hasImage&&(g=0);a={x:d.crisp?Math.floor(a.plotX-g):a.plotX-g,y:a.plotY-g};g&&(a.width=a.height=2*g);return a};
b.prototype.pointAttribs=function(a,c){var d=this.options.marker,b=a&&a.options,e=b&&b.marker||{},h=this.color,g=b&&b.color,f=a&&a.color;b=t(e.lineWidth,d.lineWidth);var k=a&&a.zone&&a.zone.color;a=1;h=g||k||f||h;g=e.fillColor||d.fillColor||h;h=e.lineColor||d.lineColor||h;c=c||"normal";d=d.states[c];c=e.states&&e.states[c]||{};b=t(c.lineWidth,d.lineWidth,b+t(c.lineWidthPlus,d.lineWidthPlus,0));g=c.fillColor||d.fillColor||g;h=c.lineColor||d.lineColor||h;a=t(c.opacity,d.opacity,a);return{stroke:h,"stroke-width":b,
fill:g,opacity:a}};b.prototype.destroy=function(a){var c=this,d=c.chart,b=/AppleWebKit\/533/.test(q.navigator.userAgent),e,h,f=c.data||[],k,m;A(c,"destroy");this.removeEvents(a);(c.axisTypes||[]).forEach(function(a){(m=c[a])&&m.series&&(g(m.series,c),m.isDirty=m.forceRedraw=!0)});c.legendItem&&c.chart.legend.destroyItem(c);for(h=f.length;h--;)(k=f[h])&&k.destroy&&k.destroy();c.clips&&c.clips.forEach(function(a){return a.destroy()});x.clearTimeout(c.animationTimeout);M(c,function(a,c){a instanceof
B&&!a.survive&&(e=b&&"group"===c?"hide":"destroy",a[e]())});d.hoverSeries===c&&(d.hoverSeries=void 0);g(d.series,c);d.orderSeries();M(c,function(d,b){a&&"hcEvents"===b||delete c[b]})};b.prototype.applyZones=function(){var a=this,c=this.chart,d=c.renderer,b=this.zones,e,h,g=this.clips||[],f,k=this.graph,m=this.area,l=Math.max(c.chartWidth,c.chartHeight),r=this[(this.zoneAxis||"y")+"Axis"],n=c.inverted,q,p,u,v=!1,w,y;if(b.length&&(k||m)&&r&&"undefined"!==typeof r.min){var E=r.reversed;var A=r.horiz;
k&&!this.showLine&&k.hide();m&&m.hide();var x=r.getExtremes();b.forEach(function(b,F){e=E?A?c.plotWidth:0:A?0:r.toPixels(x.min)||0;e=J(t(h,e),0,l);h=J(Math.round(r.toPixels(t(b.value,x.max),!0)||0),0,l);v&&(e=h=r.toPixels(x.max));q=Math.abs(e-h);p=Math.min(e,h);u=Math.max(e,h);r.isXAxis?(f={x:n?u:p,y:0,width:q,height:l},A||(f.x=c.plotHeight-f.x)):(f={x:0,y:n?u:p,width:l,height:q},A&&(f.y=c.plotWidth-f.y));n&&d.isVML&&(f=r.isXAxis?{x:0,y:E?p:u,height:f.width,width:c.chartWidth}:{x:f.y-c.plotLeft-c.spacingBox.x,
y:0,width:f.height,height:c.chartHeight});g[F]?g[F].animate(f):g[F]=d.clipRect(f);w=a["zone-area-"+F];y=a["zone-graph-"+F];k&&y&&y.clip(g[F]);m&&w&&w.clip(g[F]);v=b.value>x.max;a.resetZones&&0===h&&(h=void 0)});this.clips=g}else a.visible&&(k&&k.show(!0),m&&m.show(!0))};b.prototype.invertGroups=function(a){function c(){["group","markerGroup"].forEach(function(c){d[c]&&(b.renderer.isVML&&d[c].attr({width:d.yAxis.len,height:d.xAxis.len}),d[c].width=d.yAxis.len,d[c].height=d.xAxis.len,d[c].invert(d.isRadialSeries?
!1:a))})}var d=this,b=d.chart;d.xAxis&&(d.eventsToUnbind.push(D(b,"resize",c)),c(),d.invertGroups=c)};b.prototype.plotGroup=function(a,d,b,e,h){var g=this[a],f=!g;b={visibility:b,zIndex:e||.1};"undefined"===typeof this.opacity||this.chart.styledMode||"inactive"===this.state||(b.opacity=this.opacity);f&&(this[a]=g=this.chart.renderer.g().add(h));g.addClass("highcharts-"+d+" highcharts-series-"+this.index+" highcharts-"+this.type+"-series "+(c(this.colorIndex)?"highcharts-color-"+this.colorIndex+" ":
"")+(this.options.className||"")+(g.hasClass("highcharts-tracker")?" highcharts-tracker":""),!0);g.attr(b)[f?"attr":"animate"](this.getPlotBox());return g};b.prototype.getPlotBox=function(){var a=this.chart,c=this.xAxis,d=this.yAxis;a.inverted&&(c=d,d=this.xAxis);return{translateX:c?c.left:a.plotLeft,translateY:d?d.top:a.plotTop,scaleX:1,scaleY:1}};b.prototype.removeEvents=function(a){a||p(this);this.eventsToUnbind.length&&(this.eventsToUnbind.forEach(function(a){a()}),this.eventsToUnbind.length=
0)};b.prototype.render=function(){var a=this,c=a.chart,d=a.options,b=w(d.animation),e=!a.finishedAnimating&&c.renderer.isSVG&&b.duration,h=a.visible?"inherit":"hidden",g=d.zIndex,f=a.hasRendered,k=c.seriesGroup,m=c.inverted;A(this,"render");var l=a.plotGroup("group","series",h,g,k);a.markerGroup=a.plotGroup("markerGroup","markers",h,g,k);e&&a.animate&&a.animate(!0);l.inverted=t(a.invertible,a.isCartesian)?m:!1;a.drawGraph&&(a.drawGraph(),a.applyZones());a.visible&&a.drawPoints();a.drawDataLabels&&
a.drawDataLabels();a.redrawPoints&&a.redrawPoints();a.drawTracker&&!1!==a.options.enableMouseTracking&&a.drawTracker();a.invertGroups(m);!1===d.clip||a.sharedClipKey||f||l.clip(c.clipRect);e&&a.animate&&a.animate();f||(e&&b.defer&&(e+=b.defer),a.animationTimeout=Z(function(){a.afterAnimate()},e||0));a.isDirty=!1;a.hasRendered=!0;A(a,"afterRender")};b.prototype.redraw=function(){var a=this.chart,c=this.isDirty||this.isDirtyData,d=this.group,b=this.xAxis,e=this.yAxis;d&&(a.inverted&&d.attr({width:a.plotWidth,
height:a.plotHeight}),d.animate({translateX:t(b&&b.left,a.plotLeft),translateY:t(e&&e.top,a.plotTop)}));this.translate();this.render();c&&delete this.kdTree};b.prototype.searchPoint=function(a,c){var d=this.xAxis,b=this.yAxis,e=this.chart.inverted;return this.searchKDTree({clientX:e?d.len-a.chartY+d.pos:a.chartX-d.pos,plotY:e?b.len-a.chartX+b.pos:a.chartY-b.pos},c,a)};b.prototype.buildKDTree=function(a){function c(a,b,e){var h;if(h=a&&a.length){var g=d.kdAxisArray[b%e];a.sort(function(a,c){return a[g]-
c[g]});h=Math.floor(h/2);return{point:a[h],left:c(a.slice(0,h),b+1,e),right:c(a.slice(h+1),b+1,e)}}}this.buildingKdTree=!0;var d=this,b=-1<d.options.findNearestPointBy.indexOf("y")?2:1;delete d.kdTree;Z(function(){d.kdTree=c(d.getValidPoints(null,!d.directTouch),b,b);d.buildingKdTree=!1},d.options.kdNow||a&&"touchstart"===a.type?0:1)};b.prototype.searchKDTree=function(a,d,b){function e(a,d,b,m){var l=d.point,r=h.kdAxisArray[b%m],n=l;var q=c(a[g])&&c(l[g])?Math.pow(a[g]-l[g],2):null;var p=c(a[f])&&
c(l[f])?Math.pow(a[f]-l[f],2):null;p=(q||0)+(p||0);l.dist=c(p)?Math.sqrt(p):Number.MAX_VALUE;l.distX=c(q)?Math.sqrt(q):Number.MAX_VALUE;r=a[r]-l[r];p=0>r?"left":"right";q=0>r?"right":"left";d[p]&&(p=e(a,d[p],b+1,m),n=p[k]<n[k]?p:l);d[q]&&Math.sqrt(r*r)<n[k]&&(a=e(a,d[q],b+1,m),n=a[k]<n[k]?a:n);return n}var h=this,g=this.kdAxisArray[0],f=this.kdAxisArray[1],k=d?"distX":"dist";d=-1<h.options.findNearestPointBy.indexOf("y")?2:1;this.kdTree||this.buildingKdTree||this.buildKDTree(b);if(this.kdTree)return e(a,
this.kdTree,d,d)};b.prototype.pointPlacementToXValue=function(){var a=this.options,c=a.pointRange,d=this.xAxis;a=a.pointPlacement;"between"===a&&(a=d.reversed?-.5:.5);return R(a)?a*(c||d.pointRange):0};b.prototype.isPointInside=function(a){return"undefined"!==typeof a.plotY&&"undefined"!==typeof a.plotX&&0<=a.plotY&&a.plotY<=this.yAxis.len&&0<=a.plotX&&a.plotX<=this.xAxis.len};b.prototype.drawTracker=function(){var a=this,c=a.options,b=c.trackByArea,e=[].concat(b?a.areaPath:a.graphPath),h=a.chart,
g=h.pointer,k=h.renderer,m=h.options.tooltip.snap,l=a.tracker,r=function(c){if(h.hoverSeries!==a)a.onMouseOver()},n="rgba(192,192,192,"+(d?.0001:.002)+")";l?l.attr({d:e}):a.graph&&(a.tracker=k.path(e).attr({visibility:a.visible?"visible":"hidden",zIndex:2}).addClass(b?"highcharts-tracker-area":"highcharts-tracker-line").add(a.group),h.styledMode||a.tracker.attr({"stroke-linecap":"round","stroke-linejoin":"round",stroke:n,fill:b?n:"none","stroke-width":a.graph.strokeWidth()+(b?0:2*m)}),[a.tracker,
a.markerGroup,a.dataLabelsGroup].forEach(function(a){if(a&&(a.addClass("highcharts-tracker").on("mouseover",r).on("mouseout",function(a){g.onTrackerMouseOut(a)}),c.cursor&&!h.styledMode&&a.css({cursor:c.cursor}),f))a.on("touchstart",r)}));A(this,"afterDrawTracker")};b.prototype.addPoint=function(a,c,d,b,e){var h=this.options,g=this.data,f=this.chart,k=this.xAxis;k=k&&k.hasNames&&k.names;var m=h.data,l=this.xData,r;c=t(c,!0);var n={series:this};this.pointClass.prototype.applyOptions.apply(n,[a]);var q=
n.x;var p=l.length;if(this.requireSorting&&q<l[p-1])for(r=!0;p&&l[p-1]>q;)p--;this.updateParallelArrays(n,"splice",p,0,0);this.updateParallelArrays(n,p);k&&n.name&&(k[q]=n.name);m.splice(p,0,a);r&&(this.data.splice(p,0,null),this.processData());"point"===h.legendType&&this.generatePoints();d&&(g[0]&&g[0].remove?g[0].remove(!1):(g.shift(),this.updateParallelArrays(n,"shift"),m.shift()));!1!==e&&A(this,"addPoint",{point:n});this.isDirtyData=this.isDirty=!0;c&&f.redraw(b)};b.prototype.removePoint=function(a,
c,d){var b=this,e=b.data,h=e[a],g=b.points,f=b.chart,k=function(){g&&g.length===e.length&&g.splice(a,1);e.splice(a,1);b.options.data.splice(a,1);b.updateParallelArrays(h||{series:b},"splice",a,1);h&&h.destroy();b.isDirty=!0;b.isDirtyData=!0;c&&f.redraw()};v(d,f);c=t(c,!0);h?h.firePointEvent("remove",null,k):k()};b.prototype.remove=function(a,c,d,b){function e(){h.destroy(b);g.isDirtyLegend=g.isDirtyBox=!0;g.linkSeries();t(a,!0)&&g.redraw(c)}var h=this,g=h.chart;!1!==d?A(h,"remove",null,e):e()};b.prototype.update=
function(c,d){c=E(c,this.userOptions);A(this,"update",{options:c});var b=this,e=b.chart,g=b.userOptions,f=b.initialType||b.type,k=e.options.plotOptions,m=c.type||g.type||e.options.chart.type,r=!(this.hasDerivedData||m&&m!==this.type||"undefined"!==typeof c.pointStart||"undefined"!==typeof c.pointInterval||b.hasOptionChanged("dataGrouping")||b.hasOptionChanged("pointStart")||b.hasOptionChanged("pointInterval")||b.hasOptionChanged("pointIntervalUnit")||b.hasOptionChanged("keys")),n=l[f].prototype,q,
p=["eventOptions","navigatorSeries","baseSeries"],u=b.finishedAnimating&&{animation:!1},v={};m=m||f;r&&(p.push("data","isDirtyData","points","processedXData","processedYData","xIncrement","cropped","_hasPointMarkers","_hasPointLabels","clips","nodes","layout","mapMap","mapData","minY","maxY","minX","maxX"),!1!==c.visible&&p.push("area","graph"),b.parallelArrays.forEach(function(a){p.push(a+"Data")}),c.data&&(c.dataSorting&&h(b.options.dataSorting,c.dataSorting),this.setData(c.data,!1)));c=Q(g,u,{index:"undefined"===
typeof g.index?b.index:g.index,pointStart:t(k&&k.series&&k.series.pointStart,g.pointStart,b.xData[0])},!r&&{data:b.options.data},c);r&&c.data&&(c.data=b.options.data);p=["group","markerGroup","dataLabelsGroup","transformGroup"].concat(p);p.forEach(function(a){p[a]=b[a];delete b[a]});g=!1;if(l[m]){if(g=m!==b.type,b.remove(!1,!1,!1,!0),g)if(Object.setPrototypeOf)Object.setPrototypeOf(b,l[m].prototype);else{k=Object.hasOwnProperty.call(b,"hcEvents")&&b.hcEvents;for(q in n)b[q]=void 0;h(b,l[m].prototype);
k?b.hcEvents=k:delete b.hcEvents}}else a(17,!0,e,{missingModuleFor:m});p.forEach(function(a){b[a]=p[a]});b.init(e,c);if(r&&this.points){var w=b.options;!1===w.visible?(v.graphic=1,v.dataLabel=1):b._hasPointLabels||(c=w.marker,m=w.dataLabels,c&&(!1===c.enabled||"symbol"in c)&&(v.graphic=1),m&&!1===m.enabled&&(v.dataLabel=1));this.points.forEach(function(a){a&&a.series&&(a.resolveColor(),Object.keys(v).length&&a.destroyElements(v),!1===w.showInLegend&&a.legendItem&&e.legend.destroyItem(a))},this)}b.initialType=
f;e.linkSeries();g&&b.linkedSeries.length&&(b.isDirtyData=!0);A(this,"afterUpdate");t(d,!0)&&e.redraw(r?void 0:!1)};b.prototype.setName=function(a){this.name=this.options.name=this.userOptions.name=a;this.chart.isDirtyLegend=!0};b.prototype.hasOptionChanged=function(a){var c=this.options[a],d=this.chart.options.plotOptions,b=this.userOptions[a];return b?c!==b:c!==t(d&&d[this.type]&&d[this.type][a],d&&d.series&&d.series[a],c)};b.prototype.onMouseOver=function(){var a=this.chart,c=a.hoverSeries;a.pointer.setHoverChartIndex();
if(c&&c!==this)c.onMouseOut();this.options.events.mouseOver&&A(this,"mouseOver");this.setState("hover");a.hoverSeries=this};b.prototype.onMouseOut=function(){var a=this.options,c=this.chart,d=c.tooltip,b=c.hoverPoint;c.hoverSeries=null;if(b)b.onMouseOut();this&&a.events.mouseOut&&A(this,"mouseOut");!d||this.stickyTracking||d.shared&&!this.noSharedTooltip||d.hide();c.series.forEach(function(a){a.setState("",!0)})};b.prototype.setState=function(a,c){var d=this,b=d.options,e=d.graph,h=b.inactiveOtherPoints,
g=b.states,f=b.lineWidth,k=b.opacity,m=t(g[a||"normal"]&&g[a||"normal"].animation,d.chart.options.chart.animation);b=0;a=a||"";if(d.state!==a&&([d.group,d.markerGroup,d.dataLabelsGroup].forEach(function(c){c&&(d.state&&c.removeClass("highcharts-series-"+d.state),a&&c.addClass("highcharts-series-"+a))}),d.state=a,!d.chart.styledMode)){if(g[a]&&!1===g[a].enabled)return;a&&(f=g[a].lineWidth||f+(g[a].lineWidthPlus||0),k=t(g[a].opacity,k));if(e&&!e.dashstyle)for(g={"stroke-width":f},e.animate(g,m);d["zone-graph-"+
b];)d["zone-graph-"+b].animate(g,m),b+=1;h||[d.group,d.markerGroup,d.dataLabelsGroup,d.labelBySeries].forEach(function(a){a&&a.animate({opacity:k},m)})}c&&h&&d.points&&d.setAllPointsToState(a||void 0)};b.prototype.setAllPointsToState=function(a){this.points.forEach(function(c){c.setState&&c.setState(a)})};b.prototype.setVisible=function(a,c){var d=this,b=d.chart,e=d.legendItem,h=b.options.chart.ignoreHiddenSeries,g=d.visible;var f=(d.visible=a=d.options.visible=d.userOptions.visible="undefined"===
typeof a?!g:a)?"show":"hide";["group","dataLabelsGroup","markerGroup","tracker","tt"].forEach(function(a){if(d[a])d[a][f]()});if(b.hoverSeries===d||(b.hoverPoint&&b.hoverPoint.series)===d)d.onMouseOut();e&&b.legend.colorizeItem(d,a);d.isDirty=!0;d.options.stacking&&b.series.forEach(function(a){a.options.stacking&&a.visible&&(a.isDirty=!0)});d.linkedSeries.forEach(function(c){c.setVisible(a,!1)});h&&(b.isDirtyBox=!0);A(d,f);!1!==c&&b.redraw()};b.prototype.show=function(){this.setVisible(!0)};b.prototype.hide=
function(){this.setVisible(!1)};b.prototype.select=function(a){this.selected=a=this.options.selected="undefined"===typeof a?!this.selected:a;this.checkbox&&(this.checkbox.checked=a);A(this,a?"select":"unselect")};b.prototype.shouldShowTooltip=function(a,c,d){void 0===d&&(d={});d.series=this;d.visiblePlotOnly=!0;return this.chart.isInsidePlot(a,c,d)};b.defaultOptions={lineWidth:2,allowPointSelect:!1,crisp:!0,showCheckbox:!1,animation:{duration:1E3},events:{},marker:{enabledThreshold:2,lineColor:H.backgroundColor,
lineWidth:0,radius:4,states:{normal:{animation:!0},hover:{animation:{duration:50},enabled:!0,radiusPlus:2,lineWidthPlus:1},select:{fillColor:H.neutralColor20,lineColor:H.neutralColor100,lineWidth:2}}},point:{events:{}},dataLabels:{animation:{},align:"center",defer:!0,formatter:function(){var a=this.series.chart.numberFormatter;return"number"!==typeof this.y?"":a(this.y,-1)},padding:5,style:{fontSize:"11px",fontWeight:"bold",color:"contrast",textOutline:"1px contrast"},verticalAlign:"bottom",x:0,y:0},
cropThreshold:300,opacity:1,pointRange:0,softThreshold:!0,states:{normal:{animation:!0},hover:{animation:{duration:50},lineWidthPlus:1,marker:{},halo:{size:10,opacity:.25}},select:{animation:{duration:0}},inactive:{animation:{duration:50},opacity:.2}},stickyTracking:!0,turboThreshold:1E3,findNearestPointBy:"x"};return b}();h(e.prototype,{axisTypes:["xAxis","yAxis"],coll:"series",colorCounter:0,cropShoulder:1,directTouch:!1,drawLegendSymbol:I.drawLineMarker,isCartesian:!0,kdAxisArray:["clientX","plotY"],
parallelArrays:["x","y"],pointClass:G,requireSorting:!0,sorted:!0});C.series=e;"";"";return e});O(e,"Extensions/ScrollablePlotArea.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Axis/Axis.js"],e["Core/Chart/Chart.js"],e["Core/Series/Series.js"],e["Core/Globals.js"],e["Core/Utilities.js"]],function(e,b,I,z,H,G){var D=e.stop,B=G.addEvent,x=G.createElement,w=G.merge,v=G.pick;"";B(I,"afterSetChartSize",function(b){var d=this.options.chart.scrollablePlotArea,e=d&&d.minWidth;d=d&&d.minHeight;if(!this.renderer.forExport){if(e){if(this.scrollablePixelsX=
e=Math.max(0,e-this.chartWidth)){this.scrollablePlotBox=this.renderer.scrollablePlotBox=w(this.plotBox);this.plotBox.width=this.plotWidth+=e;this.inverted?this.clipBox.height+=e:this.clipBox.width+=e;var f={1:{name:"right",value:e}}}}else d&&(this.scrollablePixelsY=e=Math.max(0,d-this.chartHeight))&&(this.scrollablePlotBox=this.renderer.scrollablePlotBox=w(this.plotBox),this.plotBox.height=this.plotHeight+=e,this.inverted?this.clipBox.width+=e:this.clipBox.height+=e,f={2:{name:"bottom",value:e}});
f&&!b.skipAxes&&this.axes.forEach(function(d){f[d.side]?d.getPlotLinePath=function(){var b=f[d.side].name,e=this[b];this[b]=e-f[d.side].value;var k=H.Axis.prototype.getPlotLinePath.apply(this,arguments);this[b]=e;return k}:(d.setAxisSize(),d.setAxisTranslation())})}});B(I,"render",function(){this.scrollablePixelsX||this.scrollablePixelsY?(this.setUpScrolling&&this.setUpScrolling(),this.applyFixed()):this.fixedDiv&&this.applyFixed()});I.prototype.setUpScrolling=function(){var b=this,d={WebkitOverflowScrolling:"touch",
overflowX:"hidden",overflowY:"hidden"};this.scrollablePixelsX&&(d.overflowX="auto");this.scrollablePixelsY&&(d.overflowY="auto");this.scrollingParent=x("div",{className:"highcharts-scrolling-parent"},{position:"relative"},this.renderTo);this.scrollingContainer=x("div",{className:"highcharts-scrolling"},d,this.scrollingParent);B(this.scrollingContainer,"scroll",function(){b.pointer&&delete b.pointer.chartPosition});this.innerContainer=x("div",{className:"highcharts-inner-container"},null,this.scrollingContainer);
this.innerContainer.appendChild(this.container);this.setUpScrolling=null};I.prototype.moveFixedElements=function(){var b=this.container,d=this.fixedRenderer,e=".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),k;this.scrollablePixelsX&&
!this.inverted?k=".highcharts-yaxis":this.scrollablePixelsX&&this.inverted?k=".highcharts-xaxis":this.scrollablePixelsY&&!this.inverted?k=".highcharts-xaxis":this.scrollablePixelsY&&this.inverted&&(k=".highcharts-yaxis");k&&e.push(k+":not(.highcharts-radial-axis)",k+"-labels:not(.highcharts-radial-axis-labels)");e.forEach(function(e){[].forEach.call(b.querySelectorAll(e),function(b){(b.namespaceURI===d.SVG_NS?d.box:d.box.parentNode).appendChild(b);b.style.pointerEvents="auto"})})};I.prototype.applyFixed=
function(){var b=!this.fixedDiv;var d=this.options.chart;var e=d.scrollablePlotArea;b?(this.fixedDiv=x("div",{className:"highcharts-fixed"},{position:"absolute",overflow:"hidden",pointerEvents:"none",zIndex:(d.style&&d.style.zIndex||0)+2,top:0},null,!0),this.scrollingContainer&&this.scrollingContainer.parentNode.insertBefore(this.fixedDiv,this.scrollingContainer),this.renderTo.style.overflow="visible",this.fixedRenderer=d=new H.Renderer(this.fixedDiv,this.chartWidth,this.chartHeight,this.options.chart.style),
this.scrollableMask=d.path().attr({fill:this.options.chart.backgroundColor||"#fff","fill-opacity":v(e.opacity,.85),zIndex:-1}).addClass("highcharts-scrollable-mask").add(),B(this,"afterShowResetZoom",this.moveFixedElements),B(this,"afterDrilldown",this.moveFixedElements),B(this,"afterLayOutTitles",this.moveFixedElements)):this.fixedRenderer.setSize(this.chartWidth,this.chartHeight);if(this.scrollableDirty||b)this.scrollableDirty=!1,this.moveFixedElements();d=this.chartWidth+(this.scrollablePixelsX||
0);var k=this.chartHeight+(this.scrollablePixelsY||0);D(this.container);this.container.style.width=d+"px";this.container.style.height=k+"px";this.renderer.boxWrapper.attr({width:d,height:k,viewBox:[0,0,d,k].join(" ")});this.chartBackground.attr({width:d,height:k});this.scrollingContainer.style.height=this.chartHeight+"px";b&&(e.scrollPositionX&&(this.scrollingContainer.scrollLeft=this.scrollablePixelsX*e.scrollPositionX),e.scrollPositionY&&(this.scrollingContainer.scrollTop=this.scrollablePixelsY*
e.scrollPositionY));k=this.axisOffset;b=this.plotTop-k[0]-1;e=this.plotLeft-k[3]-1;d=this.plotTop+this.plotHeight+k[2]+1;k=this.plotLeft+this.plotWidth+k[1]+1;var l=this.plotLeft+this.plotWidth-(this.scrollablePixelsX||0),w=this.plotTop+this.plotHeight-(this.scrollablePixelsY||0);b=this.scrollablePixelsX?[["M",0,b],["L",this.plotLeft-1,b],["L",this.plotLeft-1,d],["L",0,d],["Z"],["M",l,b],["L",this.chartWidth,b],["L",this.chartWidth,d],["L",l,d],["Z"]]:this.scrollablePixelsY?[["M",e,0],["L",e,this.plotTop-
1],["L",k,this.plotTop-1],["L",k,0],["Z"],["M",e,w],["L",e,this.chartHeight],["L",k,this.chartHeight],["L",k,w],["Z"]]:[["M",0,0]];"adjustHeight"!==this.redrawTrigger&&this.scrollableMask.attr({d:b})};B(b,"afterInit",function(){this.chart.scrollableDirty=!0});B(z,"show",function(){this.chart.scrollableDirty=!0})});O(e,"Core/Axis/StackingAxis.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Utilities.js"]],function(e,b){var D=e.getDeferredAnimation,z=b.addEvent,H=b.destroyObjectProperties,G=
b.fireEvent,C=b.isNumber,B=b.objectEach,x=function(){function b(b){this.oldStacks={};this.stacks={};this.stacksTouched=0;this.axis=b}b.prototype.buildStacks=function(){var b=this.axis,e=b.series,d=b.options.reversedStacks,q=e.length,k;if(!b.isXAxis){this.usePercentage=!1;for(k=q;k--;){var l=e[d?k:q-k-1];l.setStackedPoints();l.setGroupedPoints()}for(k=0;k<q;k++)e[k].modifyStacks();G(b,"afterBuildStacks")}};b.prototype.cleanStacks=function(){if(!this.axis.isXAxis){if(this.oldStacks)var b=this.stacks=
this.oldStacks;B(b,function(b){B(b,function(d){d.cumulative=d.total})})}};b.prototype.resetStacks=function(){var b=this,e=this.stacks;this.axis.isXAxis||B(e,function(d){B(d,function(e,f){C(e.touched)&&e.touched<b.stacksTouched?(e.destroy(),delete d[f]):(e.total=null,e.cumulative=null)})})};b.prototype.renderStackTotals=function(){var b=this.axis,e=b.chart,d=e.renderer,q=this.stacks;b=D(e,b.options.stackLabels&&b.options.stackLabels.animation||!1);var k=this.stackTotalGroup=this.stackTotalGroup||d.g("stack-labels").attr({visibility:"visible",
zIndex:6,opacity:0}).add();k.translate(e.plotLeft,e.plotTop);B(q,function(d){B(d,function(d){d.render(k)})});k.animate({opacity:1},b)};return b}();return function(){function b(){}b.compose=function(e){z(e,"init",b.onInit);z(e,"destroy",b.onDestroy)};b.onDestroy=function(){var b=this.stacking;if(b){var e=b.stacks;B(e,function(d,b){H(d);e[b]=null});b&&b.stackTotalGroup&&b.stackTotalGroup.destroy()}};b.onInit=function(){this.stacking||(this.stacking=new x(this))};return b}()});O(e,"Extensions/Stacking.js",
[e["Core/Axis/Axis.js"],e["Core/Chart/Chart.js"],e["Core/FormatUtilities.js"],e["Core/Globals.js"],e["Core/Series/Series.js"],e["Core/Axis/StackingAxis.js"],e["Core/Utilities.js"]],function(e,b,I,z,H,G,C){var D=I.format,x=C.correctFloat,w=C.defined,v=C.destroyObjectProperties,f=C.isArray,d=C.isNumber,q=C.objectEach,k=C.pick;"";var l=function(){function b(d,b,e,f,k){var c=d.chart.inverted;this.axis=d;this.isNegative=e;this.options=b=b||{};this.x=f;this.total=null;this.points={};this.hasValidPoints=
!1;this.stack=k;this.rightCliff=this.leftCliff=0;this.alignOptions={align:b.align||(c?e?"left":"right":"center"),verticalAlign:b.verticalAlign||(c?"middle":e?"bottom":"top"),y:b.y,x:b.x};this.textAlign=b.textAlign||(c?e?"right":"left":"center")}b.prototype.destroy=function(){v(this,this.axis)};b.prototype.render=function(d){var b=this.axis.chart,e=this.options,f=e.format;f=f?D(f,this,b):e.formatter.call(this);this.label?this.label.attr({text:f,visibility:"hidden"}):(this.label=b.renderer.label(f,
null,null,e.shape,null,null,e.useHTML,!1,"stack-labels"),f={r:e.borderRadius||0,text:f,rotation:e.rotation,padding:k(e.padding,5),visibility:"hidden"},b.styledMode||(f.fill=e.backgroundColor,f.stroke=e.borderColor,f["stroke-width"]=e.borderWidth,this.label.css(e.style)),this.label.attr(f),this.label.added||this.label.add(d));this.label.labelrank=b.plotSizeY};b.prototype.setOffset=function(b,e,f,l,m){var c=this.axis,g=c.chart;l=c.translate(c.stacking.usePercentage?100:l?l:this.total,0,0,0,1);f=c.translate(f?
f:0);f=w(l)&&Math.abs(l-f);b=k(m,g.xAxis[0].translate(this.x))+b;c=w(l)&&this.getStackBox(g,this,b,l,e,f,c);e=this.label;f=this.isNegative;b="justify"===k(this.options.overflow,"justify");var a=this.textAlign;e&&c&&(m=e.getBBox(),l=e.padding,a="left"===a?g.inverted?-l:l:"right"===a?m.width:g.inverted&&"center"===a?m.width/2:g.inverted?f?m.width+l:-l:m.width/2,f=g.inverted?m.height/2:f?-l:m.height,this.alignOptions.x=k(this.options.x,0),this.alignOptions.y=k(this.options.y,0),c.x-=a,c.y-=f,e.align(this.alignOptions,
null,c),g.isInsidePlot(e.alignAttr.x+a-this.alignOptions.x,e.alignAttr.y+f-this.alignOptions.y)?e.show():(e.alignAttr.y=-9999,b=!1),b&&H.prototype.justifyDataLabel.call(this.axis,e,this.alignOptions,e.alignAttr,m,c),e.attr({x:e.alignAttr.x,y:e.alignAttr.y}),k(!b&&this.options.crop,!0)&&((g=d(e.x)&&d(e.y)&&g.isInsidePlot(e.x-l+e.width,e.y)&&g.isInsidePlot(e.x+l,e.y))||e.hide()))};b.prototype.getStackBox=function(d,b,e,f,k,c,g){var a=b.axis.reversed,h=d.inverted,m=g.height+g.pos-(h?d.plotLeft:d.plotTop);
b=b.isNegative&&!a||!b.isNegative&&a;return{x:h?b?f-g.right:f-c+g.pos-d.plotLeft:e+d.xAxis[0].transB-d.plotLeft,y:h?g.height-e-k:b?m-f-c:m-f,width:h?c:k,height:h?k:c}};return b}();b.prototype.getStacks=function(){var d=this,b=d.inverted;d.yAxis.forEach(function(d){d.stacking&&d.stacking.stacks&&d.hasVisibleSeries&&(d.stacking.oldStacks=d.stacking.stacks)});d.series.forEach(function(e){var f=e.xAxis&&e.xAxis.options||{};!e.options.stacking||!0!==e.visible&&!1!==d.options.chart.ignoreHiddenSeries||
(e.stackKey=[e.type,k(e.options.stack,""),b?f.top:f.left,b?f.height:f.width].join())})};G.compose(e);H.prototype.setGroupedPoints=function(){var d=this.yAxis.stacking;this.options.centerInCategory&&(this.is("column")||this.is("columnrange"))&&!this.options.stacking&&1<this.chart.series.length?H.prototype.setStackedPoints.call(this,"group"):d&&q(d.stacks,function(b,e){"group"===e.slice(-5)&&(q(b,function(d){return d.destroy()}),delete d.stacks[e])})};H.prototype.setStackedPoints=function(d){var b=
d||this.options.stacking;if(b&&(!0===this.visible||!1===this.chart.options.chart.ignoreHiddenSeries)){var e=this.processedXData,q=this.processedYData,v=[],m=q.length,c=this.options,g=c.threshold,a=k(c.startFromThreshold&&g,0);c=c.stack;d=d?this.type+","+b:this.stackKey;var h="-"+d,r=this.negStacks,A=this.yAxis,y=A.stacking.stacks,D=A.stacking.oldStacks,B,C;A.stacking.stacksTouched+=1;for(C=0;C<m;C++){var z=e[C];var Q=q[C];var M=this.getStackIndicator(M,z,this.index);var t=M.key;var p=(B=r&&Q<(a?0:
g))?h:d;y[p]||(y[p]={});y[p][z]||(D[p]&&D[p][z]?(y[p][z]=D[p][z],y[p][z].total=null):y[p][z]=new l(A,A.options.stackLabels,B,z,c));p=y[p][z];null!==Q?(p.points[t]=p.points[this.index]=[k(p.cumulative,a)],w(p.cumulative)||(p.base=t),p.touched=A.stacking.stacksTouched,0<M.index&&!1===this.singleStacks&&(p.points[t][0]=p.points[this.index+","+z+",0"][0])):p.points[t]=p.points[this.index]=null;"percent"===b?(B=B?d:h,r&&y[B]&&y[B][z]?(B=y[B][z],p.total=B.total=Math.max(B.total,p.total)+Math.abs(Q)||0):
p.total=x(p.total+(Math.abs(Q)||0))):"group"===b?(f(Q)&&(Q=Q[0]),null!==Q&&(p.total=(p.total||0)+1)):p.total=x(p.total+(Q||0));p.cumulative="group"===b?(p.total||1)-1:k(p.cumulative,a)+(Q||0);null!==Q&&(p.points[t].push(p.cumulative),v[C]=p.cumulative,p.hasValidPoints=!0)}"percent"===b&&(A.stacking.usePercentage=!0);"group"!==b&&(this.stackedYData=v);A.stacking.oldStacks={}}};H.prototype.modifyStacks=function(){var d=this,b=d.stackKey,e=d.yAxis.stacking.stacks,f=d.processedXData,k,m=d.options.stacking;
d[m+"Stacker"]&&[b,"-"+b].forEach(function(c){for(var b=f.length,a,h;b--;)if(a=f[b],k=d.getStackIndicator(k,a,d.index,c),h=(a=e[c]&&e[c][a])&&a.points[k.key])d[m+"Stacker"](h,a,b)})};H.prototype.percentStacker=function(d,b,e){b=b.total?100/b.total:0;d[0]=x(d[0]*b);d[1]=x(d[1]*b);this.stackedYData[e]=d[1]};H.prototype.getStackIndicator=function(d,b,e,f){!w(d)||d.x!==b||f&&d.key!==f?d={x:b,index:0,key:f}:d.index++;d.key=[e,b,d.index].join();return d};z.StackItem=l;return z.StackItem});O(e,"Series/Line/LineSeries.js",
[e["Core/Color/Palette.js"],e["Core/Series/Series.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(e,b,I,z){var D=this&&this.__extends||function(){var b=function(e,w){b=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(b,e){b.__proto__=e}||function(b,e){for(var d in e)e.hasOwnProperty(d)&&(b[d]=e[d])};return b(e,w)};return function(e,w){function v(){this.constructor=e}b(e,w);e.prototype=null===w?Object.create(w):(v.prototype=w.prototype,new v)}}(),G=z.defined,
C=z.merge;z=function(B){function x(){var b=null!==B&&B.apply(this,arguments)||this;b.data=void 0;b.options=void 0;b.points=void 0;return b}D(x,B);x.prototype.drawGraph=function(){var b=this,v=this.options,f=(this.gappedPath||this.getGraphPath).call(this),d=this.chart.styledMode,q=[["graph","highcharts-graph"]];d||q[0].push(v.lineColor||this.color||e.neutralColor20,v.dashStyle);q=b.getZonesGraphs(q);q.forEach(function(e,l){var k=e[0],q=b[k],n=q?"animate":"attr";q?(q.endX=b.preventGraphAnimation?null:
f.xMap,q.animate({d:f})):f.length&&(b[k]=q=b.chart.renderer.path(f).addClass(e[1]).attr({zIndex:1}).add(b.group));q&&!d&&(k={stroke:e[2],"stroke-width":v.lineWidth,fill:b.fillGraph&&b.color||"none"},e[3]?k.dashstyle=e[3]:"square"!==v.linecap&&(k["stroke-linecap"]=k["stroke-linejoin"]="round"),q[n](k).shadow(2>l&&v.shadow));q&&(q.startX=f.xMap,q.isArea=f.isArea)})};x.prototype.getGraphPath=function(b,e,f){var d=this,q=d.options,k=q.step,l,v=[],u=[],n;b=b||d.points;(l=b.reversed)&&b.reverse();(k={right:1,
center:2}[k]||k&&3)&&l&&(k=4-k);b=this.getValidPoints(b,!1,!(q.connectNulls&&!e&&!f));b.forEach(function(l,w){var m=l.plotX,c=l.plotY,g=b[w-1];(l.leftCliff||g&&g.rightCliff)&&!f&&(n=!0);l.isNull&&!G(e)&&0<w?n=!q.connectNulls:l.isNull&&!e?n=!0:(0===w||n?w=[["M",l.plotX,l.plotY]]:d.getPointSpline?w=[d.getPointSpline(b,l,w)]:k?(w=1===k?[["L",g.plotX,c]]:2===k?[["L",(g.plotX+m)/2,g.plotY],["L",(g.plotX+m)/2,c]]:[["L",m,g.plotY]],w.push(["L",m,c])):w=[["L",m,c]],u.push(l.x),k&&(u.push(l.x),2===k&&u.push(l.x)),
v.push.apply(v,w),n=!1)});v.xMap=u;return d.graphPath=v};x.prototype.getZonesGraphs=function(b){this.zones.forEach(function(e,f){f=["zone-graph-"+f,"highcharts-graph highcharts-zone-graph-"+f+" "+(e.className||"")];this.chart.styledMode||f.push(e.color||this.color,e.dashStyle||this.options.dashStyle);b.push(f)},this);return b};x.defaultOptions=C(b.defaultOptions,{});return x}(b);I.registerSeriesType("line",z);"";return z});O(e,"Series/Area/AreaSeries.js",[e["Core/Color/Color.js"],e["Mixins/LegendSymbol.js"],
e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(e,b,I,z){var D=this&&this.__extends||function(){var b=function(e,d){b=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(b,d){b.__proto__=d}||function(b,d){for(var e in d)d.hasOwnProperty(e)&&(b[e]=d[e])};return b(e,d)};return function(e,d){function f(){this.constructor=e}b(e,d);e.prototype=null===d?Object.create(d):(f.prototype=d.prototype,new f)}}(),G=e.parse,C=I.seriesTypes.line;e=z.extend;var B=z.merge,x=z.objectEach,
w=z.pick;z=function(b){function e(){var d=null!==b&&b.apply(this,arguments)||this;d.data=void 0;d.options=void 0;d.points=void 0;return d}D(e,b);e.prototype.drawGraph=function(){this.areaPath=[];b.prototype.drawGraph.apply(this);var d=this,e=this.areaPath,f=this.options,l=[["area","highcharts-area",this.color,f.fillColor]];this.zones.forEach(function(b,e){l.push(["zone-area-"+e,"highcharts-area highcharts-zone-area-"+e+" "+b.className,b.color||d.color,b.fillColor||f.fillColor])});l.forEach(function(b){var k=
b[0],l=d[k],q=l?"animate":"attr",v={};l?(l.endX=d.preventGraphAnimation?null:e.xMap,l.animate({d:e})):(v.zIndex=0,l=d[k]=d.chart.renderer.path(e).addClass(b[1]).add(d.group),l.isArea=!0);d.chart.styledMode||(v.fill=w(b[3],G(b[2]).setOpacity(w(f.fillOpacity,.75)).get()));l[q](v);l.startX=e.xMap;l.shiftUnit=f.step?2:1})};e.prototype.getGraphPath=function(b){var d=C.prototype.getGraphPath,e=this.options,f=e.stacking,v=this.yAxis,u,n=[],x=[],E=this.index,m=v.stacking.stacks[this.stackKey],c=e.threshold,
g=Math.round(v.getThreshold(e.threshold));e=w(e.connectNulls,"percent"===f);var a=function(a,d,e){var h=b[a];a=f&&m[h.x].points[E];var k=h[e+"Null"]||0;e=h[e+"Cliff"]||0;h=!0;if(e||k){var l=(k?a[0]:a[1])+e;var q=a[0]+e;h=!!k}else!f&&b[d]&&b[d].isNull&&(l=q=c);"undefined"!==typeof l&&(x.push({plotX:r,plotY:null===l?g:v.getThreshold(l),isNull:h,isCliff:!0}),n.push({plotX:r,plotY:null===q?g:v.getThreshold(q),doCurve:!1}))};b=b||this.points;f&&(b=this.getStackPoints(b));for(u=0;u<b.length;u++){f||(b[u].leftCliff=
b[u].rightCliff=b[u].leftNull=b[u].rightNull=void 0);var h=b[u].isNull;var r=w(b[u].rectPlotX,b[u].plotX);var A=f?w(b[u].yBottom,g):g;if(!h||e)e||a(u,u-1,"left"),h&&!f&&e||(x.push(b[u]),n.push({x:u,plotX:r,plotY:A})),e||a(u,u+1,"right")}u=d.call(this,x,!0,!0);n.reversed=!0;h=d.call(this,n,!0,!0);(A=h[0])&&"M"===A[0]&&(h[0]=["L",A[1],A[2]]);h=u.concat(h);h.length&&h.push(["Z"]);d=d.call(this,x,!1,e);h.xMap=u.xMap;this.areaPath=h;return d};e.prototype.getStackPoints=function(b){var d=this,e=[],f=[],
v=this.xAxis,u=this.yAxis,n=u.stacking.stacks[this.stackKey],D={},E=u.series,m=E.length,c=u.options.reversedStacks?1:-1,g=E.indexOf(d);b=b||this.points;if(this.options.stacking){for(var a=0;a<b.length;a++)b[a].leftNull=b[a].rightNull=void 0,D[b[a].x]=b[a];x(n,function(a,c){null!==a.total&&f.push(c)});f.sort(function(a,c){return a-c});var h=E.map(function(a){return a.visible});f.forEach(function(a,b){var k=0,l,r;if(D[a]&&!D[a].isNull)e.push(D[a]),[-1,1].forEach(function(e){var k=1===e?"rightNull":
"leftNull",q=0,t=n[f[b+e]];if(t)for(var p=g;0<=p&&p<m;){var v=E[p].index;l=t.points[v];l||(v===d.index?D[a][k]=!0:h[p]&&(r=n[a].points[v])&&(q-=r[1]-r[0]));p+=c}D[a][1===e?"rightCliff":"leftCliff"]=q});else{for(var q=g;0<=q&&q<m;){if(l=n[a].points[E[q].index]){k=l[1];break}q+=c}k=w(k,0);k=u.translate(k,0,1,0,1);e.push({isNull:!0,plotX:v.translate(a,0,0,0,1),x:a,plotY:k,yBottom:k})}})}return e};e.defaultOptions=B(C.defaultOptions,{threshold:0});return e}(C);e(z.prototype,{singleStacks:!1,drawLegendSymbol:b.drawRectangle});
I.registerSeriesType("area",z);"";return z});O(e,"Series/Spline/SplineSeries.js",[e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(e,b){var D=this&&this.__extends||function(){var b=function(e,x){b=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(b,e){b.__proto__=e}||function(b,e){for(var f in e)e.hasOwnProperty(f)&&(b[f]=e[f])};return b(e,x)};return function(e,x){function w(){this.constructor=e}b(e,x);e.prototype=null===x?Object.create(x):(w.prototype=x.prototype,
new w)}}(),z=e.seriesTypes.line,H=b.merge,G=b.pick;b=function(b){function e(){var e=null!==b&&b.apply(this,arguments)||this;e.data=void 0;e.options=void 0;e.points=void 0;return e}D(e,b);e.prototype.getPointSpline=function(b,e,v){var f=e.plotX||0,d=e.plotY||0,q=b[v-1];v=b[v+1];if(q&&!q.isNull&&!1!==q.doCurve&&!e.isCliff&&v&&!v.isNull&&!1!==v.doCurve&&!e.isCliff){b=q.plotY||0;var k=v.plotX||0;v=v.plotY||0;var l=0;var w=(1.5*f+(q.plotX||0))/2.5;var u=(1.5*d+b)/2.5;k=(1.5*f+k)/2.5;var n=(1.5*d+v)/2.5;
k!==w&&(l=(n-u)*(k-f)/(k-w)+d-n);u+=l;n+=l;u>b&&u>d?(u=Math.max(b,d),n=2*d-u):u<b&&u<d&&(u=Math.min(b,d),n=2*d-u);n>v&&n>d?(n=Math.max(v,d),u=2*d-n):n<v&&n<d&&(n=Math.min(v,d),u=2*d-n);e.rightContX=k;e.rightContY=n}e=["C",G(q.rightContX,q.plotX,0),G(q.rightContY,q.plotY,0),G(w,f,0),G(u,d,0),f,d];q.rightContX=q.rightContY=void 0;return e};e.defaultOptions=H(z.defaultOptions);return e}(z);e.registerSeriesType("spline",b);"";return b});O(e,"Series/AreaSpline/AreaSplineSeries.js",[e["Series/Area/AreaSeries.js"],
e["Series/Spline/SplineSeries.js"],e["Mixins/LegendSymbol.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(e,b,I,z,H){var D=this&&this.__extends||function(){var b=function(e,f){b=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(b,e){b.__proto__=e}||function(b,e){for(var d in e)e.hasOwnProperty(d)&&(b[d]=e[d])};return b(e,f)};return function(e,f){function d(){this.constructor=e}b(e,f);e.prototype=null===f?Object.create(f):(d.prototype=f.prototype,new d)}}(),C=
e.prototype,B=H.extend,x=H.merge;H=function(w){function v(){var b=null!==w&&w.apply(this,arguments)||this;b.data=void 0;b.points=void 0;b.options=void 0;return b}D(v,w);v.defaultOptions=x(b.defaultOptions,e.defaultOptions);return v}(b);B(H.prototype,{getGraphPath:C.getGraphPath,getStackPoints:C.getStackPoints,drawGraph:C.drawGraph,drawLegendSymbol:I.drawRectangle});z.registerSeriesType("areaspline",H);"";return H});O(e,"Series/Column/ColumnSeries.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Color/Color.js"],
e["Core/Globals.js"],e["Mixins/LegendSymbol.js"],e["Core/Color/Palette.js"],e["Core/Series/Series.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(e,b,I,z,H,G,C,B){var x=this&&this.__extends||function(){var c=function(b,a){c=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(a,c){a.__proto__=c}||function(a,c){for(var b in c)c.hasOwnProperty(b)&&(a[b]=c[b])};return c(b,a)};return function(b,a){function d(){this.constructor=b}c(b,a);b.prototype=null===a?Object.create(a):
(d.prototype=a.prototype,new d)}}(),w=e.animObject,v=b.parse,f=I.hasTouch;e=I.noop;var d=B.clamp,q=B.css,k=B.defined,l=B.extend,D=B.fireEvent,u=B.isArray,n=B.isNumber,J=B.merge,E=B.pick,m=B.objectEach;B=function(c){function b(){var a=null!==c&&c.apply(this,arguments)||this;a.borderWidth=void 0;a.data=void 0;a.group=void 0;a.options=void 0;a.points=void 0;return a}x(b,c);b.prototype.animate=function(a){var c=this,b=this.yAxis,e=c.options,g=this.chart.inverted,f={},k=g?"translateX":"translateY";if(a)f.scaleY=
.001,a=d(b.toPixels(e.threshold),b.pos,b.pos+b.len),g?f.translateX=a-b.len:f.translateY=a,c.clipBox&&c.setClip(),c.group.attr(f);else{var m=Number(c.group.attr(k));c.group.animate({scaleY:1},l(w(c.options.animation),{step:function(a,d){c.group&&(f[k]=m+d.pos*(b.pos-m),c.group.attr(f))}}))}};b.prototype.init=function(a,b){c.prototype.init.apply(this,arguments);var d=this;a=d.chart;a.hasRendered&&a.series.forEach(function(a){a.type===d.type&&(a.isDirty=!0)})};b.prototype.getColumnMetrics=function(){var a=
this,c=a.options,b=a.xAxis,d=a.yAxis,e=b.options.reversedStacks;e=b.reversed&&!e||!b.reversed&&e;var g,f={},k=0;!1===c.grouping?k=1:a.chart.series.forEach(function(c){var b=c.yAxis,e=c.options;if(c.type===a.type&&(c.visible||!a.chart.options.chart.ignoreHiddenSeries)&&d.len===b.len&&d.pos===b.pos){if(e.stacking&&"group"!==e.stacking){g=c.stackKey;"undefined"===typeof f[g]&&(f[g]=k++);var h=f[g]}else!1!==e.grouping&&(h=k++);c.columnIndex=h}});var m=Math.min(Math.abs(b.transA)*(b.ordinal&&b.ordinal.slope||
c.pointRange||b.closestPointRange||b.tickInterval||1),b.len),l=m*c.groupPadding,n=(m-2*l)/(k||1);c=Math.min(c.maxPointWidth||b.len,E(c.pointWidth,n*(1-2*c.pointPadding)));a.columnMetrics={width:c,offset:(n-c)/2+(l+((a.columnIndex||0)+(e?1:0))*n-m/2)*(e?-1:1),paddedWidth:n,columnCount:k};return a.columnMetrics};b.prototype.crispCol=function(a,c,b,d){var e=this.chart,h=this.borderWidth,g=-(h%2?.5:0);h=h%2?.5:1;e.inverted&&e.renderer.isVML&&(h+=1);this.options.crisp&&(b=Math.round(a+b)+g,a=Math.round(a)+
g,b-=a);d=Math.round(c+d)+h;g=.5>=Math.abs(c)&&.5<d;c=Math.round(c)+h;d-=c;g&&d&&(--c,d+=1);return{x:a,y:c,width:b,height:d}};b.prototype.adjustForMissingColumns=function(a,c,b,d){var e=this,h=this.options.stacking;if(!b.isNull&&1<d.columnCount){var g=0,f=0;m(this.yAxis.stacking&&this.yAxis.stacking.stacks,function(a){if("number"===typeof b.x&&(a=a[b.x.toString()])){var c=a.points[e.index],d=a.total;h?(c&&(g=f),a.hasValidPoints&&f++):u(c)&&(g=c[1],f=d||0)}});a=(b.plotX||0)+((f-1)*d.paddedWidth+c)/
2-c-g*d.paddedWidth}return a};b.prototype.translate=function(){var a=this,c=a.chart,b=a.options,e=a.dense=2>a.closestPointRange*a.xAxis.transA;e=a.borderWidth=E(b.borderWidth,e?0:1);var g=a.xAxis,f=a.yAxis,m=b.threshold,l=a.translatedThreshold=f.getThreshold(m),q=E(b.minPointLength,5),v=a.getColumnMetrics(),u=v.width,t=a.barW=Math.max(u,1+2*e),p=a.pointXOffset=v.offset,w=a.dataMin,x=a.dataMax;c.inverted&&(l-=.5);b.pointPadding&&(t=Math.ceil(t));G.prototype.translate.apply(a);a.points.forEach(function(e){var h=
E(e.yBottom,l),r=999+Math.abs(h),y=u,A=e.plotX||0;r=d(e.plotY,-r,f.len+r);A+=p;var D=t,B=Math.min(r,h),z=Math.max(r,h)-B;if(q&&Math.abs(z)<q){z=q;var C=!f.reversed&&!e.negative||f.reversed&&e.negative;n(m)&&n(x)&&e.y===m&&x<=m&&(f.min||0)<m&&(w!==x||(f.max||0)<=m)&&(C=!C);B=Math.abs(B-l)>q?h-q:l-(C?q:0)}k(e.options.pointWidth)&&(y=D=Math.ceil(e.options.pointWidth),A-=Math.round((y-u)/2));b.centerInCategory&&(A=a.adjustForMissingColumns(A,y,e,v));e.barX=A;e.pointWidth=y;e.tooltipPos=c.inverted?[d(f.len+
f.pos-c.plotLeft-r,f.pos-c.plotLeft,f.len+f.pos-c.plotLeft),g.len+g.pos-c.plotTop-A-D/2,z]:[g.left-c.plotLeft+A+D/2,d(r+f.pos-c.plotTop,f.pos-c.plotTop,f.len+f.pos-c.plotTop),z];e.shapeType=a.pointClass.prototype.shapeType||"rect";e.shapeArgs=a.crispCol.apply(a,e.isNull?[A,l,D,0]:[A,B,D,z])})};b.prototype.drawGraph=function(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data")};b.prototype.pointAttribs=function(a,c){var b=this.options,d=this.pointAttrToOptions||{};var e=d.stroke||
"borderColor";var h=d["stroke-width"]||"borderWidth",g=a&&a.color||this.color,f=a&&a[e]||b[e]||g,k=a&&a[h]||b[h]||this[h]||0;d=a&&a.options.dashStyle||b.dashStyle;var m=E(a&&a.opacity,b.opacity,1);if(a&&this.zones.length){var l=a.getZone();g=a.options.color||l&&(l.color||a.nonZonedColor)||this.color;l&&(f=l.borderColor||f,d=l.dashStyle||d,k=l.borderWidth||k)}c&&a&&(a=J(b.states[c],a.options.states&&a.options.states[c]||{}),c=a.brightness,g=a.color||"undefined"!==typeof c&&v(g).brighten(a.brightness).get()||
g,f=a[e]||f,k=a[h]||k,d=a.dashStyle||d,m=E(a.opacity,m));e={fill:g,stroke:f,"stroke-width":k,opacity:m};d&&(e.dashstyle=d);return e};b.prototype.drawPoints=function(){var a=this,c=this.chart,b=a.options,d=c.renderer,e=b.animationLimit||250,g;a.points.forEach(function(h){var f=h.graphic,k=!!f,m=f&&c.pointCount<e?"animate":"attr";if(n(h.plotY)&&null!==h.y){g=h.shapeArgs;f&&h.hasNewShapeType()&&(f=f.destroy());a.enabledDataSorting&&(h.startXPos=a.xAxis.reversed?-(g?g.width||0:0):a.xAxis.width);f||(h.graphic=
f=d[h.shapeType](g).add(h.group||a.group))&&a.enabledDataSorting&&c.hasRendered&&c.pointCount<e&&(f.attr({x:h.startXPos}),k=!0,m="animate");if(f&&k)f[m](J(g));if(b.borderRadius)f[m]({r:b.borderRadius});c.styledMode||f[m](a.pointAttribs(h,h.selected&&"select")).shadow(!1!==h.allowShadow&&b.shadow,null,b.stacking&&!b.borderRadius);f&&(f.addClass(h.getClassName(),!0),f.attr({visibility:h.visible?"inherit":"hidden"}))}else f&&(h.graphic=f.destroy())})};b.prototype.drawTracker=function(){var a=this,c=
a.chart,b=c.pointer,d=function(a){var c=b.getPointFromEvent(a);"undefined"!==typeof c&&(b.isDirectTouch=!0,c.onMouseOver(a))},e;a.points.forEach(function(a){e=u(a.dataLabels)?a.dataLabels:a.dataLabel?[a.dataLabel]:[];a.graphic&&(a.graphic.element.point=a);e.forEach(function(c){c.div?c.div.point=a:c.element.point=a})});a._hasTracking||(a.trackerGroups.forEach(function(e){if(a[e]){a[e].addClass("highcharts-tracker").on("mouseover",d).on("mouseout",function(a){b.onTrackerMouseOut(a)});if(f)a[e].on("touchstart",
d);!c.styledMode&&a.options.cursor&&a[e].css(q).css({cursor:a.options.cursor})}}),a._hasTracking=!0);D(this,"afterDrawTracker")};b.prototype.remove=function(){var a=this,c=a.chart;c.hasRendered&&c.series.forEach(function(c){c.type===a.type&&(c.isDirty=!0)});G.prototype.remove.apply(a,arguments)};b.defaultOptions=J(G.defaultOptions,{borderRadius:0,centerInCategory:!1,groupPadding:.2,marker:null,pointPadding:.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{halo:!1,brightness:.1},
select:{color:H.neutralColor20,borderColor:H.neutralColor100}},dataLabels:{align:void 0,verticalAlign:void 0,y:void 0},startFromThreshold:!0,stickyTracking:!1,tooltip:{distance:6},threshold:0,borderColor:H.backgroundColor});return b}(G);l(B.prototype,{cropShoulder:0,directTouch:!0,drawLegendSymbol:z.drawRectangle,getSymbol:e,negStacks:!0,trackerGroups:["group","dataLabelsGroup"]});C.registerSeriesType("column",B);"";"";return B});O(e,"Series/Bar/BarSeries.js",[e["Series/Column/ColumnSeries.js"],e["Core/Series/SeriesRegistry.js"],
e["Core/Utilities.js"]],function(e,b,I){var D=this&&this.__extends||function(){var b=function(e,x){b=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(b,e){b.__proto__=e}||function(b,e){for(var f in e)e.hasOwnProperty(f)&&(b[f]=e[f])};return b(e,x)};return function(e,x){function w(){this.constructor=e}b(e,x);e.prototype=null===x?Object.create(x):(w.prototype=x.prototype,new w)}}(),H=I.extend,G=I.merge;I=function(b){function B(){var e=null!==b&&b.apply(this,arguments)||this;e.data=void 0;
e.options=void 0;e.points=void 0;return e}D(B,b);B.defaultOptions=G(e.defaultOptions,{});return B}(e);H(I.prototype,{inverted:!0});b.registerSeriesType("bar",I);"";return I});O(e,"Series/Scatter/ScatterSeries.js",[e["Series/Column/ColumnSeries.js"],e["Series/Line/LineSeries.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(e,b,I,z){var D=this&&this.__extends||function(){var b=function(e,v){b=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(b,d){b.__proto__=d}||
function(b,d){for(var e in d)d.hasOwnProperty(e)&&(b[e]=d[e])};return b(e,v)};return function(e,v){function f(){this.constructor=e}b(e,v);e.prototype=null===v?Object.create(v):(f.prototype=v.prototype,new f)}}(),G=z.addEvent,C=z.extend,B=z.merge;z=function(e){function w(){var b=null!==e&&e.apply(this,arguments)||this;b.data=void 0;b.options=void 0;b.points=void 0;return b}D(w,e);w.prototype.applyJitter=function(){var b=this,e=this.options.jitter,d=this.points.length;e&&this.points.forEach(function(f,
k){["x","y"].forEach(function(l,q){var v="plot"+l.toUpperCase();if(e[l]&&!f.isNull){var n=b[l+"Axis"];var w=e[l]*n.transA;if(n&&!n.isLog){var E=Math.max(0,f[v]-w);n=Math.min(n.len,f[v]+w);q=1E4*Math.sin(k+q*d);f[v]=E+(n-E)*(q-Math.floor(q));"x"===l&&(f.clientX=f.plotX)}}})})};w.prototype.drawGraph=function(){(this.options.lineWidth||0===this.options.lineWidth&&this.graph&&this.graph.strokeWidth())&&e.prototype.drawGraph.call(this)};w.defaultOptions=B(b.defaultOptions,{lineWidth:0,findNearestPointBy:"xy",
jitter:{x:0,y:0},marker:{enabled:!0},tooltip:{headerFormat:'<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',pointFormat:"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"}});return w}(b);C(z.prototype,{drawTracker:e.prototype.drawTracker,sorted:!1,requireSorting:!1,noSharedTooltip:!0,trackerGroups:["group","markerGroup","dataLabelsGroup"],takeOrdinalPosition:!1});G(z,"afterTranslate",function(){this.applyJitter()});I.registerSeriesType("scatter",
z);"";return z});O(e,"Mixins/CenteredSeries.js",[e["Core/Globals.js"],e["Core/Series/Series.js"],e["Core/Utilities.js"]],function(e,b,I){var D=I.isNumber,H=I.pick,G=I.relativeLength,C=e.deg2rad;return e.CenteredSeriesMixin={getCenter:function(){var e=this.options,D=this.chart,w=2*(e.slicedOffset||0),v=D.plotWidth-2*w,f=D.plotHeight-2*w,d=e.center,q=Math.min(v,f),k=e.size,l=e.innerSize||0;"string"===typeof k&&(k=parseFloat(k));"string"===typeof l&&(l=parseFloat(l));e=[H(d[0],"50%"),H(d[1],"50%"),H(k&&
0>k?void 0:e.size,"100%"),H(l&&0>l?void 0:e.innerSize||0,"0%")];!D.angular||this instanceof b||(e[3]=0);for(d=0;4>d;++d)k=e[d],D=2>d||2===d&&/%$/.test(k),e[d]=G(k,[v,f,q,e[2]][d])+(D?w:0);e[3]>e[2]&&(e[3]=e[2]);return e},getStartAndEndRadians:function(b,e){b=D(b)?b:0;e=D(e)&&e>b&&360>e-b?e:b+360;return{start:C*(b+-90),end:C*(e+-90)}}}});O(e,"Series/Pie/PiePoint.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Series/Point.js"],e["Core/Utilities.js"]],function(e,b,I){var D=this&&this.__extends||
function(){var b=function(e,d){b=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(b,d){b.__proto__=d}||function(b,d){for(var e in d)d.hasOwnProperty(e)&&(b[e]=d[e])};return b(e,d)};return function(e,d){function f(){this.constructor=e}b(e,d);e.prototype=null===d?Object.create(d):(f.prototype=d.prototype,new f)}}(),H=e.setAnimation,G=I.addEvent,C=I.defined;e=I.extend;var B=I.isNumber,x=I.pick,w=I.relativeLength;I=function(e){function f(){var b=null!==e&&e.apply(this,arguments)||this;
b.labelDistance=void 0;b.options=void 0;b.series=void 0;return b}D(f,e);f.prototype.getConnectorPath=function(){var b=this.labelPosition,e=this.series.options.dataLabels,f=e.connectorShape,l=this.connectorShapes;l[f]&&(f=l[f]);return f.call(this,{x:b.final.x,y:b.final.y,alignment:b.alignment},b.connectorPosition,e)};f.prototype.getTranslate=function(){return this.sliced?this.slicedTranslation:{translateX:0,translateY:0}};f.prototype.haloPath=function(b){var d=this.shapeArgs;return this.sliced||!this.visible?
[]:this.series.chart.renderer.symbols.arc(d.x,d.y,d.r+b,d.r+b,{innerR:d.r-1,start:d.start,end:d.end})};f.prototype.init=function(){b.prototype.init.apply(this,arguments);var d=this;d.name=x(d.name,"Slice");var e=function(b){d.slice("select"===b.type)};G(d,"select",e);G(d,"unselect",e);return d};f.prototype.isValid=function(){return B(this.y)&&0<=this.y};f.prototype.setVisible=function(b,e){var d=this,f=d.series,q=f.chart,v=f.options.ignoreHiddenPoint;e=x(e,v);b!==d.visible&&(d.visible=d.options.visible=
b="undefined"===typeof b?!d.visible:b,f.options.data[f.data.indexOf(d)]=d.options,["graphic","dataLabel","connector","shadowGroup"].forEach(function(e){if(d[e])d[e][b?"show":"hide"](b)}),d.legendItem&&q.legend.colorizeItem(d,b),b||"hover"!==d.state||d.setState(""),v&&(f.isDirty=!0),e&&q.redraw())};f.prototype.slice=function(b,e,f){var d=this.series;H(f,d.chart);x(e,!0);this.sliced=this.options.sliced=C(b)?b:!this.sliced;d.options.data[d.data.indexOf(this)]=this.options;this.graphic&&this.graphic.animate(this.getTranslate());
this.shadowGroup&&this.shadowGroup.animate(this.getTranslate())};return f}(b);e(I.prototype,{connectorShapes:{fixedOffset:function(b,e,d){var f=e.breakAt;e=e.touchingSliceAt;return[["M",b.x,b.y],d.softConnector?["C",b.x+("left"===b.alignment?-5:5),b.y,2*f.x-e.x,2*f.y-e.y,f.x,f.y]:["L",f.x,f.y],["L",e.x,e.y]]},straight:function(b,e){e=e.touchingSliceAt;return[["M",b.x,b.y],["L",e.x,e.y]]},crookedLine:function(b,e,d){e=e.touchingSliceAt;var f=this.series,k=f.center[0],l=f.chart.plotWidth,v=f.chart.plotLeft;
f=b.alignment;var u=this.shapeArgs.r;d=w(d.crookDistance,1);l="left"===f?k+u+(l+v-k-u)*(1-d):v+(k-u)*d;d=["L",l,b.y];k=!0;if("left"===f?l>b.x||l<e.x:l<b.x||l>e.x)k=!1;b=[["M",b.x,b.y]];k&&b.push(d);b.push(["L",e.x,e.y]);return b}}});return I});O(e,"Series/Pie/PieSeries.js",[e["Mixins/CenteredSeries.js"],e["Series/Column/ColumnSeries.js"],e["Core/Globals.js"],e["Mixins/LegendSymbol.js"],e["Core/Color/Palette.js"],e["Series/Pie/PiePoint.js"],e["Core/Series/Series.js"],e["Core/Series/SeriesRegistry.js"],
e["Core/Renderer/SVG/SVGRenderer.js"],e["Core/Utilities.js"]],function(e,b,I,z,H,G,C,B,x,w){var v=this&&this.__extends||function(){var b=function(d,e){b=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(b,c){b.__proto__=c}||function(b,c){for(var d in c)c.hasOwnProperty(d)&&(b[d]=c[d])};return b(d,e)};return function(d,e){function f(){this.constructor=d}b(d,e);d.prototype=null===e?Object.create(e):(f.prototype=e.prototype,new f)}}(),f=e.getStartAndEndRadians;I=I.noop;var d=w.clamp,q=
w.extend,k=w.fireEvent,l=w.merge,D=w.pick,u=w.relativeLength;w=function(b){function e(){var d=null!==b&&b.apply(this,arguments)||this;d.center=void 0;d.data=void 0;d.maxLabelDistance=void 0;d.options=void 0;d.points=void 0;return d}v(e,b);e.prototype.animate=function(b){var d=this,c=d.points,e=d.startAngleRad;b||c.forEach(function(a){var c=a.graphic,b=a.shapeArgs;c&&b&&(c.attr({r:D(a.startR,d.center&&d.center[3]/2),start:e,end:e}),c.animate({r:b.r,start:b.start,end:b.end},d.options.animation))})};
e.prototype.drawEmpty=function(){var b=this.startAngleRad,d=this.endAngleRad,c=this.options;if(0===this.total&&this.center){var e=this.center[0];var a=this.center[1];this.graph||(this.graph=this.chart.renderer.arc(e,a,this.center[1]/2,0,b,d).addClass("highcharts-empty-series").add(this.group));this.graph.attr({d:x.prototype.symbols.arc(e,a,this.center[2]/2,0,{start:b,end:d,innerR:this.center[3]/2})});this.chart.styledMode||this.graph.attr({"stroke-width":c.borderWidth,fill:c.fillColor||"none",stroke:c.color||
H.neutralColor20})}else this.graph&&(this.graph=this.graph.destroy())};e.prototype.drawPoints=function(){var b=this.chart.renderer;this.points.forEach(function(d){d.graphic&&d.hasNewShapeType()&&(d.graphic=d.graphic.destroy());d.graphic||(d.graphic=b[d.shapeType](d.shapeArgs).add(d.series.group),d.delayedRendering=!0)})};e.prototype.generatePoints=function(){b.prototype.generatePoints.call(this);this.updateTotals()};e.prototype.getX=function(b,e,c){var g=this.center,a=this.radii?this.radii[c.index]||
0:g[2]/2;b=Math.asin(d((b-g[1])/(a+c.labelDistance),-1,1));return g[0]+(e?-1:1)*Math.cos(b)*(a+c.labelDistance)+(0<c.labelDistance?(e?-1:1)*this.options.dataLabels.padding:0)};e.prototype.hasData=function(){return!!this.processedXData.length};e.prototype.redrawPoints=function(){var b=this,d=b.chart,c=d.renderer,e,a,h,f,k=b.options.shadow;this.drawEmpty();!k||b.shadowGroup||d.styledMode||(b.shadowGroup=c.g("shadow").attr({zIndex:-1}).add(b.group));b.points.forEach(function(g){var m={};a=g.graphic;
if(!g.isNull&&a){var r=void 0;f=g.shapeArgs;e=g.getTranslate();d.styledMode||(r=g.shadowGroup,k&&!r&&(r=g.shadowGroup=c.g("shadow").add(b.shadowGroup)),r&&r.attr(e),h=b.pointAttribs(g,g.selected&&"select"));g.delayedRendering?(a.setRadialReference(b.center).attr(f).attr(e),d.styledMode||a.attr(h).attr({"stroke-linejoin":"round"}).shadow(k,r),g.delayedRendering=!1):(a.setRadialReference(b.center),d.styledMode||l(!0,m,h),l(!0,m,f,e),a.animate(m));a.attr({visibility:g.visible?"inherit":"hidden"});a.addClass(g.getClassName(),
!0)}else a&&(g.graphic=a.destroy())})};e.prototype.sortByAngle=function(b,d){b.sort(function(c,b){return"undefined"!==typeof c.angle&&(b.angle-c.angle)*d})};e.prototype.translate=function(b){this.generatePoints();var d=0,c=this.options,e=c.slicedOffset,a=e+(c.borderWidth||0),h=f(c.startAngle,c.endAngle),l=this.startAngleRad=h.start;h=(this.endAngleRad=h.end)-l;var n=this.points,q=c.dataLabels.distance;c=c.ignoreHiddenPoint;var v,w=n.length;b||(this.center=b=this.getCenter());for(v=0;v<w;v++){var x=
n[v];var E=l+d*h;!x.isValid()||c&&!x.visible||(d+=x.percentage/100);var z=l+d*h;var B={x:b[0],y:b[1],r:b[2]/2,innerR:b[3]/2,start:Math.round(1E3*E)/1E3,end:Math.round(1E3*z)/1E3};x.shapeType="arc";x.shapeArgs=B;x.labelDistance=D(x.options.dataLabels&&x.options.dataLabels.distance,q);x.labelDistance=u(x.labelDistance,B.r);this.maxLabelDistance=Math.max(this.maxLabelDistance||0,x.labelDistance);z=(z+E)/2;z>1.5*Math.PI?z-=2*Math.PI:z<-Math.PI/2&&(z+=2*Math.PI);x.slicedTranslation={translateX:Math.round(Math.cos(z)*
e),translateY:Math.round(Math.sin(z)*e)};B=Math.cos(z)*b[2]/2;var t=Math.sin(z)*b[2]/2;x.tooltipPos=[b[0]+.7*B,b[1]+.7*t];x.half=z<-Math.PI/2||z>Math.PI/2?1:0;x.angle=z;E=Math.min(a,x.labelDistance/5);x.labelPosition={natural:{x:b[0]+B+Math.cos(z)*x.labelDistance,y:b[1]+t+Math.sin(z)*x.labelDistance},"final":{},alignment:0>x.labelDistance?"center":x.half?"right":"left",connectorPosition:{breakAt:{x:b[0]+B+Math.cos(z)*E,y:b[1]+t+Math.sin(z)*E},touchingSliceAt:{x:b[0]+B,y:b[1]+t}}}}k(this,"afterTranslate")};
e.prototype.updateTotals=function(){var b,d=0,c=this.points,e=c.length,a=this.options.ignoreHiddenPoint;for(b=0;b<e;b++){var h=c[b];!h.isValid()||a&&!h.visible||(d+=h.y)}this.total=d;for(b=0;b<e;b++)h=c[b],h.percentage=0<d&&(h.visible||!a)?h.y/d*100:0,h.total=d};e.defaultOptions=l(C.defaultOptions,{center:[null,null],clip:!1,colorByPoint:!0,dataLabels:{allowOverlap:!0,connectorPadding:5,connectorShape:"fixedOffset",crookDistance:"70%",distance:30,enabled:!0,formatter:function(){return this.point.isNull?
void 0:this.point.name},softConnector:!0,x:0},fillColor:void 0,ignoreHiddenPoint:!0,inactiveOtherPoints:!0,legendType:"point",marker:null,size:null,showInLegend:!1,slicedOffset:10,stickyTracking:!1,tooltip:{followPointer:!0},borderColor:H.backgroundColor,borderWidth:1,lineWidth:void 0,states:{hover:{brightness:.1}}});return e}(C);q(w.prototype,{axisTypes:[],directTouch:!0,drawGraph:void 0,drawLegendSymbol:z.drawRectangle,drawTracker:b.prototype.drawTracker,getCenter:e.getCenter,getSymbol:I,isCartesian:!1,
noSharedTooltip:!0,pointAttribs:b.prototype.pointAttribs,pointClass:G,requireSorting:!1,searchPoint:I,trackerGroups:["group","dataLabelsGroup"]});B.registerSeriesType("pie",w);"";return w});O(e,"Core/Series/DataLabels.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/FormatUtilities.js"],e["Core/Globals.js"],e["Core/Color/Palette.js"],e["Core/Series/Series.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(e,b,I,z,H,G,C){var D=e.getDeferredAnimation,x=b.format;e=I.noop;
G=G.seriesTypes;var w=C.arrayMax,v=C.clamp,f=C.defined,d=C.extend,q=C.fireEvent,k=C.isArray,l=C.merge,N=C.objectEach,u=C.pick,n=C.relativeLength,J=C.splat,E=C.stableSort;"";I.distribute=function(b,c,d){function a(a,c){return a.target-c.target}var e,g=!0,f=b,k=[];var l=0;var m=f.reducedLen||c;for(e=b.length;e--;)l+=b[e].size;if(l>m){E(b,function(a,c){return(c.rank||0)-(a.rank||0)});for(l=e=0;l<=m;)l+=b[e].size,e++;k=b.splice(e-1,b.length)}E(b,a);for(b=b.map(function(a){return{size:a.size,targets:[a.target],
align:u(a.align,.5)}});g;){for(e=b.length;e--;)g=b[e],l=(Math.min.apply(0,g.targets)+Math.max.apply(0,g.targets))/2,g.pos=v(l-g.size*g.align,0,c-g.size);e=b.length;for(g=!1;e--;)0<e&&b[e-1].pos+b[e-1].size>b[e].pos&&(b[e-1].size+=b[e].size,b[e-1].targets=b[e-1].targets.concat(b[e].targets),b[e-1].align=.5,b[e-1].pos+b[e-1].size>c&&(b[e-1].pos=c-b[e-1].size),b.splice(e,1),g=!0)}f.push.apply(f,k);e=0;b.some(function(a){var b=0;if(a.targets.some(function(){f[e].pos=a.pos+b;if("undefined"!==typeof d&&
Math.abs(f[e].pos-f[e].target)>d)return f.slice(0,e+1).forEach(function(a){delete a.pos}),f.reducedLen=(f.reducedLen||c)-.1*c,f.reducedLen>.1*c&&I.distribute(f,c,d),!0;b+=f[e].size;e++}))return!0});E(f,a)};H.prototype.drawDataLabels=function(){function b(a,c){var b=c.filter;return b?(c=b.operator,a=a[b.property],b=b.value,">"===c&&a>b||"<"===c&&a<b||">="===c&&a>=b||"<="===c&&a<=b||"=="===c&&a==b||"==="===c&&a===b?!0:!1):!0}function c(a,c){var b=[],d;if(k(a)&&!k(c))b=a.map(function(a){return l(a,c)});
else if(k(c)&&!k(a))b=c.map(function(c){return l(a,c)});else if(k(a)||k(c))for(d=Math.max(a.length,c.length);d--;)b[d]=l(a[d],c[d]);else b=l(a,c);return b}var d=this,a=d.chart,e=d.options,r=e.dataLabels,n=d.points,v,w=d.hasRendered||0,E=r.animation;E=r.defer?D(a,E,d):{defer:0,duration:0};var B=a.renderer;r=c(c(a.options.plotOptions&&a.options.plotOptions.series&&a.options.plotOptions.series.dataLabels,a.options.plotOptions&&a.options.plotOptions[d.type]&&a.options.plotOptions[d.type].dataLabels),
r);q(this,"drawDataLabels");if(k(r)||r.enabled||d._hasPointLabels){var C=d.plotGroup("dataLabelsGroup","data-labels",w?"inherit":"hidden",r.zIndex||6);C.attr({opacity:+w});!w&&(w=d.dataLabelsGroup)&&(d.visible&&C.show(!0),w[e.animation?"animate":"attr"]({opacity:1},E));n.forEach(function(g){v=J(c(r,g.dlOptions||g.options&&g.options.dataLabels));v.forEach(function(c,h){var k=c.enabled&&(!g.isNull||g.dataLabelOnNull)&&b(g,c),l=g.dataLabels?g.dataLabels[h]:g.dataLabel,m=g.connectors?g.connectors[h]:
g.connector,r=u(c.distance,g.labelDistance),n=!l;if(k){var q=g.getLabelConfig();var t=u(c[g.formatPrefix+"Format"],c.format);q=f(t)?x(t,q,a):(c[g.formatPrefix+"Formatter"]||c.formatter).call(q,c);t=c.style;var v=c.rotation;a.styledMode||(t.color=u(c.color,t.color,d.color,z.neutralColor100),"contrast"===t.color?(g.contrastColor=B.getContrast(g.color||d.color),t.color=!f(r)&&c.inside||0>r||e.stacking?g.contrastColor:z.neutralColor100):delete g.contrastColor,e.cursor&&(t.cursor=e.cursor));var w={r:c.borderRadius||
0,rotation:v,padding:c.padding,zIndex:1};a.styledMode||(w.fill=c.backgroundColor,w.stroke=c.borderColor,w["stroke-width"]=c.borderWidth);N(w,function(a,c){"undefined"===typeof a&&delete w[c]})}!l||k&&f(q)?k&&f(q)&&(l?w.text=q:(g.dataLabels=g.dataLabels||[],l=g.dataLabels[h]=v?B.text(q,0,-9999,c.useHTML).addClass("highcharts-data-label"):B.label(q,0,-9999,c.shape,null,null,c.useHTML,null,"data-label"),h||(g.dataLabel=l),l.addClass(" highcharts-data-label-color-"+g.colorIndex+" "+(c.className||"")+
(c.useHTML?" highcharts-tracker":""))),l.options=c,l.attr(w),a.styledMode||l.css(t).shadow(c.shadow),l.added||l.add(C),c.textPath&&!c.useHTML&&(l.setTextPath(g.getDataLabelPath&&g.getDataLabelPath(l)||g.graphic,c.textPath),g.dataLabelPath&&!c.textPath.enabled&&(g.dataLabelPath=g.dataLabelPath.destroy())),d.alignDataLabel(g,l,c,null,n)):(g.dataLabel=g.dataLabel&&g.dataLabel.destroy(),g.dataLabels&&(1===g.dataLabels.length?delete g.dataLabels:delete g.dataLabels[h]),h||delete g.dataLabel,m&&(g.connector=
g.connector.destroy(),g.connectors&&(1===g.connectors.length?delete g.connectors:delete g.connectors[h])))})})}q(this,"afterDrawDataLabels")};H.prototype.alignDataLabel=function(b,c,e,a,f){var g=this,h=this.chart,k=this.isCartesian&&h.inverted,l=this.enabledDataSorting,m=u(b.dlBox&&b.dlBox.centerX,b.plotX,-9999),n=u(b.plotY,-9999),q=c.getBBox(),v=e.rotation,w=e.align,t=h.isInsidePlot(m,Math.round(n),{inverted:k,paneCoordinates:!0,series:g}),p="justify"===u(e.overflow,l?"none":"justify"),D=this.visible&&
!1!==b.visible&&(b.series.forceDL||l&&!p||t||u(e.inside,!!this.options.stacking)&&a&&h.isInsidePlot(m,k?a.x+1:a.y+a.height-1,{inverted:k,paneCoordinates:!0,series:g}));var x=function(a){l&&g.xAxis&&!p&&g.setDataLabelStartPos(b,c,f,t,a)};if(D){var z=h.renderer.fontMetrics(h.styledMode?void 0:e.style.fontSize,c).b;a=d({x:k?this.yAxis.len-n:m,y:Math.round(k?this.xAxis.len-m:n),width:0,height:0},a);d(e,{width:q.width,height:q.height});v?(p=!1,m=h.renderer.rotCorr(z,v),m={x:a.x+(e.x||0)+a.width/2+m.x,
y:a.y+(e.y||0)+{top:0,middle:.5,bottom:1}[e.verticalAlign]*a.height},x(m),c[f?"attr":"animate"](m).attr({align:w}),x=(v+720)%360,x=180<x&&360>x,"left"===w?m.y-=x?q.height:0:"center"===w?(m.x-=q.width/2,m.y-=q.height/2):"right"===w&&(m.x-=q.width,m.y-=x?0:q.height),c.placed=!0,c.alignAttr=m):(x(a),c.align(e,void 0,a),m=c.alignAttr);p&&0<=a.height?this.justifyDataLabel(c,e,m,q,a,f):u(e.crop,!0)&&(D=h.isInsidePlot(m.x,m.y,{paneCoordinates:!0,series:g})&&h.isInsidePlot(m.x+q.width,m.y+q.height,{paneCoordinates:!0,
series:g}));if(e.shape&&!v)c[f?"attr":"animate"]({anchorX:k?h.plotWidth-b.plotY:b.plotX,anchorY:k?h.plotHeight-b.plotX:b.plotY})}f&&l&&(c.placed=!1);D||l&&!p||(c.hide(!0),c.placed=!1)};H.prototype.setDataLabelStartPos=function(b,c,d,a,e){var g=this.chart,f=g.inverted,h=this.xAxis,k=h.reversed,l=f?c.height/2:c.width/2;b=(b=b.pointWidth)?b/2:0;h=f?e.x:k?-l-b:h.width-l+b;e=f?k?this.yAxis.height-l+b:-l-b:e.y;c.startXPos=h;c.startYPos=e;a?"hidden"===c.visibility&&(c.show(),c.attr({opacity:0}).animate({opacity:1})):
c.attr({opacity:1}).animate({opacity:0},void 0,c.hide);g.hasRendered&&(d&&c.attr({x:c.startXPos,y:c.startYPos}),c.placed=!0)};H.prototype.justifyDataLabel=function(b,c,d,a,e,f){var g=this.chart,h=c.align,k=c.verticalAlign,l=b.box?0:b.padding||0,m=c.x;m=void 0===m?0:m;var n=c.y;var r=void 0===n?0:n;n=(d.x||0)+l;if(0>n){"right"===h&&0<=m?(c.align="left",c.inside=!0):m-=n;var q=!0}n=(d.x||0)+a.width-l;n>g.plotWidth&&("left"===h&&0>=m?(c.align="right",c.inside=!0):m+=g.plotWidth-n,q=!0);n=d.y+l;0>n&&
("bottom"===k&&0<=r?(c.verticalAlign="top",c.inside=!0):r-=n,q=!0);n=(d.y||0)+a.height-l;n>g.plotHeight&&("top"===k&&0>=r?(c.verticalAlign="bottom",c.inside=!0):r+=g.plotHeight-n,q=!0);q&&(c.x=m,c.y=r,b.placed=!f,b.align(c,void 0,e));return q};G.pie&&(G.pie.prototype.dataLabelPositioners={radialDistributionY:function(b){return b.top+b.distributeBox.pos},radialDistributionX:function(b,c,d,a){return b.getX(d<c.top+2||d>c.bottom-2?a:d,c.half,c)},justify:function(b,c,d){return d[0]+(b.half?-1:1)*(c+b.labelDistance)},
alignToPlotEdges:function(b,c,d,a){b=b.getBBox().width;return c?b+a:d-b-a},alignToConnectors:function(b,c,d,a){var e=0,g;b.forEach(function(a){g=a.dataLabel.getBBox().width;g>e&&(e=g)});return c?e+a:d-e-a}},G.pie.prototype.drawDataLabels=function(){var b=this,c=b.data,d,a=b.chart,e=b.options.dataLabels||{},k=e.connectorPadding,n,q=a.plotWidth,v=a.plotHeight,x=a.plotLeft,D=Math.round(a.chartWidth/3),E,B=b.center,C=B[2]/2,t=B[1],p,G,J,N,F=[[],[]],O,K,T,X,U=[0,0,0,0],W=b.dataLabelPositioners,Y;b.visible&&
(e.enabled||b._hasPointLabels)&&(c.forEach(function(a){a.dataLabel&&a.visible&&a.dataLabel.shortened&&(a.dataLabel.attr({width:"auto"}).css({width:"auto",textOverflow:"clip"}),a.dataLabel.shortened=!1)}),H.prototype.drawDataLabels.apply(b),c.forEach(function(a){a.dataLabel&&(a.visible?(F[a.half].push(a),a.dataLabel._pos=null,!f(e.style.width)&&!f(a.options.dataLabels&&a.options.dataLabels.style&&a.options.dataLabels.style.width)&&a.dataLabel.getBBox().width>D&&(a.dataLabel.css({width:Math.round(.7*
D)+"px"}),a.dataLabel.shortened=!0)):(a.dataLabel=a.dataLabel.destroy(),a.dataLabels&&1===a.dataLabels.length&&delete a.dataLabels))}),F.forEach(function(c,g){var h=c.length,l=[],m;if(h){b.sortByAngle(c,g-.5);if(0<b.maxLabelDistance){var n=Math.max(0,t-C-b.maxLabelDistance);var r=Math.min(t+C+b.maxLabelDistance,a.plotHeight);c.forEach(function(b){0<b.labelDistance&&b.dataLabel&&(b.top=Math.max(0,t-C-b.labelDistance),b.bottom=Math.min(t+C+b.labelDistance,a.plotHeight),m=b.dataLabel.getBBox().height||
21,b.distributeBox={target:b.labelPosition.natural.y-b.top+m/2,size:m,rank:b.y},l.push(b.distributeBox))});n=r+m-n;I.distribute(l,n,n/5)}for(X=0;X<h;X++){d=c[X];J=d.labelPosition;p=d.dataLabel;T=!1===d.visible?"hidden":"inherit";K=n=J.natural.y;l&&f(d.distributeBox)&&("undefined"===typeof d.distributeBox.pos?T="hidden":(N=d.distributeBox.size,K=W.radialDistributionY(d)));delete d.positionIndex;if(e.justify)O=W.justify(d,C,B);else switch(e.alignTo){case "connectors":O=W.alignToConnectors(c,g,q,x);
break;case "plotEdges":O=W.alignToPlotEdges(p,g,q,x);break;default:O=W.radialDistributionX(b,d,K,n)}p._attr={visibility:T,align:J.alignment};Y=d.options.dataLabels||{};p._pos={x:O+u(Y.x,e.x)+({left:k,right:-k}[J.alignment]||0),y:K+u(Y.y,e.y)-10};J.final.x=O;J.final.y=K;u(e.crop,!0)&&(G=p.getBBox().width,n=null,O-G<k&&1===g?(n=Math.round(G-O+k),U[3]=Math.max(n,U[3])):O+G>q-k&&0===g&&(n=Math.round(O+G-q+k),U[1]=Math.max(n,U[1])),0>K-N/2?U[0]=Math.max(Math.round(-K+N/2),U[0]):K+N/2>v&&(U[2]=Math.max(Math.round(K+
N/2-v),U[2])),p.sideOverflow=n)}}}),0===w(U)||this.verifyDataLabelOverflow(U))&&(this.placeDataLabels(),this.points.forEach(function(c){Y=l(e,c.options.dataLabels);if(n=u(Y.connectorWidth,1)){var d;E=c.connector;if((p=c.dataLabel)&&p._pos&&c.visible&&0<c.labelDistance){T=p._attr.visibility;if(d=!E)c.connector=E=a.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-"+c.colorIndex+(c.className?" "+c.className:"")).add(b.dataLabelsGroup),a.styledMode||E.attr({"stroke-width":n,
stroke:Y.connectorColor||c.color||z.neutralColor60});E[d?"attr":"animate"]({d:c.getConnectorPath()});E.attr("visibility",T)}else E&&(c.connector=E.destroy())}}))},G.pie.prototype.placeDataLabels=function(){this.points.forEach(function(b){var c=b.dataLabel,d;c&&b.visible&&((d=c._pos)?(c.sideOverflow&&(c._attr.width=Math.max(c.getBBox().width-c.sideOverflow,0),c.css({width:c._attr.width+"px",textOverflow:(this.options.dataLabels.style||{}).textOverflow||"ellipsis"}),c.shortened=!0),c.attr(c._attr),
c[c.moved?"animate":"attr"](d),c.moved=!0):c&&c.attr({y:-9999}));delete b.distributeBox},this)},G.pie.prototype.alignDataLabel=e,G.pie.prototype.verifyDataLabelOverflow=function(b){var c=this.center,d=this.options,a=d.center,e=d.minSize||80,f=null!==d.size;if(!f){if(null!==a[0])var k=Math.max(c[2]-Math.max(b[1],b[3]),e);else k=Math.max(c[2]-b[1]-b[3],e),c[0]+=(b[3]-b[1])/2;null!==a[1]?k=v(k,e,c[2]-Math.max(b[0],b[2])):(k=v(k,e,c[2]-b[0]-b[2]),c[1]+=(b[0]-b[2])/2);k<c[2]?(c[2]=k,c[3]=Math.min(n(d.innerSize||
0,k),k),this.translate(c),this.drawDataLabels&&this.drawDataLabels()):f=!0}return f});G.column&&(G.column.prototype.alignDataLabel=function(b,c,d,a,e){var f=this.chart.inverted,g=b.series,h=b.dlBox||b.shapeArgs,k=u(b.below,b.plotY>u(this.translatedThreshold,g.yAxis.len)),m=u(d.inside,!!this.options.stacking);h&&(a=l(h),0>a.y&&(a.height+=a.y,a.y=0),h=a.y+a.height-g.yAxis.len,0<h&&h<a.height&&(a.height-=h),f&&(a={x:g.yAxis.len-a.y-a.height,y:g.xAxis.len-a.x-a.width,width:a.height,height:a.width}),m||
(f?(a.x+=k?0:a.width,a.width=0):(a.y+=k?a.height:0,a.height=0)));d.align=u(d.align,!f||m?"center":k?"right":"left");d.verticalAlign=u(d.verticalAlign,f||m?"middle":k?"top":"bottom");H.prototype.alignDataLabel.call(this,b,c,d,a,e);d.inside&&b.contrastColor&&c.css({color:b.contrastColor})})});O(e,"Extensions/OverlappingDataLabels.js",[e["Core/Chart/Chart.js"],e["Core/Utilities.js"]],function(e,b){function D(b,e){var f=!1;if(b){var d=b.newOpacity;b.oldOpacity!==d&&(b.alignAttr&&b.placed?(b[d?"removeClass":
"addClass"]("highcharts-data-label-hidden"),f=!0,b.alignAttr.opacity=d,b[b.isOld?"animate":"attr"](b.alignAttr,null,function(){e.styledMode||b.css({pointerEvents:d?"auto":"none"});b.visibility=d?"inherit":"hidden"}),H(e,"afterHideOverlappingLabel")):b.attr({opacity:d}));b.isOld=!0}return f}var z=b.addEvent,H=b.fireEvent,G=b.isArray,C=b.isNumber,B=b.objectEach,x=b.pick;z(e,"render",function(){var b=this,e=[];(this.labelCollectors||[]).forEach(function(b){e=e.concat(b())});(this.yAxis||[]).forEach(function(b){b.stacking&&
b.options.stackLabels&&!b.options.stackLabels.allowOverlap&&B(b.stacking.stacks,function(b){B(b,function(b){e.push(b.label)})})});(this.series||[]).forEach(function(f){var d=f.options.dataLabels;f.visible&&(!1!==d.enabled||f._hasPointLabels)&&(d=function(d){return d.forEach(function(d){d.visible&&(G(d.dataLabels)?d.dataLabels:d.dataLabel?[d.dataLabel]:[]).forEach(function(f){var k=f.options;f.labelrank=x(k.labelrank,d.labelrank,d.shapeArgs&&d.shapeArgs.height);k.allowOverlap?(f.oldOpacity=f.opacity,
f.newOpacity=1,D(f,b)):e.push(f)})})},d(f.nodes||[]),d(f.points))});this.hideOverlappingLabels(e)});e.prototype.hideOverlappingLabels=function(b){var e=this,f=b.length,d=e.renderer,q,k,l,w=!1;var u=function(b){var e,c=b.box?0:b.padding||0,f=e=0,a;if(b&&(!b.alignAttr||b.placed)){var h=b.alignAttr||{x:b.attr("x"),y:b.attr("y")};var k=b.parentGroup;b.width||(e=b.getBBox(),b.width=e.width,b.height=e.height,e=d.fontMetrics(null,b.element).h);var l=b.width-2*c;(a={left:"0",center:"0.5",right:"1"}[b.alignValue])?
f=+a*l:C(b.x)&&Math.round(b.x)!==b.translateX&&(f=b.x-b.translateX);return{x:h.x+(k.translateX||0)+c-(f||0),y:h.y+(k.translateY||0)+c-e,width:b.width-2*c,height:b.height-2*c}}};for(k=0;k<f;k++)if(q=b[k])q.oldOpacity=q.opacity,q.newOpacity=1,q.absoluteBox=u(q);b.sort(function(b,d){return(d.labelrank||0)-(b.labelrank||0)});for(k=0;k<f;k++){var n=(u=b[k])&&u.absoluteBox;for(q=k+1;q<f;++q){var x=(l=b[q])&&l.absoluteBox;!n||!x||u===l||0===u.newOpacity||0===l.newOpacity||x.x>=n.x+n.width||x.x+x.width<=
n.x||x.y>=n.y+n.height||x.y+x.height<=n.y||((u.labelrank<l.labelrank?u:l).newOpacity=0)}}b.forEach(function(b){D(b,e)&&(w=!0)});w&&H(e,"afterHideAllOverlappingLabels")}});O(e,"Core/Responsive.js",[e["Core/Chart/Chart.js"],e["Core/Utilities.js"]],function(e,b){var D=b.find,z=b.isArray,H=b.isObject,G=b.merge,C=b.objectEach,B=b.pick,x=b.splat,w=b.uniqueKey;e.prototype.setResponsive=function(b,e){var d=this.options.responsive,f=[],k=this.currentResponsive;!e&&d&&d.rules&&d.rules.forEach(function(b){"undefined"===
typeof b._id&&(b._id=w());this.matchResponsiveRule(b,f)},this);e=G.apply(0,f.map(function(b){return D(d.rules,function(d){return d._id===b}).chartOptions}));e.isResponsiveOptions=!0;f=f.toString()||void 0;f!==(k&&k.ruleIds)&&(k&&this.update(k.undoOptions,b,!0),f?(k=this.currentOptions(e),k.isResponsiveOptions=!0,this.currentResponsive={ruleIds:f,mergedOptions:e,undoOptions:k},this.update(e,b,!0)):this.currentResponsive=void 0)};e.prototype.matchResponsiveRule=function(b,e){var d=b.condition;(d.callback||
function(){return this.chartWidth<=B(d.maxWidth,Number.MAX_VALUE)&&this.chartHeight<=B(d.maxHeight,Number.MAX_VALUE)&&this.chartWidth>=B(d.minWidth,0)&&this.chartHeight>=B(d.minHeight,0)}).call(this)&&e.push(b._id)};e.prototype.currentOptions=function(b){function e(b,f,q,u){var k;C(b,function(b,l){if(!u&&-1<d.collectionsWithUpdate.indexOf(l)&&f[l])for(b=x(b),q[l]=[],k=0;k<Math.max(b.length,f[l].length);k++)f[l][k]&&(void 0===b[k]?q[l][k]=f[l][k]:(q[l][k]={},e(b[k],f[l][k],q[l][k],u+1)));else H(b)?
(q[l]=z(b)?[]:{},e(b,f[l]||{},q[l],u+1)):q[l]="undefined"===typeof f[l]?null:f[l]})}var d=this,q={};e(b,this.options,q,0);return q}});O(e,"masters/highcharts.src.js",[e["Core/Globals.js"],e["Core/Utilities.js"],e["Core/Options.js"],e["Core/Animation/Fx.js"],e["Core/Animation/AnimationUtilities.js"],e["Core/Renderer/HTML/AST.js"],e["Core/FormatUtilities.js"],e["Core/Renderer/SVG/SVGElement.js"],e["Core/Series/Series.js"]],function(e,b,I,z,H,G,C,B,x){e.animate=H.animate;e.animObject=H.animObject;e.getDeferredAnimation=
H.getDeferredAnimation;e.setAnimation=H.setAnimation;e.stop=H.stop;e.timers=z.timers;e.AST=G;e.Fx=z;e.Series=x;e.SVGElement=B;e.dateFormat=C.dateFormat;e.format=C.format;e.numberFormat=C.numberFormat;e.defaultOptions=I.defaultOptions;e.getOptions=I.getOptions;e.time=I.defaultTime;e.setOptions=I.setOptions;e.addEvent=b.addEvent;e.arrayMax=b.arrayMax;e.arrayMin=b.arrayMin;e.attr=b.attr;e.clearTimeout=b.clearTimeout;e.correctFloat=b.correctFloat;e.createElement=b.createElement;e.css=b.css;e.defined=
b.defined;e.destroyObjectProperties=b.destroyObjectProperties;e.discardElement=b.discardElement;e.erase=b.erase;e.error=b.error;e.extend=b.extend;e.extendClass=b.extendClass;e.find=b.find;e.fireEvent=b.fireEvent;e.getMagnitude=b.getMagnitude;e.getStyle=b.getStyle;e.inArray=b.inArray;e.isArray=b.isArray;e.isClass=b.isClass;e.isDOMElement=b.isDOMElement;e.isFunction=b.isFunction;e.isNumber=b.isNumber;e.isObject=b.isObject;e.isString=b.isString;e.keys=b.keys;e.merge=b.merge;e.normalizeTickInterval=b.normalizeTickInterval;
e.objectEach=b.objectEach;e.offset=b.offset;e.pad=b.pad;e.pick=b.pick;e.pInt=b.pInt;e.relativeLength=b.relativeLength;e.removeEvent=b.removeEvent;e.splat=b.splat;e.stableSort=b.stableSort;e.syncTimeout=b.syncTimeout;e.timeUnits=b.timeUnits;e.uniqueKey=b.uniqueKey;e.useSerialIds=b.useSerialIds;e.wrap=b.wrap;return e});e["masters/highcharts.src.js"]._modules=e;return e["masters/highcharts.src.js"]});

},{}],73:[function(require,module,exports){
(function (global){(function (){
/*!
 *  howler.js v2.2.3
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */
  var HowlerGlobal = function() {
    this.init();
  };
  HowlerGlobal.prototype = {
    /**
     * Initialize the global Howler object.
     * @return {Howler}
     */
    init: function() {
      var self = this || Howler;

      // Create a global ID counter.
      self._counter = 1000;

      // Pool of unlocked HTML5 Audio objects.
      self._html5AudioPool = [];
      self.html5PoolSize = 10;

      // Internal properties.
      self._codecs = {};
      self._howls = [];
      self._muted = false;
      self._volume = 1;
      self._canPlayEvent = 'canplaythrough';
      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;

      // Public properties.
      self.masterGain = null;
      self.noAudio = false;
      self.usingWebAudio = true;
      self.autoSuspend = true;
      self.ctx = null;

      // Set to false to disable the auto audio unlocker.
      self.autoUnlock = true;

      // Setup the various state values for global tracking.
      self._setup();

      return self;
    },

    /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */
    volume: function(vol) {
      var self = this || Howler;
      vol = parseFloat(vol);

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        self._volume = vol;

        // Don't update any of the nodes if we are muted.
        if (self._muted) {
          return self;
        }

        // When using Web Audio, we just need to adjust the master gain.
        if (self.usingWebAudio) {
          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
        }

        // Loop through and change volume for all HTML5 audio nodes.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and change the volumes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node) {
                sound._node.volume = sound._volume * vol;
              }
            }
          }
        }

        return self;
      }

      return self._volume;
    },

    /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */
    mute: function(muted) {
      var self = this || Howler;

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      self._muted = muted;

      // With Web Audio, we just need to mute the master gain.
      if (self.usingWebAudio) {
        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);
      }

      // Loop through and mute all HTML5 Audio nodes.
      for (var i=0; i<self._howls.length; i++) {
        if (!self._howls[i]._webAudio) {
          // Get all of the sounds in this Howl group.
          var ids = self._howls[i]._getSoundIds();

          // Loop through all sounds and mark the audio node as muted.
          for (var j=0; j<ids.length; j++) {
            var sound = self._howls[i]._soundById(ids[j]);

            if (sound && sound._node) {
              sound._node.muted = (muted) ? true : sound._muted;
            }
          }
        }
      }

      return self;
    },

    /**
     * Handle stopping all sounds globally.
     */
    stop: function() {
      var self = this || Howler;

      // Loop through all Howls and stop them.
      for (var i=0; i<self._howls.length; i++) {
        self._howls[i].stop();
      }

      return self;
    },

    /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
    unload: function() {
      var self = this || Howler;

      for (var i=self._howls.length-1; i>=0; i--) {
        self._howls[i].unload();
      }

      // Create a new AudioContext to make sure it is fully reset.
      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
        self.ctx.close();
        self.ctx = null;
        setupAudioContext();
      }

      return self;
    },

    /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */
    codecs: function(ext) {
      return (this || Howler)._codecs[ext.replace(/^x-/, '')];
    },

    /**
     * Setup various state values for global tracking.
     * @return {Howler}
     */
    _setup: function() {
      var self = this || Howler;

      // Keeps track of the suspend/resume state of the AudioContext.
      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';

      // Automatically begin the 30-second suspend process
      self._autoSuspend();

      // Check if audio is available.
      if (!self.usingWebAudio) {
        // No audio is available on this system if noAudio is set to true.
        if (typeof Audio !== 'undefined') {
          try {
            var test = new Audio();

            // Check if the canplaythrough event is available.
            if (typeof test.oncanplaythrough === 'undefined') {
              self._canPlayEvent = 'canplay';
            }
          } catch(e) {
            self.noAudio = true;
          }
        } else {
          self.noAudio = true;
        }
      }

      // Test to make sure audio isn't disabled in Internet Explorer.
      try {
        var test = new Audio();
        if (test.muted) {
          self.noAudio = true;
        }
      } catch (e) {}

      // Check for supported codecs.
      if (!self.noAudio) {
        self._setupCodecs();
      }

      return self;
    },

    /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */
    _setupCodecs: function() {
      var self = this || Howler;
      var audioTest = null;

      // Must wrap in a try/catch because IE11 in server mode throws an error.
      try {
        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
      } catch (err) {
        return self;
      }

      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
        return self;
      }

      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');

      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
      var ua = self._navigator ? self._navigator.userAgent : '';
      var checkOpera = ua.match(/OPR\/([0-6].)/g);
      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);
      var checkSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;
      var safariVersion = ua.match(/Version\/(.*?) /);
      var isOldSafari = (checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15);

      self._codecs = {
        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
        mpeg: !!mpegTest,
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),
        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
        webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
      };

      return self;
    },

    /**
     * Some browsers/devices will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */
    _unlockAudio: function() {
      var self = this || Howler;

      // Only run this if Web Audio is supported and it hasn't already been unlocked.
      if (self._audioUnlocked || !self.ctx) {
        return;
      }

      self._audioUnlocked = false;
      self.autoUnlock = false;

      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
        self._mobileUnloaded = true;
        self.unload();
      }

      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
      // http://stackoverflow.com/questions/24119684
      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);

      // Call this method on touch start to create and play a buffer,
      // then check if the audio actually played to determine if
      // audio has now been unlocked on iOS, Android, etc.
      var unlock = function(e) {
        // Create a pool of unlocked HTML5 Audio objects that can
        // be used for playing sounds without user interaction. HTML5
        // Audio objects must be individually unlocked, as opposed
        // to the WebAudio API which only needs a single activation.
        // This must occur before WebAudio setup or the source.onended
        // event will not fire.
        while (self._html5AudioPool.length < self.html5PoolSize) {
          try {
            var audioNode = new Audio();

            // Mark this Audio object as unlocked to ensure it can get returned
            // to the unlocked pool when released.
            audioNode._unlocked = true;

            // Add the audio node to the pool.
            self._releaseHtml5Audio(audioNode);
          } catch (e) {
            self.noAudio = true;
            break;
          }
        }

        // Loop through any assigned audio nodes and unlock them.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and unlock the audio nodes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node && !sound._node._unlocked) {
                sound._node._unlocked = true;
                sound._node.load();
              }
            }
          }
        }

        // Fix Android can not play in suspend state.
        self._autoResume();

        // Create an empty buffer.
        var source = self.ctx.createBufferSource();
        source.buffer = self._scratchBuffer;
        source.connect(self.ctx.destination);

        // Play the empty buffer.
        if (typeof source.start === 'undefined') {
          source.noteOn(0);
        } else {
          source.start(0);
        }

        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
        if (typeof self.ctx.resume === 'function') {
          self.ctx.resume();
        }

        // Setup a timeout to check that we are unlocked on the next event loop.
        source.onended = function() {
          source.disconnect(0);

          // Update the unlocked state and prevent this check from happening again.
          self._audioUnlocked = true;

          // Remove the touch start listener.
          document.removeEventListener('touchstart', unlock, true);
          document.removeEventListener('touchend', unlock, true);
          document.removeEventListener('click', unlock, true);
          document.removeEventListener('keydown', unlock, true);

          // Let all sounds know that audio has been unlocked.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('unlock');
          }
        };
      };

      // Setup a touch start listener to attempt an unlock in.
      document.addEventListener('touchstart', unlock, true);
      document.addEventListener('touchend', unlock, true);
      document.addEventListener('click', unlock, true);
      document.addEventListener('keydown', unlock, true);

      return self;
    },

    /**
     * Get an unlocked HTML5 Audio object from the pool. If none are left,
     * return a new Audio object and throw a warning.
     * @return {Audio} HTML5 Audio object.
     */
    _obtainHtml5Audio: function() {
      var self = this || Howler;

      // Return the next object from the pool if one exists.
      if (self._html5AudioPool.length) {
        return self._html5AudioPool.pop();
      }

      //.Check if the audio is locked and throw a warning.
      var testPlay = new Audio().play();
      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {
        testPlay.catch(function() {
          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');
        });
      }

      return new Audio();
    },

    /**
     * Return an activated HTML5 Audio object to the pool.
     * @return {Howler}
     */
    _releaseHtml5Audio: function(audio) {
      var self = this || Howler;

      // Don't add audio to the pool if we don't know if it has been unlocked.
      if (audio._unlocked) {
        self._html5AudioPool.push(audio);
      }

      return self;
    },

    /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */
    _autoSuspend: function() {
      var self = this;

      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      // Check if any sounds are playing.
      for (var i=0; i<self._howls.length; i++) {
        if (self._howls[i]._webAudio) {
          for (var j=0; j<self._howls[i]._sounds.length; j++) {
            if (!self._howls[i]._sounds[j]._paused) {
              return self;
            }
          }
        }
      }

      if (self._suspendTimer) {
        clearTimeout(self._suspendTimer);
      }

      // If no sound has played after 30 seconds, suspend the context.
      self._suspendTimer = setTimeout(function() {
        if (!self.autoSuspend) {
          return;
        }

        self._suspendTimer = null;
        self.state = 'suspending';

        // Handle updating the state of the audio context after suspending.
        var handleSuspension = function() {
          self.state = 'suspended';

          if (self._resumeAfterSuspend) {
            delete self._resumeAfterSuspend;
            self._autoResume();
          }
        };

        // Either the state gets suspended or it is interrupted.
        // Either way, we need to update the state to suspended.
        self.ctx.suspend().then(handleSuspension, handleSuspension);
      }, 30000);

      return self;
    },

    /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */
    _autoResume: function() {
      var self = this;

      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {
        clearTimeout(self._suspendTimer);
        self._suspendTimer = null;
      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {
        self.ctx.resume().then(function() {
          self.state = 'running';

          // Emit to all Howls that the audio has resumed.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('resume');
          }
        });

        if (self._suspendTimer) {
          clearTimeout(self._suspendTimer);
          self._suspendTimer = null;
        }
      } else if (self.state === 'suspending') {
        self._resumeAfterSuspend = true;
      }

      return self;
    }
  };

  // Setup the global audio controller.
  var Howler = new HowlerGlobal();

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Create an audio group controller.
   * @param {Object} o Passed in properties for this group.
   */
  var Howl = function(o) {
    var self = this;

    // Throw an error if no source is provided.
    if (!o.src || o.src.length === 0) {
      console.error('An array of source files must be passed with any new Howl.');
      return;
    }

    self.init(o);
  };
  Howl.prototype = {
    /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */
    init: function(o) {
      var self = this;

      // If we don't have an AudioContext created yet, run the setup.
      if (!Howler.ctx) {
        setupAudioContext();
      }

      // Setup user-defined default properties.
      self._autoplay = o.autoplay || false;
      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
      self._html5 = o.html5 || false;
      self._muted = o.mute || false;
      self._loop = o.loop || false;
      self._pool = o.pool || 5;
      self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;
      self._rate = o.rate || 1;
      self._sprite = o.sprite || {};
      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
      self._volume = o.volume !== undefined ? o.volume : 1;
      self._xhr = {
        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',
        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,
      };

      // Setup all other default properties.
      self._duration = 0;
      self._state = 'unloaded';
      self._sounds = [];
      self._endTimers = {};
      self._queue = [];
      self._playLock = false;

      // Setup event listeners.
      self._onend = o.onend ? [{fn: o.onend}] : [];
      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
      self._onload = o.onload ? [{fn: o.onload}] : [];
      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];
      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];
      self._onresume = [];

      // Web Audio or HTML5 Audio?
      self._webAudio = Howler.usingWebAudio && !self._html5;

      // Automatically try to enable audio.
      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {
        Howler._unlockAudio();
      }

      // Keep track of this Howl group in the global controller.
      Howler._howls.push(self);

      // If they selected autoplay, add a play event to the load queue.
      if (self._autoplay) {
        self._queue.push({
          event: 'play',
          action: function() {
            self.play();
          }
        });
      }

      // Load the source file unless otherwise specified.
      if (self._preload && self._preload !== 'none') {
        self.load();
      }

      return self;
    },

    /**
     * Load the audio file.
     * @return {Howler}
     */
    load: function() {
      var self = this;
      var url = null;

      // If no audio is available, quit immediately.
      if (Howler.noAudio) {
        self._emit('loaderror', null, 'No audio support.');
        return;
      }

      // Make sure our source is in an array.
      if (typeof self._src === 'string') {
        self._src = [self._src];
      }

      // Loop through the sources and pick the first one that is compatible.
      for (var i=0; i<self._src.length; i++) {
        var ext, str;

        if (self._format && self._format[i]) {
          // If an extension was specified, use that instead.
          ext = self._format[i];
        } else {
          // Make sure the source is a string.
          str = self._src[i];
          if (typeof str !== 'string') {
            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
            continue;
          }

          // Extract the file extension from the URL or base64 data URI.
          ext = /^data:audio\/([^;,]+);/i.exec(str);
          if (!ext) {
            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
          }

          if (ext) {
            ext = ext[1].toLowerCase();
          }
        }

        // Log a warning if no extension was found.
        if (!ext) {
          console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
        }

        // Check if this extension is available.
        if (ext && Howler.codecs(ext)) {
          url = self._src[i];
          break;
        }
      }

      if (!url) {
        self._emit('loaderror', null, 'No codec support for selected audio sources.');
        return;
      }

      self._src = url;
      self._state = 'loading';

      // If the hosting page is HTTPS and the source isn't,
      // drop down to HTML5 Audio to avoid Mixed Content errors.
      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
        self._html5 = true;
        self._webAudio = false;
      }

      // Create a new sound object and add it to the pool.
      new Sound(self);

      // Load and decode the audio data for playback.
      if (self._webAudio) {
        loadBuffer(self);
      }

      return self;
    },

    /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Number}          Sound ID.
     */
    play: function(sprite, internal) {
      var self = this;
      var id = null;

      // Determine if a sprite, sound id or nothing was passed
      if (typeof sprite === 'number') {
        id = sprite;
        sprite = null;
      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
        // If the passed sprite doesn't exist, do nothing.
        return null;
      } else if (typeof sprite === 'undefined') {
        // Use the default sound sprite (plays the full audio length).
        sprite = '__default';

        // Check if there is a single paused sound that isn't ended.
        // If there is, play that sound. If not, continue as usual.
        if (!self._playLock) {
          var num = 0;
          for (var i=0; i<self._sounds.length; i++) {
            if (self._sounds[i]._paused && !self._sounds[i]._ended) {
              num++;
              id = self._sounds[i]._id;
            }
          }

          if (num === 1) {
            sprite = null;
          } else {
            id = null;
          }
        }
      }

      // Get the selected node, or get one from the pool.
      var sound = id ? self._soundById(id) : self._inactiveSound();

      // If the sound doesn't exist, do nothing.
      if (!sound) {
        return null;
      }

      // Select the sprite definition.
      if (id && !sprite) {
        sprite = sound._sprite || '__default';
      }

      // If the sound hasn't loaded, we must wait to get the audio's duration.
      // We also need to wait to make sure we don't run into race conditions with
      // the order of function calls.
      if (self._state !== 'loaded') {
        // Set the sprite value on this sound.
        sound._sprite = sprite;

        // Mark this sound as not ended in case another sound is played before this one loads.
        sound._ended = false;

        // Add the sound to the queue to be played on load.
        var soundId = sound._id;
        self._queue.push({
          event: 'play',
          action: function() {
            self.play(soundId);
          }
        });

        return soundId;
      }

      // Don't play the sound if an id was passed and it is already playing.
      if (id && !sound._paused) {
        // Trigger the play event, in order to keep iterating through queue.
        if (!internal) {
          self._loadQueue('play');
        }

        return sound._id;
      }

      // Make sure the AudioContext isn't suspended, and resume it if it is.
      if (self._webAudio) {
        Howler._autoResume();
      }

      // Determine how long to play for and where to start playing.
      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);
      var timeout = (duration * 1000) / Math.abs(sound._rate);
      var start = self._sprite[sprite][0] / 1000;
      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
      sound._sprite = sprite;

      // Mark the sound as ended instantly so that this async playback
      // doesn't get grabbed by another call to play while this one waits to start.
      sound._ended = false;

      // Update the parameters of the sound.
      var setParams = function() {
        sound._paused = false;
        sound._seek = seek;
        sound._start = start;
        sound._stop = stop;
        sound._loop = !!(sound._loop || self._sprite[sprite][2]);
      };

      // End the sound instantly if seek is at the end.
      if (seek >= stop) {
        self._ended(sound);
        return;
      }

      // Begin the actual playback.
      var node = sound._node;
      if (self._webAudio) {
        // Fire this when the sound is ready to play to begin Web Audio playback.
        var playWebAudio = function() {
          self._playLock = false;
          setParams();
          self._refreshBuffer(sound);

          // Setup the playback params.
          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
          sound._playStart = Howler.ctx.currentTime;

          // Play the sound using the supported method.
          if (typeof node.bufferSource.start === 'undefined') {
            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
          } else {
            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
          }

          // Start a new timer if none is present.
          if (timeout !== Infinity) {
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }

          if (!internal) {
            setTimeout(function() {
              self._emit('play', sound._id);
              self._loadQueue();
            }, 0);
          }
        };

        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {
          playWebAudio();
        } else {
          self._playLock = true;

          // Wait for the audio context to resume before playing.
          self.once('resume', playWebAudio);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      } else {
        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
        var playHtml5 = function() {
          node.currentTime = seek;
          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
          node.volume = sound._volume * Howler.volume();
          node.playbackRate = sound._rate;

          // Some browsers will throw an error if this is called without user interaction.
          try {
            var play = node.play();

            // Support older browsers that don't support promises, and thus don't have this issue.
            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {
              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
              self._playLock = true;

              // Set param values immediately.
              setParams();

              // Releases the lock and executes queued actions.
              play
                .then(function() {
                  self._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self._emit('play', sound._id);
                  } else {
                    self._loadQueue();
                  }
                })
                .catch(function() {
                  self._playLock = false;
                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                    'on mobile devices and Chrome where playback was not within a user interaction.');

                  // Reset the ended and paused values.
                  sound._ended = true;
                  sound._paused = true;
                });
            } else if (!internal) {
              self._playLock = false;
              setParams();
              self._emit('play', sound._id);
            }

            // Setting rate before playing won't work in IE, so we set it again here.
            node.playbackRate = sound._rate;

            // If the node is still paused, then we can assume there was a playback issue.
            if (node.paused) {
              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                'on mobile devices and Chrome where playback was not within a user interaction.');
              return;
            }

            // Setup the end timer on sprites or listen for the ended event.
            if (sprite !== '__default' || sound._loop) {
              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
            } else {
              self._endTimers[sound._id] = function() {
                // Fire ended on this audio node.
                self._ended(sound);

                // Clear this listener.
                node.removeEventListener('ended', self._endTimers[sound._id], false);
              };
              node.addEventListener('ended', self._endTimers[sound._id], false);
            }
          } catch (err) {
            self._emit('playerror', sound._id, err);
          }
        };

        // If this is streaming audio, make sure the src is set and load again.
        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {
          node.src = self._src;
          node.load();
        }

        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);
        if (node.readyState >= 3 || loadedNoReadyState) {
          playHtml5();
        } else {
          self._playLock = true;
          self._state = 'loading';

          var listener = function() {
            self._state = 'loaded';
            
            // Begin playback.
            playHtml5();

            // Clear this listener.
            node.removeEventListener(Howler._canPlayEvent, listener, false);
          };
          node.addEventListener(Howler._canPlayEvent, listener, false);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      }

      return sound._id;
    },

    /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */
    pause: function(id) {
      var self = this;

      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'pause',
          action: function() {
            self.pause(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be paused.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound && !sound._paused) {
          // Reset the seek position.
          sound._seek = self.seek(ids[i]);
          sound._rateSeek = 0;
          sound._paused = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound has been created.
              if (!sound._node.bufferSource) {
                continue;
              }

              if (typeof sound._node.bufferSource.stop === 'undefined') {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              }

              // Clean up the buffer source.
              self._cleanBuffer(sound._node);
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.pause();
            }
          }
        }

        // Fire the pause event, unless `true` is passed as the 2nd argument.
        if (!arguments[1]) {
          self._emit('pause', sound ? sound._id : null);
        }
      }

      return self;
    },

    /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Howl}
     */
    stop: function(id, internal) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to stop when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'stop',
          action: function() {
            self.stop(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be stopped.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          // Reset the seek position.
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._paused = true;
          sound._ended = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound's AudioBufferSourceNode has been created.
              if (sound._node.bufferSource) {
                if (typeof sound._node.bufferSource.stop === 'undefined') {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                }

                // Clean up the buffer source.
                self._cleanBuffer(sound._node);
              }
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.currentTime = sound._start || 0;
              sound._node.pause();

              // If this is a live stream, stop download once the audio is stopped.
              if (sound._node.duration === Infinity) {
                self._clearSound(sound._node);
              }
            }
          }

          if (!internal) {
            self._emit('stop', sound._id);
          }
        }
      }

      return self;
    },

    /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */
    mute: function(muted, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to mute when capable.
      if (self._state !== 'loaded'|| self._playLock) {
        self._queue.push({
          event: 'mute',
          action: function() {
            self.mute(muted, id);
          }
        });

        return self;
      }

      // If applying mute/unmute to all sounds, update the group's value.
      if (typeof id === 'undefined') {
        if (typeof muted === 'boolean') {
          self._muted = muted;
        } else {
          return self._muted;
        }
      }

      // If no id is passed, get all ID's to be muted.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          sound._muted = muted;

          // Cancel active fade and set the volume to the end value.
          if (sound._interval) {
            self._stopFade(sound._id);
          }

          if (self._webAudio && sound._node) {
            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
          } else if (sound._node) {
            sound._node.muted = Howler._muted ? true : muted;
          }

          self._emit('mute', sound._id);
        }
      }

      return self;
    },

    /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */
    volume: function() {
      var self = this;
      var args = arguments;
      var vol, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // Return the value of the groups' volume.
        return self._volume;
      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
        // First check if this is an ID, and if not, assume it is a new volume.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          vol = parseFloat(args[0]);
        }
      } else if (args.length >= 2) {
        vol = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the volume or return the current volume.
      var sound;
      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
        if (self._state !== 'loaded'|| self._playLock) {
          self._queue.push({
            event: 'volume',
            action: function() {
              self.volume.apply(self, args);
            }
          });

          return self;
        }

        // Set the group volume.
        if (typeof id === 'undefined') {
          self._volume = vol;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            sound._volume = vol;

            // Stop currently running fades.
            if (!args[2]) {
              self._stopFade(id[i]);
            }

            if (self._webAudio && sound._node && !sound._muted) {
              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
            } else if (sound._node && !sound._muted) {
              sound._node.volume = vol * Howler.volume();
            }

            self._emit('volume', sound._id);
          }
        }
      } else {
        sound = id ? self._soundById(id) : self._sounds[0];
        return sound ? sound._volume : 0;
      }

      return self;
    },

    /**
     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */
    fade: function(from, to, len, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to fade when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'fade',
          action: function() {
            self.fade(from, to, len, id);
          }
        });

        return self;
      }

      // Make sure the to/from/len values are numbers.
      from = Math.min(Math.max(0, parseFloat(from)), 1);
      to = Math.min(Math.max(0, parseFloat(to)), 1);
      len = parseFloat(len);

      // Set the volume to the start position.
      self.volume(from, id);

      // Fade the volume of one or all sounds.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        // Create a linear fade or fall back to timeouts with HTML5 Audio.
        if (sound) {
          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
          if (!id) {
            self._stopFade(ids[i]);
          }

          // If we are using Web Audio, let the native methods do the actual fade.
          if (self._webAudio && !sound._muted) {
            var currentTime = Howler.ctx.currentTime;
            var end = currentTime + (len / 1000);
            sound._volume = from;
            sound._node.gain.setValueAtTime(from, currentTime);
            sound._node.gain.linearRampToValueAtTime(to, end);
          }

          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');
        }
      }

      return self;
    },

    /**
     * Starts the internal interval to fade a sound.
     * @param  {Object} sound Reference to sound to fade.
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id to fade.
     * @param  {Boolean} isGroup   If true, set the volume on the group.
     */
    _startFadeInterval: function(sound, from, to, len, id, isGroup) {
      var self = this;
      var vol = from;
      var diff = to - from;
      var steps = Math.abs(diff / 0.01);
      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);
      var lastTick = Date.now();

      // Store the value being faded to.
      sound._fadeTo = to;

      // Update the volume value on each interval tick.
      sound._interval = setInterval(function() {
        // Update the volume based on the time since the last tick.
        var tick = (Date.now() - lastTick) / len;
        lastTick = Date.now();
        vol += diff * tick;

        // Round to within 2 decimal points.
        vol = Math.round(vol * 100) / 100;

        // Make sure the volume is in the right bounds.
        if (diff < 0) {
          vol = Math.max(to, vol);
        } else {
          vol = Math.min(to, vol);
        }

        // Change the volume.
        if (self._webAudio) {
          sound._volume = vol;
        } else {
          self.volume(vol, sound._id, true);
        }

        // Set the group's volume.
        if (isGroup) {
          self._volume = vol;
        }

        // When the fade is complete, stop it and fire event.
        if ((to < from && vol <= to) || (to > from && vol >= to)) {
          clearInterval(sound._interval);
          sound._interval = null;
          sound._fadeTo = null;
          self.volume(to, sound._id);
          self._emit('fade', sound._id);
        }
      }, stepLen);
    },

    /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */
    _stopFade: function(id) {
      var self = this;
      var sound = self._soundById(id);

      if (sound && sound._interval) {
        if (self._webAudio) {
          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
        }

        clearInterval(sound._interval);
        sound._interval = null;
        self.volume(sound._fadeTo, id);
        sound._fadeTo = null;
        self._emit('fade', id);
      }

      return self;
    },

    /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */
    loop: function() {
      var self = this;
      var args = arguments;
      var loop, id, sound;

      // Determine the values for loop and id.
      if (args.length === 0) {
        // Return the grou's loop value.
        return self._loop;
      } else if (args.length === 1) {
        if (typeof args[0] === 'boolean') {
          loop = args[0];
          self._loop = loop;
        } else {
          // Return this sound's loop value.
          sound = self._soundById(parseInt(args[0], 10));
          return sound ? sound._loop : false;
        }
      } else if (args.length === 2) {
        loop = args[0];
        id = parseInt(args[1], 10);
      }

      // If no id is passed, get all ID's to be looped.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        sound = self._soundById(ids[i]);

        if (sound) {
          sound._loop = loop;
          if (self._webAudio && sound._node && sound._node.bufferSource) {
            sound._node.bufferSource.loop = loop;
            if (loop) {
              sound._node.bufferSource.loopStart = sound._start || 0;
              sound._node.bufferSource.loopEnd = sound._stop;

              // If playing, restart playback to ensure looping updates.
              if (self.playing(ids[i])) {
                self.pause(ids[i], true);
                self.play(ids[i], true);
              }
            }
          }
        }
      }

      return self;
    },

    /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */
    rate: function() {
      var self = this;
      var args = arguments;
      var rate, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current rate of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new rate value.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          rate = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        rate = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the playback rate or return the current value.
      var sound;
      if (typeof rate === 'number') {
        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
        if (self._state !== 'loaded' || self._playLock) {
          self._queue.push({
            event: 'rate',
            action: function() {
              self.rate.apply(self, args);
            }
          });

          return self;
        }

        // Set the group rate.
        if (typeof id === 'undefined') {
          self._rate = rate;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            // Keep track of our position when the rate changed and update the playback
            // start position so we can properly adjust the seek position for time elapsed.
            if (self.playing(id[i])) {
              sound._rateSeek = self.seek(id[i]);
              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
            }
            sound._rate = rate;

            // Change the playback rate.
            if (self._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
            } else if (sound._node) {
              sound._node.playbackRate = rate;
            }

            // Reset the timers.
            var seek = self.seek(id[i]);
            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
            var timeout = (duration * 1000) / Math.abs(sound._rate);

            // Start a new end timer if sound is already playing.
            if (self._endTimers[id[i]] || !sound._paused) {
              self._clearTimer(id[i]);
              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
            }

            self._emit('rate', sound._id);
          }
        }
      } else {
        sound = self._soundById(id);
        return sound ? sound._rate : self._rate;
      }

      return self;
    },

    /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */
    seek: function() {
      var self = this;
      var args = arguments;
      var seek, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current position of the first node.
        if (self._sounds.length) {
          id = self._sounds[0]._id;
        }
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new seek position.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else if (self._sounds.length) {
          id = self._sounds[0]._id;
          seek = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        seek = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // If there is no ID, bail out.
      if (typeof id === 'undefined') {
        return 0;
      }

      // If the sound hasn't loaded, add it to the load queue to seek when capable.
      if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {
        self._queue.push({
          event: 'seek',
          action: function() {
            self.seek.apply(self, args);
          }
        });

        return self;
      }

      // Get the sound.
      var sound = self._soundById(id);

      if (sound) {
        if (typeof seek === 'number' && seek >= 0) {
          // Pause the sound and update position for restarting playback.
          var playing = self.playing(id);
          if (playing) {
            self.pause(id, true);
          }

          // Move the position of the track and cancel timer.
          sound._seek = seek;
          sound._ended = false;
          self._clearTimer(id);

          // Update the seek position for HTML5 Audio.
          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
            sound._node.currentTime = seek;
          }

          // Seek and emit when ready.
          var seekAndEmit = function() {
            // Restart the playback if the sound was playing.
            if (playing) {
              self.play(id, true);
            }

            self._emit('seek', id);
          };

          // Wait for the play lock to be unset before emitting (HTML5 Audio).
          if (playing && !self._webAudio) {
            var emitSeek = function() {
              if (!self._playLock) {
                seekAndEmit();
              } else {
                setTimeout(emitSeek, 0);
              }
            };
            setTimeout(emitSeek, 0);
          } else {
            seekAndEmit();
          }
        } else {
          if (self._webAudio) {
            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
          } else {
            return sound._node.currentTime;
          }
        }
      }

      return self;
    },

    /**
     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
     * @return {Boolean} True if playing and false if not.
     */
    playing: function(id) {
      var self = this;

      // Check the passed sound ID (if any).
      if (typeof id === 'number') {
        var sound = self._soundById(id);
        return sound ? !sound._paused : false;
      }

      // Otherwise, loop through all sounds and check if any are playing.
      for (var i=0; i<self._sounds.length; i++) {
        if (!self._sounds[i]._paused) {
          return true;
        }
      }

      return false;
    },

    /**
     * Get the duration of this sound. Passing a sound id will return the sprite duration.
     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
     * @return {Number} Audio duration in seconds.
     */
    duration: function(id) {
      var self = this;
      var duration = self._duration;

      // If we pass an ID, get the sound and return the sprite length.
      var sound = self._soundById(id);
      if (sound) {
        duration = self._sprite[sound._sprite][1] / 1000;
      }

      return duration;
    },

    /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */
    state: function() {
      return this._state;
    },

    /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */
    unload: function() {
      var self = this;

      // Stop playing any active sounds.
      var sounds = self._sounds;
      for (var i=0; i<sounds.length; i++) {
        // Stop the sound if it is currently playing.
        if (!sounds[i]._paused) {
          self.stop(sounds[i]._id);
        }

        // Remove the source or disconnect.
        if (!self._webAudio) {
          // Set the source to 0-second silence to stop any downloading (except in IE).
          self._clearSound(sounds[i]._node);

          // Remove any event listeners.
          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
          sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);

          // Release the Audio object back to the pool.
          Howler._releaseHtml5Audio(sounds[i]._node);
        }

        // Empty out all of the nodes.
        delete sounds[i]._node;

        // Make sure all timers are cleared out.
        self._clearTimer(sounds[i]._id);
      }

      // Remove the references in the global Howler object.
      var index = Howler._howls.indexOf(self);
      if (index >= 0) {
        Howler._howls.splice(index, 1);
      }

      // Delete this sound from the cache (if no other Howl is using it).
      var remCache = true;
      for (i=0; i<Howler._howls.length; i++) {
        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {
          remCache = false;
          break;
        }
      }

      if (cache && remCache) {
        delete cache[self._src];
      }

      // Clear global errors.
      Howler.noAudio = false;

      // Clear out `self`.
      self._state = 'unloaded';
      self._sounds = [];
      self = null;

      return null;
    },

    /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */
    on: function(event, fn, id, once) {
      var self = this;
      var events = self['_on' + event];

      if (typeof fn === 'function') {
        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
      }

      return self;
    },

    /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */
    off: function(event, fn, id) {
      var self = this;
      var events = self['_on' + event];
      var i = 0;

      // Allow passing just an event and ID.
      if (typeof fn === 'number') {
        id = fn;
        fn = null;
      }

      if (fn || id) {
        // Loop through event store and remove the passed function.
        for (i=0; i<events.length; i++) {
          var isId = (id === events[i].id);
          if (fn === events[i].fn && isId || !fn && isId) {
            events.splice(i, 1);
            break;
          }
        }
      } else if (event) {
        // Clear out all events of this type.
        self['_on' + event] = [];
      } else {
        // Clear out all events of every type.
        var keys = Object.keys(self);
        for (i=0; i<keys.length; i++) {
          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
            self[keys[i]] = [];
          }
        }
      }

      return self;
    },

    /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */
    once: function(event, fn, id) {
      var self = this;

      // Setup the event listener.
      self.on(event, fn, id, 1);

      return self;
    },

    /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */
    _emit: function(event, id, msg) {
      var self = this;
      var events = self['_on' + event];

      // Loop through event store and fire all functions.
      for (var i=events.length-1; i>=0; i--) {
        // Only fire the listener if the correct ID is used.
        if (!events[i].id || events[i].id === id || event === 'load') {
          setTimeout(function(fn) {
            fn.call(this, id, msg);
          }.bind(self, events[i].fn), 0);

          // If this event was setup with `once`, remove it.
          if (events[i].once) {
            self.off(event, events[i].fn, events[i].id);
          }
        }
      }

      // Pass the event type into load queue so that it can continue stepping.
      self._loadQueue(event);

      return self;
    },

    /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */
    _loadQueue: function(event) {
      var self = this;

      if (self._queue.length > 0) {
        var task = self._queue[0];

        // Remove this task if a matching event was passed.
        if (task.event === event) {
          self._queue.shift();
          self._loadQueue();
        }

        // Run the task if no event type is passed.
        if (!event) {
          task.action();
        }
      }

      return self;
    },

    /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _ended: function(sound) {
      var self = this;
      var sprite = sound._sprite;

      // If we are using IE and there was network latency we may be clipping
      // audio before it completes playing. Lets check the node to make sure it
      // believes it has completed, before ending the playback.
      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
        setTimeout(self._ended.bind(self, sound), 100);
        return self;
      }

      // Should this sound loop?
      var loop = !!(sound._loop || self._sprite[sprite][2]);

      // Fire the ended event.
      self._emit('end', sound._id);

      // Restart the playback for HTML5 Audio loop.
      if (!self._webAudio && loop) {
        self.stop(sound._id, true).play(sound._id);
      }

      // Restart this timer if on a Web Audio loop.
      if (self._webAudio && loop) {
        self._emit('play', sound._id);
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        sound._playStart = Howler.ctx.currentTime;

        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      }

      // Mark the node as paused.
      if (self._webAudio && !loop) {
        sound._paused = true;
        sound._ended = true;
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        self._clearTimer(sound._id);

        // Clean up the buffer source.
        self._cleanBuffer(sound._node);

        // Attempt to auto-suspend AudioContext if no sounds are still playing.
        Howler._autoSuspend();
      }

      // When using a sprite, end the track.
      if (!self._webAudio && !loop) {
        self.stop(sound._id, true);
      }

      return self;
    },

    /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */
    _clearTimer: function(id) {
      var self = this;

      if (self._endTimers[id]) {
        // Clear the timeout or remove the ended listener.
        if (typeof self._endTimers[id] !== 'function') {
          clearTimeout(self._endTimers[id]);
        } else {
          var sound = self._soundById(id);
          if (sound && sound._node) {
            sound._node.removeEventListener('ended', self._endTimers[id], false);
          }
        }

        delete self._endTimers[id];
      }

      return self;
    },

    /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */
    _soundById: function(id) {
      var self = this;

      // Loop through all sounds and find the one with this ID.
      for (var i=0; i<self._sounds.length; i++) {
        if (id === self._sounds[i]._id) {
          return self._sounds[i];
        }
      }

      return null;
    },

    /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
    _inactiveSound: function() {
      var self = this;

      self._drain();

      // Find the first inactive node to recycle.
      for (var i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          return self._sounds[i].reset();
        }
      }

      // If no inactive node was found, create a new one.
      return new Sound(self);
    },

    /**
     * Drain excess inactive sounds from the pool.
     */
    _drain: function() {
      var self = this;
      var limit = self._pool;
      var cnt = 0;
      var i = 0;

      // If there are less sounds than the max pool size, we are done.
      if (self._sounds.length < limit) {
        return;
      }

      // Count the number of inactive sounds.
      for (i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          cnt++;
        }
      }

      // Remove excess inactive sounds, going in reverse order.
      for (i=self._sounds.length - 1; i>=0; i--) {
        if (cnt <= limit) {
          return;
        }

        if (self._sounds[i]._ended) {
          // Disconnect the audio source when using Web Audio.
          if (self._webAudio && self._sounds[i]._node) {
            self._sounds[i]._node.disconnect(0);
          }

          // Remove sounds until we have the pool size.
          self._sounds.splice(i, 1);
          cnt--;
        }
      }
    },

    /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */
    _getSoundIds: function(id) {
      var self = this;

      if (typeof id === 'undefined') {
        var ids = [];
        for (var i=0; i<self._sounds.length; i++) {
          ids.push(self._sounds[i]._id);
        }

        return ids;
      } else {
        return [id];
      }
    },

    /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _refreshBuffer: function(sound) {
      var self = this;

      // Setup the buffer source for playback.
      sound._node.bufferSource = Howler.ctx.createBufferSource();
      sound._node.bufferSource.buffer = cache[self._src];

      // Connect to the correct node.
      if (sound._panner) {
        sound._node.bufferSource.connect(sound._panner);
      } else {
        sound._node.bufferSource.connect(sound._node);
      }

      // Setup looping and playback rate.
      sound._node.bufferSource.loop = sound._loop;
      if (sound._loop) {
        sound._node.bufferSource.loopStart = sound._start || 0;
        sound._node.bufferSource.loopEnd = sound._stop || 0;
      }
      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);

      return self;
    },

    /**
     * Prevent memory leaks by cleaning up the buffer source after playback.
     * @param  {Object} node Sound's audio node containing the buffer source.
     * @return {Howl}
     */
    _cleanBuffer: function(node) {
      var self = this;
      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;

      if (Howler._scratchBuffer && node.bufferSource) {
        node.bufferSource.onended = null;
        node.bufferSource.disconnect(0);
        if (isIOS) {
          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}
        }
      }
      node.bufferSource = null;

      return self;
    },

    /**
     * Set the source to a 0-second silence to stop any downloading (except in IE).
     * @param  {Object} node Audio node to clear.
     */
    _clearSound: function(node) {
      var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
      if (!checkIE) {
        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
      }
    }
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */
  var Sound = function(howl) {
    this._parent = howl;
    this.init();
  };
  Sound.prototype = {
    /**
     * Initialize a new Sound object.
     * @return {Sound}
     */
    init: function() {
      var self = this;
      var parent = self._parent;

      // Setup the default parameters.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a unique ID for this sound.
      self._id = ++Howler._counter;

      // Add itself to the parent's pool.
      parent._sounds.push(self);

      // Create the new node.
      self.create();

      return self;
    },

    /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */
    create: function() {
      var self = this;
      var parent = self._parent;
      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;

      if (parent._webAudio) {
        // Create the gain node for controlling volume (the source will connect to this).
        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
        self._node.paused = true;
        self._node.connect(Howler.masterGain);
      } else if (!Howler.noAudio) {
        // Get an unlocked Audio object from the pool.
        self._node = Howler._obtainHtml5Audio();

        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
        self._errorFn = self._errorListener.bind(self);
        self._node.addEventListener('error', self._errorFn, false);

        // Listen for 'canplaythrough' event to let us know the sound is ready.
        self._loadFn = self._loadListener.bind(self);
        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);

        // Listen for the 'ended' event on the sound to account for edge-case where
        // a finite sound has a duration of Infinity.
        self._endFn = self._endListener.bind(self);
        self._node.addEventListener('ended', self._endFn, false);

        // Setup the new audio node.
        self._node.src = parent._src;
        self._node.preload = parent._preload === true ? 'auto' : parent._preload;
        self._node.volume = volume * Howler.volume();

        // Begin loading the source.
        self._node.load();
      }

      return self;
    },

    /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */
    reset: function() {
      var self = this;
      var parent = self._parent;

      // Reset all of the parameters of this sound.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._rateSeek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a new ID so that it isn't confused with the previous sound.
      self._id = ++Howler._counter;

      return self;
    },

    /**
     * HTML5 Audio error listener callback.
     */
    _errorListener: function() {
      var self = this;

      // Fire an error event and pass back the code.
      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);

      // Clear the event listener.
      self._node.removeEventListener('error', self._errorFn, false);
    },

    /**
     * HTML5 Audio canplaythrough listener callback.
     */
    _loadListener: function() {
      var self = this;
      var parent = self._parent;

      // Round up the duration to account for the lower precision in HTML5 Audio.
      parent._duration = Math.ceil(self._node.duration * 10) / 10;

      // Setup a sprite if none is defined.
      if (Object.keys(parent._sprite).length === 0) {
        parent._sprite = {__default: [0, parent._duration * 1000]};
      }

      if (parent._state !== 'loaded') {
        parent._state = 'loaded';
        parent._emit('load');
        parent._loadQueue();
      }

      // Clear the event listener.
      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
    },

    /**
     * HTML5 Audio ended listener callback.
     */
    _endListener: function() {
      var self = this;
      var parent = self._parent;

      // Only handle the `ended`` event if the duration is Infinity.
      if (parent._duration === Infinity) {
        // Update the parent duration to match the real audio duration.
        // Round up the duration to account for the lower precision in HTML5 Audio.
        parent._duration = Math.ceil(self._node.duration * 10) / 10;

        // Update the sprite that corresponds to the real duration.
        if (parent._sprite.__default[1] === Infinity) {
          parent._sprite.__default[1] = parent._duration * 1000;
        }

        // Run the regular ended method.
        parent._ended(self);
      }

      // Clear the event listener since the duration is now correct.
      self._node.removeEventListener('ended', self._endFn, false);
    }
  };

  /** Helper Methods **/
  /***************************************************************************/

  var cache = {};

  /**
   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
   * @param  {Howl} self
   */
  var loadBuffer = function(self) {
    var url = self._src;

    // Check if the buffer has already been cached and use it instead.
    if (cache[url]) {
      // Set the duration from the cache.
      self._duration = cache[url].duration;

      // Load the sound into this Howl.
      loadSound(self);

      return;
    }

    if (/^data:[^;]+;base64,/.test(url)) {
      // Decode the base64 data URI without XHR, since some browsers don't support it.
      var data = atob(url.split(',')[1]);
      var dataView = new Uint8Array(data.length);
      for (var i=0; i<data.length; ++i) {
        dataView[i] = data.charCodeAt(i);
      }

      decodeAudioData(dataView.buffer, self);
    } else {
      // Load the buffer from the URL.
      var xhr = new XMLHttpRequest();
      xhr.open(self._xhr.method, url, true);
      xhr.withCredentials = self._xhr.withCredentials;
      xhr.responseType = 'arraybuffer';

      // Apply any custom headers to the request.
      if (self._xhr.headers) {
        Object.keys(self._xhr.headers).forEach(function(key) {
          xhr.setRequestHeader(key, self._xhr.headers[key]);
        });
      }

      xhr.onload = function() {
        // Make sure we get a successful response back.
        var code = (xhr.status + '')[0];
        if (code !== '0' && code !== '2' && code !== '3') {
          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
          return;
        }

        decodeAudioData(xhr.response, self);
      };
      xhr.onerror = function() {
        // If there is an error, switch to HTML5 Audio.
        if (self._webAudio) {
          self._html5 = true;
          self._webAudio = false;
          self._sounds = [];
          delete cache[url];
          self.load();
        }
      };
      safeXhrSend(xhr);
    }
  };

  /**
   * Send the XHR request wrapped in a try/catch.
   * @param  {Object} xhr XHR to send.
   */
  var safeXhrSend = function(xhr) {
    try {
      xhr.send();
    } catch (e) {
      xhr.onerror();
    }
  };

  /**
   * Decode audio data from an array buffer.
   * @param  {ArrayBuffer} arraybuffer The audio data.
   * @param  {Howl}        self
   */
  var decodeAudioData = function(arraybuffer, self) {
    // Fire a load error if something broke.
    var error = function() {
      self._emit('loaderror', null, 'Decoding audio data failed.');
    };

    // Load the sound on success.
    var success = function(buffer) {
      if (buffer && self._sounds.length > 0) {
        cache[self._src] = buffer;
        loadSound(self, buffer);
      } else {
        error();
      }
    };

    // Decode the buffer into an audio source.
    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {
      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
    } else {
      Howler.ctx.decodeAudioData(arraybuffer, success, error);
    }
  }

  /**
   * Sound is now loaded, so finish setting everything up and fire the loaded event.
   * @param  {Howl} self
   * @param  {Object} buffer The decoded buffer sound source.
   */
  var loadSound = function(self, buffer) {
    // Set the duration.
    if (buffer && !self._duration) {
      self._duration = buffer.duration;
    }

    // Setup a sprite if none is defined.
    if (Object.keys(self._sprite).length === 0) {
      self._sprite = {__default: [0, self._duration * 1000]};
    }

    // Fire the loaded event.
    if (self._state !== 'loaded') {
      self._state = 'loaded';
      self._emit('load');
      self._loadQueue();
    }
  };

  /**
   * Setup the audio context when available, or switch to HTML5 Audio mode.
   */
  var setupAudioContext = function() {
    // If we have already detected that Web Audio isn't supported, don't run this step again.
    if (!Howler.usingWebAudio) {
      return;
    }

    // Check if we are using Web Audio and setup the AudioContext if we are.
    try {
      if (typeof AudioContext !== 'undefined') {
        Howler.ctx = new AudioContext();
      } else if (typeof webkitAudioContext !== 'undefined') {
        Howler.ctx = new webkitAudioContext();
      } else {
        Howler.usingWebAudio = false;
      }
    } catch(e) {
      Howler.usingWebAudio = false;
    }

    // If the audio context creation still failed, set using web audio to false.
    if (!Howler.ctx) {
      Howler.usingWebAudio = false;
    }

    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
    // If it is, disable Web Audio as it causes crashing.
    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
    var version = appVersion ? parseInt(appVersion[1], 10) : null;
    if (iOS && version && version < 9) {
      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
      if (Howler._navigator && !safari) {
        Howler.usingWebAudio = false;
      }
    }

    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
    if (Howler.usingWebAudio) {
      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);
      Howler.masterGain.connect(Howler.ctx.destination);
    }

    // Re-run the setup on Howler.
    Howler._setup();
  };

  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
  if (typeof define === 'function' && define.amd) {
    define([], function() {
      return {
        Howler: Howler,
        Howl: Howl
      };
    });
  }

  // Add support for CommonJS libraries such as browserify.
  if (typeof exports !== 'undefined') {
    exports.Howler = Howler;
    exports.Howl = Howl;
  }

  // Add to global in Node.js (for testing, etc).
  if (typeof global !== 'undefined') {
    global.HowlerGlobal = HowlerGlobal;
    global.Howler = Howler;
    global.Howl = Howl;
    global.Sound = Sound;
  } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.
    window.HowlerGlobal = HowlerGlobal;
    window.Howler = Howler;
    window.Howl = Howl;
    window.Sound = Sound;
  }
})();


/*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.2.3
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  // Setup default properties.
  HowlerGlobal.prototype._pos = [0, 0, 0];
  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Helper method to update the stereo panning position of all current Howls.
   * Future Howls will not use this value unless explicitly set.
   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
   * @return {Howler/Number}     Self or current stereo panning value.
   */
  HowlerGlobal.prototype.stereo = function(pan) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Loop through all Howls and update their stereo panning.
    for (var i=self._howls.length-1; i>=0; i--) {
      self._howls[i].stereo(pan);
    }

    return self;
  };

  /**
   * Get/set the position of the listener in 3D cartesian space. Sounds using
   * 3D position will be relative to the listener's position.
   * @param  {Number} x The x-position of the listener.
   * @param  {Number} y The y-position of the listener.
   * @param  {Number} z The z-position of the listener.
   * @return {Howler/Array}   Self or current listener position.
   */
  HowlerGlobal.prototype.pos = function(x, y, z) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._pos[1] : y;
    z = (typeof z !== 'number') ? self._pos[2] : z;

    if (typeof x === 'number') {
      self._pos = [x, y, z];

      if (typeof self.ctx.listener.positionX !== 'undefined') {
        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
      }
    } else {
      return self._pos;
    }

    return self;
  };

  /**
   * Get/set the direction the listener is pointing in the 3D cartesian space.
   * A front and up vector must be provided. The front is the direction the
   * face of the listener is pointing, and up is the direction the top of the
   * listener is pointing. Thus, these values are expected to be at right angles
   * from each other.
   * @param  {Number} x   The x-orientation of the listener.
   * @param  {Number} y   The y-orientation of the listener.
   * @param  {Number} z   The z-orientation of the listener.
   * @param  {Number} xUp The x-orientation of the top of the listener.
   * @param  {Number} yUp The y-orientation of the top of the listener.
   * @param  {Number} zUp The z-orientation of the top of the listener.
   * @return {Howler/Array}     Returns self or the current orientation vectors.
   */
  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    var or = self._orientation;
    y = (typeof y !== 'number') ? or[1] : y;
    z = (typeof z !== 'number') ? or[2] : z;
    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
    zUp = (typeof zUp !== 'number') ? or[5] : zUp;

    if (typeof x === 'number') {
      self._orientation = [x, y, z, xUp, yUp, zUp];

      if (typeof self.ctx.listener.forwardX !== 'undefined') {
        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
      }
    } else {
      return or;
    }

    return self;
  };

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core init.
   * @param  {Function} _super Core init method.
   * @return {Howl}
   */
  Howl.prototype.init = (function(_super) {
    return function(o) {
      var self = this;

      // Setup user-defined default properties.
      self._orientation = o.orientation || [1, 0, 0];
      self._stereo = o.stereo || null;
      self._pos = o.pos || null;
      self._pannerAttr = {
        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
      };

      // Setup event listeners.
      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];

      // Complete initilization with howler.js core's init function.
      return _super.call(this, o);
    };
  })(Howl.prototype.init);

  /**
   * Get/set the stereo panning of the audio source for this sound or all in the group.
   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Number}    Returns self or the current stereo panning value.
   */
  Howl.prototype.stereo = function(pan, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'stereo',
        action: function() {
          self.stereo(pan, id);
        }
      });

      return self;
    }

    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';

    // Setup the group's stereo panning if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's stereo panning if no parameters are passed.
      if (typeof pan === 'number') {
        self._stereo = pan;
        self._pos = [pan, 0, 0];
      } else {
        return self._stereo;
      }
    }

    // Change the streo panning of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof pan === 'number') {
          sound._stereo = pan;
          sound._pos = [pan, 0, 0];

          if (sound._node) {
            // If we are falling back, make sure the panningModel is equalpower.
            sound._pannerAttr.panningModel = 'equalpower';

            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || !sound._panner.pan) {
              setupPanner(sound, pannerType);
            }

            if (pannerType === 'spatial') {
              if (typeof sound._panner.positionX !== 'undefined') {
                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
              } else {
                sound._panner.setPosition(pan, 0, 0);
              }
            } else {
              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
            }
          }

          self._emit('stereo', sound._id);
        } else {
          return sound._stereo;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
   * @param  {Number} x  The x-position of the audio source.
   * @param  {Number} y  The y-position of the audio source.
   * @param  {Number} z  The z-position of the audio source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
   */
  Howl.prototype.pos = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change position when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'pos',
        action: function() {
          self.pos(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? 0 : y;
    z = (typeof z !== 'number') ? -0.5 : z;

    // Setup the group's spatial position if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial position if no parameters are passed.
      if (typeof x === 'number') {
        self._pos = [x, y, z];
      } else {
        return self._pos;
      }
    }

    // Change the spatial position of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._pos = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || sound._panner.pan) {
              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.positionX !== 'undefined') {
              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setPosition(x, y, z);
            }
          }

          self._emit('pos', sound._id);
        } else {
          return sound._pos;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
   * space. Depending on how direction the sound is, based on the `cone` attributes,
   * a sound pointing away from the listener can be quiet or silent.
   * @param  {Number} x  The x-orientation of the source.
   * @param  {Number} y  The y-orientation of the source.
   * @param  {Number} z  The z-orientation of the source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
   */
  Howl.prototype.orientation = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'orientation',
        action: function() {
          self.orientation(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._orientation[1] : y;
    z = (typeof z !== 'number') ? self._orientation[2] : z;

    // Setup the group's spatial orientation if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial orientation if no parameters are passed.
      if (typeof x === 'number') {
        self._orientation = [x, y, z];
      } else {
        return self._orientation;
      }
    }

    // Change the spatial orientation of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._orientation = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner) {
              // Make sure we have a position to setup the node with.
              if (!sound._pos) {
                sound._pos = self._pos || [0, 0, -0.5];
              }

              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.orientationX !== 'undefined') {
              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setOrientation(x, y, z);
            }
          }

          self._emit('orientation', sound._id);
        } else {
          return sound._orientation;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the panner node's attributes for a sound or group of sounds.
   * This method can optionall take 0, 1 or 2 arguments.
   *   pannerAttr() -> Returns the group's values.
   *   pannerAttr(id) -> Returns the sound id's values.
   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
   *   pannerAttr(o, id) -> Set's the values of passed sound id.
   *
   *   Attributes:
   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      inside of which there will be no volume reduction.
   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
   *                     listener. Can be `linear`, `inverse` or `exponential.
   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
   *                   will not be reduced any further.
   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
   *                   This is simply a variable of the distance model and has a different effect depending on which model
   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`
   *                     with `inverse` and `exponential`.
   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
   *                     Can be `HRTF` or `equalpower`.
   *
   * @return {Howl/Object} Returns self or current panner attributes.
   */
  Howl.prototype.pannerAttr = function() {
    var self = this;
    var args = arguments;
    var o, id, sound;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // Determine the values based on arguments.
    if (args.length === 0) {
      // Return the group's panner attribute values.
      return self._pannerAttr;
    } else if (args.length === 1) {
      if (typeof args[0] === 'object') {
        o = args[0];

        // Set the grou's panner attribute values.
        if (typeof id === 'undefined') {
          if (!o.pannerAttr) {
            o.pannerAttr = {
              coneInnerAngle: o.coneInnerAngle,
              coneOuterAngle: o.coneOuterAngle,
              coneOuterGain: o.coneOuterGain,
              distanceModel: o.distanceModel,
              maxDistance: o.maxDistance,
              refDistance: o.refDistance,
              rolloffFactor: o.rolloffFactor,
              panningModel: o.panningModel
            };
          }

          self._pannerAttr = {
            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,
            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,
            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,
            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel
          };
        }
      } else {
        // Return this sound's panner attribute values.
        sound = self._soundById(parseInt(args[0], 10));
        return sound ? sound._pannerAttr : self._pannerAttr;
      }
    } else if (args.length === 2) {
      o = args[0];
      id = parseInt(args[1], 10);
    }

    // Update the values of the specified sounds.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      sound = self._soundById(ids[i]);

      if (sound) {
        // Merge the new values into the sound.
        var pa = sound._pannerAttr;
        pa = {
          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,
          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel
        };

        // Update the panner values or create a new panner if none exists.
        var panner = sound._panner;
        if (panner) {
          panner.coneInnerAngle = pa.coneInnerAngle;
          panner.coneOuterAngle = pa.coneOuterAngle;
          panner.coneOuterGain = pa.coneOuterGain;
          panner.distanceModel = pa.distanceModel;
          panner.maxDistance = pa.maxDistance;
          panner.refDistance = pa.refDistance;
          panner.rolloffFactor = pa.rolloffFactor;
          panner.panningModel = pa.panningModel;
        } else {
          // Make sure we have a position to setup the node with.
          if (!sound._pos) {
            sound._pos = self._pos || [0, 0, -0.5];
          }

          // Create a new panner node.
          setupPanner(sound, 'spatial');
        }
      }
    }

    return self;
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core Sound init.
   * @param  {Function} _super Core Sound init method.
   * @return {Sound}
   */
  Sound.prototype.init = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Setup user-defined default properties.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // Complete initilization with howler.js core Sound's init function.
      _super.call(this);

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      }
    };
  })(Sound.prototype.init);

  /**
   * Override the Sound.reset method to clean up properties from the spatial plugin.
   * @param  {Function} _super Sound reset method.
   * @return {Sound}
   */
  Sound.prototype.reset = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Reset all spatial plugin properties on this sound.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      } else if (self._panner) {
        // Disconnect the panner.
        self._panner.disconnect(0);
        self._panner = undefined;
        parent._refreshBuffer(self);
      }

      // Complete resetting of the sound.
      return _super.call(this);
    };
  })(Sound.prototype.reset);

  /** Helper Methods **/
  /***************************************************************************/

  /**
   * Create a new panner node and save it on the sound.
   * @param  {Sound} sound Specific sound to setup panning on.
   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
   */
  var setupPanner = function(sound, type) {
    type = type || 'spatial';

    // Create the new panner node.
    if (type === 'spatial') {
      sound._panner = Howler.ctx.createPanner();
      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
      sound._panner.refDistance = sound._pannerAttr.refDistance;
      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
      sound._panner.panningModel = sound._pannerAttr.panningModel;

      if (typeof sound._panner.positionX !== 'undefined') {
        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
      }

      if (typeof sound._panner.orientationX !== 'undefined') {
        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
      }
    } else {
      sound._panner = Howler.ctx.createStereoPanner();
      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
    }

    sound._panner.connect(sound._node);

    // Update the connections.
    if (!sound._paused) {
      sound._parent.pause(sound._id, true).play(sound._id, true);
    }
  };
})();

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyStyleWithOptions = void 0;
function applyStyleWithOptions(clonedNode, options) {
    var style = clonedNode.style;
    if (options.backgroundColor) {
        style.backgroundColor = options.backgroundColor;
    }
    if (options.width) {
        style.width = options.width + "px";
    }
    if (options.height) {
        style.height = options.height + "px";
    }
    if (options.style) {
        Object.assign(style, options.style);
    }
    return clonedNode;
}
exports.applyStyleWithOptions = applyStyleWithOptions;

},{}],75:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cloneNode = void 0;
var clonePseudoElements_1 = require("./clonePseudoElements");
var util_1 = require("./util");
function cloneSingleNode(node) {
    return __awaiter(this, void 0, void 0, function () {
        var dataURL;
        return __generator(this, function (_a) {
            if (node instanceof HTMLCanvasElement) {
                dataURL = node.toDataURL();
                if (dataURL === 'data:,') {
                    return [2 /*return*/, Promise.resolve(node.cloneNode(false))];
                }
                return [2 /*return*/, util_1.createImage(dataURL)];
            }
            // if (node.tagName && node.tagName.toLowerCase() === 'svg') {
            //   return Promise.resolve(node as SVGElement)
            //     .then((svg) => svgToDataURL(svg))
            //     .then(createImage)
            // }
            return [2 /*return*/, Promise.resolve(node.cloneNode(false))];
        });
    });
}
function cloneChildren(nativeNode, clonedNode, filter) {
    return __awaiter(this, void 0, void 0, function () {
        var children;
        return __generator(this, function (_a) {
            children = util_1.toArray(nativeNode.childNodes);
            if (children.length === 0) {
                return [2 /*return*/, Promise.resolve(clonedNode)];
            }
            return [2 /*return*/, children
                    .reduce(function (done, child) {
                    return done
                        .then(function () { return cloneNode(child, filter); })
                        .then(function (clonedChild) {
                        if (clonedChild) {
                            clonedNode.appendChild(clonedChild);
                        }
                    });
                }, Promise.resolve())
                    .then(function () { return clonedNode; })];
        });
    });
}
function decorate(nativeNode, clonedNode) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (!(clonedNode instanceof Element)) {
                return [2 /*return*/, clonedNode];
            }
            return [2 /*return*/, Promise.resolve()
                    .then(function () { return cloneCssStyle(nativeNode, clonedNode); })
                    .then(function () { return clonePseudoElements_1.clonePseudoElements(nativeNode, clonedNode); })
                    .then(function () { return cloneInputValue(nativeNode, clonedNode); })
                    .then(function () { return clonedNode; })];
        });
    });
}
function cloneCssStyle(nativeNode, clonedNode) {
    var source = window.getComputedStyle(nativeNode);
    var target = clonedNode.style;
    if (source.cssText) {
        target.cssText = source.cssText;
    }
    else {
        util_1.toArray(source).forEach(function (name) {
            target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));
        });
    }
}
function cloneInputValue(nativeNode, clonedNode) {
    if (nativeNode instanceof HTMLTextAreaElement) {
        clonedNode.innerHTML = nativeNode.value;
    }
    if (nativeNode instanceof HTMLInputElement) {
        clonedNode.setAttribute('value', nativeNode.value);
    }
}
function cloneNode(nativeNode, filter, isRoot) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (!isRoot && filter && !filter(nativeNode)) {
                return [2 /*return*/, Promise.resolve(null)];
            }
            return [2 /*return*/, Promise.resolve(nativeNode)
                    .then(cloneSingleNode)
                    .then(function (clonedNode) { return cloneChildren(nativeNode, clonedNode, filter); })
                    .then(function (clonedNode) { return decorate(nativeNode, clonedNode); })];
        });
    });
}
exports.cloneNode = cloneNode;

},{"./clonePseudoElements":76,"./util":83}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clonePseudoElements = void 0;
var util_1 = require("./util");
function clonePseudoElements(nativeNode, clonedNode) {
    var pseudos = [':before', ':after'];
    pseudos.forEach(function (pseudo) {
        return Pseudo.clonePseudoElement(nativeNode, clonedNode, pseudo);
    });
}
exports.clonePseudoElements = clonePseudoElements;
var Pseudo;
(function (Pseudo) {
    function clonePseudoElement(nativeNode, clonedNode, pseudo) {
        var style = window.getComputedStyle(nativeNode, pseudo);
        var content = style.getPropertyValue('content');
        if (content === '' || content === 'none') {
            return;
        }
        var className = util_1.uuid();
        var styleElement = document.createElement('style');
        styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));
        clonedNode.className = clonedNode.className + " " + className;
        clonedNode.appendChild(styleElement);
    }
    Pseudo.clonePseudoElement = clonePseudoElement;
    function getPseudoElementStyle(className, pseudo, style) {
        var selector = "." + className + ":" + pseudo;
        var cssText = style.cssText
            ? formatCssText(style)
            : formatCssProperties(style);
        return document.createTextNode(selector + "{" + cssText + "}");
    }
    function formatCssText(style) {
        var content = style.getPropertyValue('content');
        return style.cssText + " content: " + content + ";";
    }
    function formatCssProperties(style) {
        return util_1.toArray(style)
            .map(function (name) {
            var value = style.getPropertyValue(name);
            var priority = style.getPropertyPriority(name);
            return name + ": " + value + (priority ? ' !important' : '') + ";";
        })
            .join(' ');
    }
})(Pseudo || (Pseudo = {}));

},{"./util":83}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSvgDataURL = void 0;
var util_1 = require("./util");
function createSvgDataURL(clonedNode, width, height) {
    var xmlns = 'http://www.w3.org/2000/svg';
    var svg = document.createElementNS(xmlns, 'svg');
    var foreignObject = document.createElementNS(xmlns, 'foreignObject');
    svg.setAttributeNS('', 'width', "" + width);
    svg.setAttributeNS('', 'height', "" + height);
    foreignObject.setAttributeNS('', 'width', '100%');
    foreignObject.setAttributeNS('', 'height', '100%');
    foreignObject.setAttributeNS('', 'x', '0');
    foreignObject.setAttributeNS('', 'y', '0');
    foreignObject.setAttributeNS('', 'externalResourcesRequired', 'true');
    svg.appendChild(foreignObject);
    foreignObject.appendChild(clonedNode);
    return util_1.svgToDataURL(svg);
}
exports.createSvgDataURL = createSvgDataURL;

},{"./util":83}],78:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.embedImages = void 0;
var getBlobFromURL_1 = require("./getBlobFromURL");
var embedResources_1 = require("./embedResources");
var util_1 = require("./util");
function embedImages(clonedNode, options) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (!(clonedNode instanceof Element)) {
                return [2 /*return*/, Promise.resolve(clonedNode)];
            }
            return [2 /*return*/, Promise.resolve(clonedNode)
                    .then(function (node) { return embedBackground(node, options); })
                    .then(function (node) { return embedImageNode(node, options); })
                    .then(function (node) { return embedChildren(node, options); })];
        });
    });
}
exports.embedImages = embedImages;
function embedBackground(clonedNode, options) {
    return __awaiter(this, void 0, void 0, function () {
        var background;
        return __generator(this, function (_a) {
            background = clonedNode.style.getPropertyValue('background');
            if (!background) {
                return [2 /*return*/, Promise.resolve(clonedNode)];
            }
            return [2 /*return*/, Promise.resolve(background)
                    .then(function (cssString) { return embedResources_1.embedResources(cssString, null, options); })
                    .then(function (cssString) {
                    clonedNode.style.setProperty('background', cssString, clonedNode.style.getPropertyPriority('background'));
                    return clonedNode;
                })];
        });
    });
}
function embedImageNode(clonedNode, options) {
    if (!(clonedNode instanceof HTMLImageElement) || util_1.isDataUrl(clonedNode.src)) {
        return Promise.resolve(clonedNode);
    }
    return Promise.resolve(clonedNode.src)
        .then(function (url) { return getBlobFromURL_1.getBlobFromURL(url, options); })
        .then(function (data) { return util_1.toDataURL(data, util_1.getMimeType(clonedNode.src)); })
        .then(function (dataURL) {
        return new Promise(function (resolve, reject) {
            clonedNode.onload = resolve;
            clonedNode.onerror = reject;
            clonedNode.src = dataURL;
        });
    })
        .then(function () { return clonedNode; }, function () { return clonedNode; });
}
function embedChildren(clonedNode, options) {
    return __awaiter(this, void 0, void 0, function () {
        var children, deferreds;
        return __generator(this, function (_a) {
            children = util_1.toArray(clonedNode.childNodes);
            deferreds = children.map(function (child) { return embedImages(child, options); });
            return [2 /*return*/, Promise.all(deferreds).then(function () { return clonedNode; })];
        });
    });
}

},{"./embedResources":79,"./getBlobFromURL":81,"./util":83}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.embed = exports.parseURLs = exports.embedResources = exports.shouldEmbed = void 0;
var getBlobFromURL_1 = require("./getBlobFromURL");
var util_1 = require("./util");
var URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
function shouldEmbed(string) {
    return string.search(URL_REGEX) !== -1;
}
exports.shouldEmbed = shouldEmbed;
function embedResources(cssString, baseUrl, options) {
    if (!shouldEmbed(cssString)) {
        return Promise.resolve(cssString);
    }
    return Promise.resolve(cssString)
        .then(parseURLs)
        .then(function (urls) {
        return urls.reduce(function (done, url) { return done.then(function (ret) { return embed(ret, url, baseUrl, options); }); }, Promise.resolve(cssString));
    });
}
exports.embedResources = embedResources;
function parseURLs(str) {
    var result = [];
    str.replace(URL_REGEX, function (raw, quotation, url) {
        result.push(url);
        return raw;
    });
    return result.filter(function (url) { return !util_1.isDataUrl(url); });
}
exports.parseURLs = parseURLs;
function embed(cssString, resourceURL, baseURL, options, get) {
    var resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
    return Promise.resolve(resolvedURL)
        .then(function (url) { return (get ? get(url) : getBlobFromURL_1.getBlobFromURL(url, options)); })
        .then(function (data) { return util_1.toDataURL(data, util_1.getMimeType(resourceURL)); })
        .then(function (dataURL) {
        return cssString.replace(urlToRegex(resourceURL), "$1" + dataURL + "$3");
    })
        .then(function (content) { return content; }, function () { return resolvedURL; });
}
exports.embed = embed;
function resolveUrl(url, baseUrl) {
    // url is absolute already
    if (url.match(/^[a-z]+:\/\//i)) {
        return url;
    }
    // url is absolute already, without protocol
    if (url.match(/^\/\//)) {
        return window.location.protocol + url;
    }
    // dataURI, mailto:, tel:, etc.
    if (url.match(/^[a-z]+:/i)) {
        return url;
    }
    var doc = document.implementation.createHTMLDocument();
    var base = doc.createElement('base');
    var a = doc.createElement('a');
    doc.head.appendChild(base);
    doc.body.appendChild(a);
    if (baseUrl) {
        base.href = baseUrl;
    }
    a.href = url;
    return a.href;
}
function urlToRegex(url) {
    return new RegExp("(url\\(['\"]?)(" + escape(url) + ")(['\"]?\\))", 'g');
}
function escape(url) {
    return url.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1');
}

},{"./getBlobFromURL":81,"./util":83}],80:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCssRules = exports.embedWebFonts = exports.parseWebFontRules = void 0;
var util_1 = require("./util");
var embedResources_1 = require("./embedResources");
function parseWebFontRules(clonedNode) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    if (!clonedNode.ownerDocument) {
                        reject(new Error('Provided element is not within a Document'));
                    }
                    resolve(util_1.toArray(clonedNode.ownerDocument.styleSheets));
                })
                    .then(getCssRules)
                    .then(getWebFontRules)];
        });
    });
}
exports.parseWebFontRules = parseWebFontRules;
function embedWebFonts(clonedNode, options) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, parseWebFontRules(clonedNode)
                    .then(function (rules) {
                    return Promise.all(rules.map(function (rule) {
                        var baseUrl = rule.parentStyleSheet
                            ? rule.parentStyleSheet.href
                            : null;
                        return embedResources_1.embedResources(rule.cssText, baseUrl, options);
                    }));
                })
                    .then(function (cssStrings) { return cssStrings.join('\n'); })
                    .then(function (cssString) {
                    var styleNode = document.createElement('style');
                    var sytleContent = document.createTextNode(cssString);
                    styleNode.appendChild(sytleContent);
                    if (clonedNode.firstChild) {
                        clonedNode.insertBefore(styleNode, clonedNode.firstChild);
                    }
                    else {
                        clonedNode.appendChild(styleNode);
                    }
                    return clonedNode;
                })];
        });
    });
}
exports.embedWebFonts = embedWebFonts;
function getCssRules(styleSheets) {
    return __awaiter(this, void 0, void 0, function () {
        var ret, promises;
        return __generator(this, function (_a) {
            ret = [];
            promises = [];
            // First loop inlines imports
            styleSheets.forEach(function (sheet) {
                if ('cssRules' in sheet) {
                    try {
                        util_1.toArray(sheet.cssRules).forEach(function (item) {
                            if (item.type === CSSRule.IMPORT_RULE) {
                                promises.push(fetchCSS(item.href, sheet)
                                    .then(embedFonts)
                                    .then(function (cssText) {
                                    var parsed = parseCSS(cssText);
                                    parsed.forEach(function (rule) {
                                        sheet.insertRule(rule, sheet.cssRules.length);
                                    });
                                })
                                    .catch(function (e) {
                                    console.log('Error loading remote css', e.toString());
                                }));
                            }
                        });
                    }
                    catch (e) {
                        var inline_1 = styleSheets.find(function (a) { return a.href === null; }) || document.styleSheets[0];
                        if (sheet.href != null) {
                            promises.push(fetchCSS(sheet.href, inline_1)
                                .then(embedFonts)
                                .then(function (cssText) {
                                var parsed = parseCSS(cssText);
                                parsed.forEach(function (rule) {
                                    inline_1.insertRule(rule, sheet.cssRules.length);
                                });
                            })
                                .catch(function (e) {
                                console.log('Error loading remote stylesheet', e.toString());
                            }));
                        }
                        console.log('Error inlining remote css file', e.toString());
                    }
                }
            });
            return [2 /*return*/, Promise.all(promises).then(function () {
                    // Second loop parses rules
                    styleSheets.forEach(function (sheet) {
                        if ('cssRules' in sheet) {
                            try {
                                util_1.toArray(sheet.cssRules).forEach(function (item) {
                                    ret.push(item);
                                });
                            }
                            catch (e) {
                                console.log("Error while reading CSS rules from " + sheet.href, e.toString());
                            }
                        }
                    });
                    return ret;
                })];
        });
    });
}
exports.getCssRules = getCssRules;
function getWebFontRules(cssRules) {
    return cssRules
        .filter(function (rule) { return rule.type === CSSRule.FONT_FACE_RULE; })
        .filter(function (rule) { return embedResources_1.shouldEmbed(rule.style.getPropertyValue('src')); });
}
function parseCSS(source) {
    if (source === undefined) {
        return [];
    }
    var cssText = source;
    var css = [];
    var cssKeyframeRegex = '((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})';
    var combinedCSSRegex = '((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]' +
        '*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})'; // to match css & media queries together
    var cssCommentsRegex = new RegExp('(\\/\\*[\\s\\S]*?\\*\\/)', 'gi');
    // strip out comments
    cssText = cssText.replace(cssCommentsRegex, '');
    var keyframesRegex = new RegExp(cssKeyframeRegex, 'gi');
    var arr;
    while (true) {
        arr = keyframesRegex.exec(cssText);
        if (arr === null) {
            break;
        }
        css.push(arr[0]);
    }
    cssText = cssText.replace(keyframesRegex, '');
    // unified regex
    var unified = new RegExp(combinedCSSRegex, 'gi');
    while (true) {
        arr = unified.exec(cssText);
        if (arr === null) {
            break;
        }
        css.push(arr[0]);
    }
    return css;
}
function fetchCSS(url, sheet) {
    return fetch(url).then(function (res) {
        return {
            url: url,
            cssText: res.text(),
        };
    }, function (e) {
        console.log('ERROR FETCHING CSS: ', e.toString());
    });
}
function embedFonts(data) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, data.cssText.then(function (resolved) {
                    var cssText = resolved;
                    var regexUrlFind = /url\(["']?([^"')]+)["']?\)/g;
                    var fontLocations = cssText.match(/url\([^)]+\)/g) || [];
                    var fontLoadedPromises = fontLocations.map(function (location) {
                        var url = location.replace(regexUrlFind, '$1');
                        if (!url.startsWith('https://')) {
                            var source = data.url;
                            url = new URL(url, source).href;
                        }
                        return new Promise(function (resolve, reject) {
                            fetch(url)
                                .then(function (res) { return res.blob(); })
                                .then(function (blob) {
                                var reader = new FileReader();
                                reader.addEventListener('load', function (res) {
                                    // Side Effect
                                    cssText = cssText.replace(location, "url(" + reader.result + ")");
                                    resolve([location, reader.result]);
                                });
                                reader.readAsDataURL(blob);
                            })
                                .catch(reject);
                        });
                    });
                    return Promise.all(fontLoadedPromises).then(function () { return cssText; });
                })];
        });
    });
}

},{"./embedResources":79,"./util":83}],81:[function(require,module,exports){
"use strict";
/* tslint:disable:max-line-length */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBlobFromURL = void 0;
var util_1 = require("./util");
// KNOWN ISSUE
// -----------
// Can not handle redirect-url, such as when access 'http://something.com/avatar.png'
// will redirect to 'http://something.com/65fc2ffcc8aea7ba65a1d1feda173540'
var TIMEOUT = 30000;
function getBlobFromURL(url, options) {
    // cache bypass so we dont have CORS issues with cached images
    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
    if (options.cacheBust) {
        // tslint:disable-next-line
        url += (/\?/.test(url) ? '&' : '?') + new Date().getTime();
    }
    var failed = function (reason) {
        var placeholder = '';
        if (options.imagePlaceholder) {
            var parts = options.imagePlaceholder.split(/,/);
            if (parts && parts[1]) {
                placeholder = parts[1];
            }
        }
        var msg = "Failed to fetch resource: " + url;
        if (reason) {
            msg = typeof reason === 'string' ? reason : reason.message;
        }
        if (msg) {
            console.error(msg);
        }
        return placeholder;
    };
    var deferred = window.fetch
        ? window
            .fetch(url)
            .then(function (response) { return response.blob(); })
            .then(function (blob) {
            return new Promise(function (resolve, reject) {
                var reader = new FileReader();
                reader.onloadend = function () { return resolve(reader.result); };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        })
            .then(util_1.getDataURLContent)
            .catch(function () { return new Promise(function (resolve, reject) { return reject(); }); })
        : new Promise(function (resolve, reject) {
            var req = new XMLHttpRequest();
            var timeout = function () {
                reject(new Error("Timeout of " + TIMEOUT + "ms occured while fetching resource: " + url));
            };
            var done = function () {
                if (req.readyState !== 4) {
                    return;
                }
                if (req.status !== 200) {
                    reject(new Error("Failed to fetch resource: " + url + ", status: " + req.status));
                    return;
                }
                var encoder = new FileReader();
                encoder.onloadend = function () {
                    resolve(util_1.getDataURLContent(encoder.result));
                };
                encoder.readAsDataURL(req.response);
            };
            req.onreadystatechange = done;
            req.ontimeout = timeout;
            req.responseType = 'blob';
            req.timeout = TIMEOUT;
            req.open('GET', url, true);
            req.send();
        });
    return deferred.catch(failed);
}
exports.getBlobFromURL = getBlobFromURL;

},{"./util":83}],82:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBlob = exports.toJpeg = exports.toPng = exports.toPixelData = exports.toCanvas = exports.toSvgDataURL = exports.toSvg = void 0;
var cloneNode_1 = require("./cloneNode");
var embedImages_1 = require("./embedImages");
var embedWebFonts_1 = require("./embedWebFonts");
var createSvgDataURL_1 = require("./createSvgDataURL");
var applyStyleWithOptions_1 = require("./applyStyleWithOptions");
var util_1 = require("./util");
function getImageSize(domNode, options) {
    if (options === void 0) { options = {}; }
    var width = options.width || util_1.getNodeWidth(domNode);
    var height = options.height || util_1.getNodeHeight(domNode);
    return { width: width, height: height };
}
function toSvg(domNode, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var _a, width, height;
        return __generator(this, function (_b) {
            _a = getImageSize(domNode, options), width = _a.width, height = _a.height;
            return [2 /*return*/, cloneNode_1.cloneNode(domNode, options.filter, true)
                    .then(function (clonedNode) { return embedWebFonts_1.embedWebFonts(clonedNode, options); })
                    .then(function (clonedNode) { return embedImages_1.embedImages(clonedNode, options); })
                    .then(function (clonedNode) { return applyStyleWithOptions_1.applyStyleWithOptions(clonedNode, options); })
                    .then(function (clonedNode) { return createSvgDataURL_1.createSvgDataURL(clonedNode, width, height); })];
        });
    });
}
exports.toSvg = toSvg;
exports.toSvgDataURL = toSvg;
function toCanvas(domNode, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, toSvg(domNode, options)
                    .then(util_1.createImage)
                    .then(util_1.delay(100))
                    .then(function (image) {
                    var canvas = document.createElement('canvas');
                    var context = canvas.getContext('2d');
                    var ratio = options.pixelRatio || util_1.getPixelRatio();
                    var _a = getImageSize(domNode, options), width = _a.width, height = _a.height;
                    canvas.width = width * ratio;
                    canvas.height = height * ratio;
                    canvas.style.width = "" + width;
                    canvas.style.height = "" + height;
                    if (options.backgroundColor) {
                        context.fillStyle = options.backgroundColor;
                        context.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    context.drawImage(image, 0, 0);
                    return canvas;
                })];
        });
    });
}
exports.toCanvas = toCanvas;
function toPixelData(domNode, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var _a, width, height;
        return __generator(this, function (_b) {
            _a = getImageSize(domNode, options), width = _a.width, height = _a.height;
            return [2 /*return*/, toCanvas(domNode, options).then(function (canvas) {
                    var ctx = canvas.getContext('2d');
                    return ctx.getImageData(0, 0, width, height).data;
                })];
        });
    });
}
exports.toPixelData = toPixelData;
function toPng(domNode, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, toCanvas(domNode, options).then(function (canvas) { return canvas.toDataURL(); })];
        });
    });
}
exports.toPng = toPng;
function toJpeg(domNode, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, toCanvas(domNode, options).then(function (canvas) {
                    return canvas.toDataURL('image/jpeg', options.quality || 1);
                })];
        });
    });
}
exports.toJpeg = toJpeg;
function toBlob(domNode, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, toCanvas(domNode, options).then(util_1.canvasToBlob)];
        });
    });
}
exports.toBlob = toBlob;

},{"./applyStyleWithOptions":74,"./cloneNode":75,"./createSvgDataURL":77,"./embedImages":78,"./embedWebFonts":80,"./util":83}],83:[function(require,module,exports){
(function (process){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBlobFromImageURL = exports.svgToDataURL = exports.createImage = exports.getPixelRatio = exports.getNodeHeight = exports.getNodeWidth = exports.toArray = exports.canvasToBlob = exports.getDataURLContent = exports.toDataURL = exports.isDataUrl = exports.delay = exports.getMimeType = exports.getExtension = exports.uuid = void 0;
var WOFF = 'application/font-woff';
var JPEG = 'image/jpeg';
var mimes = {
    woff: WOFF,
    woff2: WOFF,
    ttf: 'application/font-truetype',
    eot: 'application/vnd.ms-fontobject',
    png: 'image/png',
    jpg: JPEG,
    jpeg: JPEG,
    gif: 'image/gif',
    tiff: 'image/tiff',
    svg: 'image/svg+xml',
};
exports.uuid = (function uuid() {
    // generate uuid for className of pseudo elements.
    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.
    var counter = 0;
    // ref: http://stackoverflow.com/a/6248722/2519373
    var random = function () {
        return ("0000" + ((Math.random() * Math.pow(36, 4)) << 0).toString(36)).slice(-4);
    };
    return function () {
        counter += 1;
        return "u" + random() + counter;
    };
})();
function getExtension(url) {
    var match = /\.([^./]*?)$/g.exec(url);
    return match ? match[1] : '';
}
exports.getExtension = getExtension;
function getMimeType(url) {
    var ext = getExtension(url).toLowerCase();
    return mimes[ext] || '';
}
exports.getMimeType = getMimeType;
function delay(ms) {
    return function (args) {
        return new Promise(function (resolve) {
            setTimeout(function () {
                resolve(args);
            }, ms);
        });
    };
}
exports.delay = delay;
function isDataUrl(url) {
    return url.search(/^(data:)/) !== -1;
}
exports.isDataUrl = isDataUrl;
function toDataURL(content, mimeType) {
    return "data:" + mimeType + ";base64," + content;
}
exports.toDataURL = toDataURL;
function getDataURLContent(dataURL) {
    return dataURL.split(/,/)[1];
}
exports.getDataURLContent = getDataURLContent;
function toBlob(canvas) {
    return new Promise(function (resolve) {
        var binaryString = window.atob(canvas.toDataURL().split(',')[1]);
        var len = binaryString.length;
        var binaryArray = new Uint8Array(len);
        for (var i = 0; i < len; i += 1) {
            binaryArray[i] = binaryString.charCodeAt(i);
        }
        resolve(new Blob([binaryArray], { type: 'image/png' }));
    });
}
function canvasToBlob(canvas) {
    if (canvas.toBlob) {
        return new Promise(function (resolve) { return canvas.toBlob(resolve); });
    }
    return toBlob(canvas);
}
exports.canvasToBlob = canvasToBlob;
function toArray(arrayLike) {
    var result = [];
    for (var i = 0, l = arrayLike.length; i < l; i += 1) {
        result.push(arrayLike[i]);
    }
    return result;
}
exports.toArray = toArray;
function px(node, styleProperty) {
    var val = window.getComputedStyle(node).getPropertyValue(styleProperty);
    return parseFloat(val.replace('px', ''));
}
function getNodeWidth(node) {
    var leftBorder = px(node, 'border-left-width');
    var rightBorder = px(node, 'border-right-width');
    return node.scrollWidth + leftBorder + rightBorder;
}
exports.getNodeWidth = getNodeWidth;
function getNodeHeight(node) {
    var topBorder = px(node, 'border-top-width');
    var bottomBorder = px(node, 'border-bottom-width');
    return node.scrollHeight + topBorder + bottomBorder;
}
exports.getNodeHeight = getNodeHeight;
function getPixelRatio() {
    var ratio;
    var val = process && process.env ? process.env.devicePixelRatio : null;
    if (val) {
        ratio = parseInt(val, 10);
        if (isNaN(ratio)) {
            ratio = 1;
        }
    }
    return ratio || window.devicePixelRatio || 1;
}
exports.getPixelRatio = getPixelRatio;
function createImage(url) {
    return new Promise(function (resolve, reject) {
        var image = new Image();
        image.onload = function () { return resolve(image); };
        image.onerror = reject;
        image.crossOrigin = 'anonymous';
        image.src = url;
    });
}
exports.createImage = createImage;
function svgToDataURL(svg) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, Promise.resolve()
                    .then(function () { return new XMLSerializer().serializeToString(svg); })
                    .then(encodeURIComponent)
                    .then(function (html) { return "data:image/svg+xml;charset=utf-8," + html; })];
        });
    });
}
exports.svgToDataURL = svgToDataURL;
function getBlobFromImageURL(url) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, createImage(url).then(function (image) {
                    var width = image.width, height = image.height;
                    var canvas = document.createElement('canvas');
                    var context = canvas.getContext('2d');
                    var ratio = getPixelRatio();
                    canvas.width = width * ratio;
                    canvas.height = height * ratio;
                    canvas.style.width = "" + width;
                    canvas.style.height = "" + height;
                    context.scale(ratio, ratio);
                    context.drawImage(image, 0, 0);
                    var dataURL = canvas.toDataURL(getMimeType(url));
                    return getDataURLContent(dataURL);
                })];
        });
    });
}
exports.getBlobFromImageURL = getBlobFromImageURL;

}).call(this)}).call(this,require('_process'))

},{"_process":84}],84:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("./vnode");
var is = require("./is");
function addNS(data, children, sel) {
    data.ns = 'http://www.w3.org/2000/svg';
    if (sel !== 'foreignObject' && children !== undefined) {
        for (var i = 0; i < children.length; ++i) {
            var childData = children[i].data;
            if (childData !== undefined) {
                addNS(childData, children[i].children, children[i].sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {}, children, text, i;
    if (c !== undefined) {
        data = b;
        if (is.array(c)) {
            children = c;
        }
        else if (is.primitive(c)) {
            text = c;
        }
        else if (c && c.sel) {
            children = [c];
        }
    }
    else if (b !== undefined) {
        if (is.array(b)) {
            children = b;
        }
        else if (is.primitive(b)) {
            text = b;
        }
        else if (b && b.sel) {
            children = [b];
        }
        else {
            data = b;
        }
    }
    if (children !== undefined) {
        for (i = 0; i < children.length; ++i) {
            if (is.primitive(children[i]))
                children[i] = vnode_1.vnode(undefined, undefined, undefined, children[i], undefined);
        }
    }
    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&
        (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {
        addNS(data, children, sel);
    }
    return vnode_1.vnode(sel, data, children, text, undefined);
}
exports.h = h;
;
exports.default = h;

},{"./is":87,"./vnode":96}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function createElement(tagName) {
    return document.createElement(tagName);
}
function createElementNS(namespaceURI, qualifiedName) {
    return document.createElementNS(namespaceURI, qualifiedName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(elm) {
    return elm.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function getTextContent(node) {
    return node.textContent;
}
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeType === 8;
}
exports.htmlDomApi = {
    createElement: createElement,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    getTextContent: getTextContent,
    isElement: isElement,
    isText: isText,
    isComment: isComment,
};
exports.default = exports.htmlDomApi;

},{}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.array = Array.isArray;
function primitive(s) {
    return typeof s === 'string' || typeof s === 'number';
}
exports.primitive = primitive;

},{}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var xlinkNS = 'http://www.w3.org/1999/xlink';
var xmlNS = 'http://www.w3.org/XML/1998/namespace';
var colonChar = 58;
var xChar = 120;
function updateAttrs(oldVnode, vnode) {
    var key, elm = vnode.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs;
    if (!oldAttrs && !attrs)
        return;
    if (oldAttrs === attrs)
        return;
    oldAttrs = oldAttrs || {};
    attrs = attrs || {};
    // update modified attributes, add new attributes
    for (key in attrs) {
        var cur = attrs[key];
        var old = oldAttrs[key];
        if (old !== cur) {
            if (cur === true) {
                elm.setAttribute(key, "");
            }
            else if (cur === false) {
                elm.removeAttribute(key);
            }
            else {
                if (key.charCodeAt(0) !== xChar) {
                    elm.setAttribute(key, cur);
                }
                else if (key.charCodeAt(3) === colonChar) {
                    // Assume xml namespace
                    elm.setAttributeNS(xmlNS, key, cur);
                }
                else if (key.charCodeAt(5) === colonChar) {
                    // Assume xlink namespace
                    elm.setAttributeNS(xlinkNS, key, cur);
                }
                else {
                    elm.setAttribute(key, cur);
                }
            }
        }
    }
    // remove removed attributes
    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
    // the other option is to remove all attributes with value == undefined
    for (key in oldAttrs) {
        if (!(key in attrs)) {
            elm.removeAttribute(key);
        }
    }
}
exports.attributesModule = { create: updateAttrs, update: updateAttrs };
exports.default = exports.attributesModule;

},{}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function updateClass(oldVnode, vnode) {
    var cur, name, elm = vnode.elm, oldClass = oldVnode.data.class, klass = vnode.data.class;
    if (!oldClass && !klass)
        return;
    if (oldClass === klass)
        return;
    oldClass = oldClass || {};
    klass = klass || {};
    for (name in oldClass) {
        if (!klass[name]) {
            elm.classList.remove(name);
        }
    }
    for (name in klass) {
        cur = klass[name];
        if (cur !== oldClass[name]) {
            elm.classList[cur ? 'add' : 'remove'](name);
        }
    }
}
exports.classModule = { create: updateClass, update: updateClass };
exports.default = exports.classModule;

},{}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function invokeHandler(handler, vnode, event) {
    if (typeof handler === "function") {
        // call function handler
        handler.call(vnode, event, vnode);
    }
    else if (typeof handler === "object") {
        // call handler with arguments
        if (typeof handler[0] === "function") {
            // special case for single argument for performance
            if (handler.length === 2) {
                handler[0].call(vnode, handler[1], event, vnode);
            }
            else {
                var args = handler.slice(1);
                args.push(event);
                args.push(vnode);
                handler[0].apply(vnode, args);
            }
        }
        else {
            // call multiple handlers
            for (var i = 0; i < handler.length; i++) {
                invokeHandler(handler[i], vnode, event);
            }
        }
    }
}
function handleEvent(event, vnode) {
    var name = event.type, on = vnode.data.on;
    // call event handler(s) if exists
    if (on && on[name]) {
        invokeHandler(on[name], vnode, event);
    }
}
function createListener() {
    return function handler(event) {
        handleEvent(event, handler.vnode);
    };
}
function updateEventListeners(oldVnode, vnode) {
    var oldOn = oldVnode.data.on, oldListener = oldVnode.listener, oldElm = oldVnode.elm, on = vnode && vnode.data.on, elm = (vnode && vnode.elm), name;
    // optimization for reused immutable handlers
    if (oldOn === on) {
        return;
    }
    // remove existing listeners which no longer used
    if (oldOn && oldListener) {
        // if element changed or deleted we remove all existing listeners unconditionally
        if (!on) {
            for (name in oldOn) {
                // remove listener if element was changed or existing listeners removed
                oldElm.removeEventListener(name, oldListener, false);
            }
        }
        else {
            for (name in oldOn) {
                // remove listener if existing listener removed
                if (!on[name]) {
                    oldElm.removeEventListener(name, oldListener, false);
                }
            }
        }
    }
    // add new listeners which has not already attached
    if (on) {
        // reuse existing listener or create new
        var listener = vnode.listener = oldVnode.listener || createListener();
        // update vnode for listener
        listener.vnode = vnode;
        // if element changed or added we add all needed listeners unconditionally
        if (!oldOn) {
            for (name in on) {
                // add listener if element was changed or new listeners added
                elm.addEventListener(name, listener, false);
            }
        }
        else {
            for (name in on) {
                // add listener if new listener added
                if (!oldOn[name]) {
                    elm.addEventListener(name, listener, false);
                }
            }
        }
    }
}
exports.eventListenersModule = {
    create: updateEventListeners,
    update: updateEventListeners,
    destroy: updateEventListeners
};
exports.default = exports.eventListenersModule;

},{}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function updateProps(oldVnode, vnode) {
    var key, cur, old, elm = vnode.elm, oldProps = oldVnode.data.props, props = vnode.data.props;
    if (!oldProps && !props)
        return;
    if (oldProps === props)
        return;
    oldProps = oldProps || {};
    props = props || {};
    for (key in oldProps) {
        if (!props[key]) {
            delete elm[key];
        }
    }
    for (key in props) {
        cur = props[key];
        old = oldProps[key];
        if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
            elm[key] = cur;
        }
    }
}
exports.propsModule = { create: updateProps, update: updateProps };
exports.default = exports.propsModule;

},{}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Bindig `requestAnimationFrame` like this fixes a bug in IE/Edge. See #360 and #409.
var raf = (typeof window !== 'undefined' && (window.requestAnimationFrame).bind(window)) || setTimeout;
var nextFrame = function (fn) { raf(function () { raf(fn); }); };
var reflowForced = false;
function setNextFrame(obj, prop, val) {
    nextFrame(function () { obj[prop] = val; });
}
function updateStyle(oldVnode, vnode) {
    var cur, name, elm = vnode.elm, oldStyle = oldVnode.data.style, style = vnode.data.style;
    if (!oldStyle && !style)
        return;
    if (oldStyle === style)
        return;
    oldStyle = oldStyle || {};
    style = style || {};
    var oldHasDel = 'delayed' in oldStyle;
    for (name in oldStyle) {
        if (!style[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.removeProperty(name);
            }
            else {
                elm.style[name] = '';
            }
        }
    }
    for (name in style) {
        cur = style[name];
        if (name === 'delayed' && style.delayed) {
            for (var name2 in style.delayed) {
                cur = style.delayed[name2];
                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
                    setNextFrame(elm.style, name2, cur);
                }
            }
        }
        else if (name !== 'remove' && cur !== oldStyle[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.setProperty(name, cur);
            }
            else {
                elm.style[name] = cur;
            }
        }
    }
}
function applyDestroyStyle(vnode) {
    var style, name, elm = vnode.elm, s = vnode.data.style;
    if (!s || !(style = s.destroy))
        return;
    for (name in style) {
        elm.style[name] = style[name];
    }
}
function applyRemoveStyle(vnode, rm) {
    var s = vnode.data.style;
    if (!s || !s.remove) {
        rm();
        return;
    }
    if (!reflowForced) {
        vnode.elm.offsetLeft;
        reflowForced = true;
    }
    var name, elm = vnode.elm, i = 0, compStyle, style = s.remove, amount = 0, applied = [];
    for (name in style) {
        applied.push(name);
        elm.style[name] = style[name];
    }
    compStyle = getComputedStyle(elm);
    var props = compStyle['transition-property'].split(', ');
    for (; i < props.length; ++i) {
        if (applied.indexOf(props[i]) !== -1)
            amount++;
    }
    elm.addEventListener('transitionend', function (ev) {
        if (ev.target === elm)
            --amount;
        if (amount === 0)
            rm();
    });
}
function forceReflow() {
    reflowForced = false;
}
exports.styleModule = {
    pre: forceReflow,
    create: updateStyle,
    update: updateStyle,
    destroy: applyDestroyStyle,
    remove: applyRemoveStyle
};
exports.default = exports.styleModule;

},{}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("./vnode");
var is = require("./is");
var htmldomapi_1 = require("./htmldomapi");
function isUndef(s) { return s === undefined; }
function isDef(s) { return s !== undefined; }
var emptyNode = vnode_1.default('', {}, [], undefined, undefined);
function sameVnode(vnode1, vnode2) {
    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}
function isVnode(vnode) {
    return vnode.sel !== undefined;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, map = {}, key, ch;
    for (i = beginIdx; i <= endIdx; ++i) {
        ch = children[i];
        if (ch != null) {
            key = ch.key;
            if (key !== undefined)
                map[key] = i;
        }
    }
    return map;
}
var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];
var h_1 = require("./h");
exports.h = h_1.h;
var thunk_1 = require("./thunk");
exports.thunk = thunk_1.thunk;
function init(modules, domApi) {
    var i, j, cbs = {};
    var api = domApi !== undefined ? domApi : htmldomapi_1.default;
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            var hook = modules[j][hooks[i]];
            if (hook !== undefined) {
                cbs[hooks[i]].push(hook);
            }
        }
    }
    function emptyNodeAt(elm) {
        var id = elm.id ? '#' + elm.id : '';
        var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
        return vnode_1.default(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        return function rmCb() {
            if (--listeners === 0) {
                var parent_1 = api.parentNode(childElm);
                api.removeChild(parent_1, childElm);
            }
        };
    }
    function createElm(vnode, insertedVnodeQueue) {
        var i, data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.init)) {
                i(vnode);
                data = vnode.data;
            }
        }
        var children = vnode.children, sel = vnode.sel;
        if (sel === '!') {
            if (isUndef(vnode.text)) {
                vnode.text = '';
            }
            vnode.elm = api.createComment(vnode.text);
        }
        else if (sel !== undefined) {
            // Parse selector
            var hashIdx = sel.indexOf('#');
            var dotIdx = sel.indexOf('.', hashIdx);
            var hash = hashIdx > 0 ? hashIdx : sel.length;
            var dot = dotIdx > 0 ? dotIdx : sel.length;
            var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
            var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)
                : api.createElement(tag);
            if (hash < dot)
                elm.setAttribute('id', sel.slice(hash + 1, dot));
            if (dotIdx > 0)
                elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' '));
            for (i = 0; i < cbs.create.length; ++i)
                cbs.create[i](emptyNode, vnode);
            if (is.array(children)) {
                for (i = 0; i < children.length; ++i) {
                    var ch = children[i];
                    if (ch != null) {
                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                    }
                }
            }
            else if (is.primitive(vnode.text)) {
                api.appendChild(elm, api.createTextNode(vnode.text));
            }
            i = vnode.data.hook; // Reuse variable
            if (isDef(i)) {
                if (i.create)
                    i.create(emptyNode, vnode);
                if (i.insert)
                    insertedVnodeQueue.push(vnode);
            }
        }
        else {
            vnode.elm = api.createTextNode(vnode.text);
        }
        return vnode.elm;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (ch != null) {
                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
            }
        }
    }
    function invokeDestroyHook(vnode) {
        var i, j, data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.destroy))
                i(vnode);
            for (i = 0; i < cbs.destroy.length; ++i)
                cbs.destroy[i](vnode);
            if (vnode.children !== undefined) {
                for (j = 0; j < vnode.children.length; ++j) {
                    i = vnode.children[j];
                    if (i != null && typeof i !== "string") {
                        invokeDestroyHook(i);
                    }
                }
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var i_1 = void 0, listeners = void 0, rm = void 0, ch = vnodes[startIdx];
            if (ch != null) {
                if (isDef(ch.sel)) {
                    invokeDestroyHook(ch);
                    listeners = cbs.remove.length + 1;
                    rm = createRmCb(ch.elm, listeners);
                    for (i_1 = 0; i_1 < cbs.remove.length; ++i_1)
                        cbs.remove[i_1](ch, rm);
                    if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
                        i_1(ch, rm);
                    }
                    else {
                        rm();
                    }
                }
                else { // Text node
                    api.removeChild(parentElm, ch.elm);
                }
            }
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
        var oldStartIdx = 0, newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx;
        var idxInOld;
        var elmToMove;
        var before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            }
            else if (oldEndVnode == null) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (newStartVnode == null) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (newEndVnode == null) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) { // New element
                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.sel !== newStartVnode.sel) {
                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    }
                    else {
                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                        oldCh[idxInOld] = undefined;
                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
            if (oldStartIdx > oldEndIdx) {
                before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
            }
            else {
                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
        var i, hook;
        if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
            i(oldVnode, vnode);
        }
        var elm = vnode.elm = oldVnode.elm;
        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (oldVnode === vnode)
            return;
        if (vnode.data !== undefined) {
            for (i = 0; i < cbs.update.length; ++i)
                cbs.update[i](oldVnode, vnode);
            i = vnode.data.hook;
            if (isDef(i) && isDef(i = i.update))
                i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch)
                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            }
            else if (isDef(ch)) {
                if (isDef(oldVnode.text))
                    api.setTextContent(elm, '');
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            }
            else if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            }
            else if (isDef(oldVnode.text)) {
                api.setTextContent(elm, '');
            }
        }
        else if (oldVnode.text !== vnode.text) {
            if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            }
            api.setTextContent(elm, vnode.text);
        }
        if (isDef(hook) && isDef(i = hook.postpatch)) {
            i(oldVnode, vnode);
        }
    }
    return function patch(oldVnode, vnode) {
        var i, elm, parent;
        var insertedVnodeQueue = [];
        for (i = 0; i < cbs.pre.length; ++i)
            cbs.pre[i]();
        if (!isVnode(oldVnode)) {
            oldVnode = emptyNodeAt(oldVnode);
        }
        if (sameVnode(oldVnode, vnode)) {
            patchVnode(oldVnode, vnode, insertedVnodeQueue);
        }
        else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode, insertedVnodeQueue);
            if (parent !== null) {
                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
                removeVnodes(parent, [oldVnode], 0, 0);
            }
        }
        for (i = 0; i < insertedVnodeQueue.length; ++i) {
            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
        }
        for (i = 0; i < cbs.post.length; ++i)
            cbs.post[i]();
        return vnode;
    };
}
exports.init = init;

},{"./h":85,"./htmldomapi":86,"./is":87,"./thunk":94,"./vnode":96}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var h_1 = require("./h");
function copyToThunk(vnode, thunk) {
    thunk.elm = vnode.elm;
    vnode.data.fn = thunk.data.fn;
    vnode.data.args = thunk.data.args;
    thunk.data = vnode.data;
    thunk.children = vnode.children;
    thunk.text = vnode.text;
    thunk.elm = vnode.elm;
}
function init(thunk) {
    var cur = thunk.data;
    var vnode = cur.fn.apply(undefined, cur.args);
    copyToThunk(vnode, thunk);
}
function prepatch(oldVnode, thunk) {
    var i, old = oldVnode.data, cur = thunk.data;
    var oldArgs = old.args, args = cur.args;
    if (old.fn !== cur.fn || oldArgs.length !== args.length) {
        copyToThunk(cur.fn.apply(undefined, args), thunk);
        return;
    }
    for (i = 0; i < args.length; ++i) {
        if (oldArgs[i] !== args[i]) {
            copyToThunk(cur.fn.apply(undefined, args), thunk);
            return;
        }
    }
    copyToThunk(oldVnode, thunk);
}
exports.thunk = function thunk(sel, key, fn, args) {
    if (args === undefined) {
        args = fn;
        fn = key;
        key = undefined;
    }
    return h_1.h(sel, {
        key: key,
        hook: { init: init, prepatch: prepatch },
        fn: fn,
        args: args
    });
};
exports.default = exports.thunk;

},{"./h":85}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("./vnode");
var htmldomapi_1 = require("./htmldomapi");
function toVNode(node, domApi) {
    var api = domApi !== undefined ? domApi : htmldomapi_1.default;
    var text;
    if (api.isElement(node)) {
        var id = node.id ? '#' + node.id : '';
        var cn = node.getAttribute('class');
        var c = cn ? '.' + cn.split(' ').join('.') : '';
        var sel = api.tagName(node).toLowerCase() + id + c;
        var attrs = {};
        var children = [];
        var name_1;
        var i = void 0, n = void 0;
        var elmAttrs = node.attributes;
        var elmChildren = node.childNodes;
        for (i = 0, n = elmAttrs.length; i < n; i++) {
            name_1 = elmAttrs[i].nodeName;
            if (name_1 !== 'id' && name_1 !== 'class') {
                attrs[name_1] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i < n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode_1.default(sel, { attrs: attrs }, children, undefined, node);
    }
    else if (api.isText(node)) {
        text = api.getTextContent(node);
        return vnode_1.default(undefined, undefined, undefined, text, node);
    }
    else if (api.isComment(node)) {
        text = api.getTextContent(node);
        return vnode_1.default('!', {}, [], text, node);
    }
    else {
        return vnode_1.default('', {}, [], undefined, node);
    }
}
exports.toVNode = toVNode;
exports.default = toVNode;

},{"./htmldomapi":86,"./vnode":96}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function vnode(sel, data, children, text, elm) {
    var key = data === undefined ? undefined : data.key;
    return { sel: sel, data: data, children: children, text: text, elm: elm, key: key };
}
exports.vnode = vnode;
exports.default = vnode;

},{}],97:[function(require,module,exports){
function noop() {}

module.exports = function (url, opts) {
	opts = opts || {};

	var ws, num=0, timer=1, $={};
	var max = opts.maxAttempts || Infinity;

	$.open = function () {
		ws = new WebSocket(url, opts.protocols || []);

		ws.onmessage = opts.onmessage || noop;

		ws.onopen = function (e) {
			(opts.onopen || noop)(e);
			num = 0;
		};

		ws.onclose = function (e) {
			e.code === 1e3 || e.code === 1001 || e.code === 1005 || $.reconnect(e);
			(opts.onclose || noop)(e);
		};

		ws.onerror = function (e) {
			(e && e.code==='ECONNREFUSED') ? $.reconnect(e) : (opts.onerror || noop)(e);
		};
	};

	$.reconnect = function (e) {
		if (timer && num++ < max) {
			timer = setTimeout(function () {
				(opts.onreconnect || noop)(e);
				$.open();
			}, opts.timeout || 1e3);
		} else {
			(opts.onmaximum || noop)(e);
		}
	};

	$.json = function (x) {
		ws.send(JSON.stringify(x));
	};

	$.send = function (x) {
		ws.send(x);
	};

	$.close = function (x, y) {
		timer = clearTimeout(timer);
		ws.close(x || 1e3, y);
	};

	$.open(); // init

	return $;
}

},{}],98:[function(require,module,exports){
(function (process){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Module = (function () {
    var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
    return (function (Module) {
        Module = Module || {};
        var Module = typeof Module !== "undefined" ? Module : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function (resolve, reject) { readyPromiseResolve = resolve; readyPromiseReject = reject; });
        var moduleOverrides = {};
        var key;
        for (key in Module) {
            if (Module.hasOwnProperty(key)) {
                moduleOverrides[key] = Module[key];
            }
        }
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = function (status, toThrow) { throw toThrow; };
        var ENVIRONMENT_IS_WEB = false;
        var ENVIRONMENT_IS_WORKER = false;
        var ENVIRONMENT_IS_NODE = false;
        var ENVIRONMENT_IS_SHELL = false;
        ENVIRONMENT_IS_WEB = typeof window === "object";
        ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
        ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
        var scriptDirectory = "";
        function locateFile(path) { if (Module["locateFile"]) {
            return Module["locateFile"](path, scriptDirectory);
        } return scriptDirectory + path; }
        var read_, readAsync, readBinary, setWindowTitle;
        if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
                scriptDirectory = self.location.href;
            }
            else if (typeof document !== "undefined" && document.currentScript) {
                scriptDirectory = document.currentScript.src;
            }
            if (_scriptDir) {
                scriptDirectory = _scriptDir;
            }
            if (scriptDirectory.indexOf("blob:") !== 0) {
                scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
            }
            else {
                scriptDirectory = "";
            }
            {
                read_ = function shell_read(url) { var xhr = new XMLHttpRequest; xhr.open("GET", url, false); xhr.send(null); return xhr.responseText; };
                if (ENVIRONMENT_IS_WORKER) {
                    readBinary = function readBinary(url) { var xhr = new XMLHttpRequest; xhr.open("GET", url, false); xhr.responseType = "arraybuffer"; xhr.send(null); return new Uint8Array(xhr.response); };
                }
                readAsync = function readAsync(url, onload, onerror) { var xhr = new XMLHttpRequest; xhr.open("GET", url, true); xhr.responseType = "arraybuffer"; xhr.onload = function xhr_onload() { if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                    onload(xhr.response);
                    return;
                } onerror(); }; xhr.onerror = onerror; xhr.send(null); };
            }
            setWindowTitle = function (title) { document.title = title; };
        }
        else { }
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.warn.bind(console);
        for (key in moduleOverrides) {
            if (moduleOverrides.hasOwnProperty(key)) {
                Module[key] = moduleOverrides[key];
            }
        }
        moduleOverrides = null;
        if (Module["arguments"])
            arguments_ = Module["arguments"];
        if (Module["thisProgram"])
            thisProgram = Module["thisProgram"];
        if (Module["quit"])
            quit_ = Module["quit"];
        var STACK_ALIGN = 16;
        function alignMemory(size, factor) { if (!factor)
            factor = STACK_ALIGN; return Math.ceil(size / factor) * factor; }
        var tempRet0 = 0;
        var setTempRet0 = function (value) { tempRet0 = value; };
        var wasmBinary;
        if (Module["wasmBinary"])
            wasmBinary = Module["wasmBinary"];
        var noExitRuntime;
        if (Module["noExitRuntime"])
            noExitRuntime = Module["noExitRuntime"];
        if (typeof WebAssembly !== "object") {
            abort("no native wasm support detected");
        }
        var wasmMemory;
        var ABORT = false;
        var EXITSTATUS = 0;
        function assert(condition, text) { if (!condition) {
            abort("Assertion failed: " + text);
        } }
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) { var endIdx = idx + maxBytesToRead; var endPtr = idx; while (heap[endPtr] && !(endPtr >= endIdx))
            ++endPtr; if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
            return UTF8Decoder.decode(heap.subarray(idx, endPtr));
        }
        else {
            var str = "";
            while (idx < endPtr) {
                var u0 = heap[idx++];
                if (!(u0 & 128)) {
                    str += String.fromCharCode(u0);
                    continue;
                }
                var u1 = heap[idx++] & 63;
                if ((u0 & 224) == 192) {
                    str += String.fromCharCode((u0 & 31) << 6 | u1);
                    continue;
                }
                var u2 = heap[idx++] & 63;
                if ((u0 & 240) == 224) {
                    u0 = (u0 & 15) << 12 | u1 << 6 | u2;
                }
                else {
                    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
                }
                if (u0 < 65536) {
                    str += String.fromCharCode(u0);
                }
                else {
                    var ch = u0 - 65536;
                    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
                }
            }
        } return str; }
        function UTF8ToString(ptr, maxBytesToRead) { return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : ""; }
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) { if (!(maxBytesToWrite > 0))
            return 0; var startIdx = outIdx; var endIdx = outIdx + maxBytesToWrite - 1; for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i);
                u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
                if (outIdx >= endIdx)
                    break;
                heap[outIdx++] = u;
            }
            else if (u <= 2047) {
                if (outIdx + 1 >= endIdx)
                    break;
                heap[outIdx++] = 192 | u >> 6;
                heap[outIdx++] = 128 | u & 63;
            }
            else if (u <= 65535) {
                if (outIdx + 2 >= endIdx)
                    break;
                heap[outIdx++] = 224 | u >> 12;
                heap[outIdx++] = 128 | u >> 6 & 63;
                heap[outIdx++] = 128 | u & 63;
            }
            else {
                if (outIdx + 3 >= endIdx)
                    break;
                heap[outIdx++] = 240 | u >> 18;
                heap[outIdx++] = 128 | u >> 12 & 63;
                heap[outIdx++] = 128 | u >> 6 & 63;
                heap[outIdx++] = 128 | u & 63;
            }
        } heap[outIdx] = 0; return outIdx - startIdx; }
        function stringToUTF8(str, outPtr, maxBytesToWrite) { return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite); }
        function lengthBytesUTF8(str) { var len = 0; for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343)
                u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
            if (u <= 127)
                ++len;
            else if (u <= 2047)
                len += 2;
            else if (u <= 65535)
                len += 3;
            else
                len += 4;
        } return len; }
        var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined;
        function UTF16ToString(ptr, maxBytesToRead) { var endPtr = ptr; var idx = endPtr >> 1; var maxIdx = idx + maxBytesToRead / 2; while (!(idx >= maxIdx) && HEAPU16[idx])
            ++idx; endPtr = idx << 1; if (endPtr - ptr > 32 && UTF16Decoder) {
            return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
        }
        else {
            var i = 0;
            var str = "";
            while (1) {
                var codeUnit = HEAP16[ptr + i * 2 >> 1];
                if (codeUnit == 0 || i == maxBytesToRead / 2)
                    return str;
                ++i;
                str += String.fromCharCode(codeUnit);
            }
        } }
        function stringToUTF16(str, outPtr, maxBytesToWrite) { if (maxBytesToWrite === undefined) {
            maxBytesToWrite = 2147483647;
        } if (maxBytesToWrite < 2)
            return 0; maxBytesToWrite -= 2; var startPtr = outPtr; var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length; for (var i = 0; i < numCharsToWrite; ++i) {
            var codeUnit = str.charCodeAt(i);
            HEAP16[outPtr >> 1] = codeUnit;
            outPtr += 2;
        } HEAP16[outPtr >> 1] = 0; return outPtr - startPtr; }
        function lengthBytesUTF16(str) { return str.length * 2; }
        function UTF32ToString(ptr, maxBytesToRead) { var i = 0; var str = ""; while (!(i >= maxBytesToRead / 4)) {
            var utf32 = HEAP32[ptr + i * 4 >> 2];
            if (utf32 == 0)
                break;
            ++i;
            if (utf32 >= 65536) {
                var ch = utf32 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
            else {
                str += String.fromCharCode(utf32);
            }
        } return str; }
        function stringToUTF32(str, outPtr, maxBytesToWrite) { if (maxBytesToWrite === undefined) {
            maxBytesToWrite = 2147483647;
        } if (maxBytesToWrite < 4)
            return 0; var startPtr = outPtr; var endPtr = startPtr + maxBytesToWrite - 4; for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343) {
                var trailSurrogate = str.charCodeAt(++i);
                codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
            }
            HEAP32[outPtr >> 2] = codeUnit;
            outPtr += 4;
            if (outPtr + 4 > endPtr)
                break;
        } HEAP32[outPtr >> 2] = 0; return outPtr - startPtr; }
        function lengthBytesUTF32(str) { var len = 0; for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343)
                ++i;
            len += 4;
        } return len; }
        function writeArrayToMemory(array, buffer) { HEAP8.set(array, buffer); }
        function writeAsciiToMemory(str, buffer, dontAddNull) { for (var i = 0; i < str.length; ++i) {
            HEAP8[buffer++ >> 0] = str.charCodeAt(i);
        } if (!dontAddNull)
            HEAP8[buffer >> 0] = 0; }
        var WASM_PAGE_SIZE = 65536;
        function alignUp(x, multiple) { if (x % multiple > 0) {
            x += multiple - x % multiple;
        } return x; }
        var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateGlobalBufferAndViews(buf) { buffer = buf; Module["HEAP8"] = HEAP8 = new Int8Array(buf); Module["HEAP16"] = HEAP16 = new Int16Array(buf); Module["HEAP32"] = HEAP32 = new Int32Array(buf); Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf); Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf); Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf); Module["HEAPF32"] = HEAPF32 = new Float32Array(buf); Module["HEAPF64"] = HEAPF64 = new Float64Array(buf); }
        var INITIAL_INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 33554432;
        if (Module["wasmMemory"]) {
            wasmMemory = Module["wasmMemory"];
        }
        else {
            wasmMemory = new WebAssembly.Memory({ "initial": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE, "maximum": 1073741824 / WASM_PAGE_SIZE });
        }
        if (wasmMemory) {
            buffer = wasmMemory.buffer;
        }
        INITIAL_INITIAL_MEMORY = buffer.byteLength;
        updateGlobalBufferAndViews(buffer);
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        var runtimeExited = false;
        function preRun() { if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
                Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
                addOnPreRun(Module["preRun"].shift());
            }
        } callRuntimeCallbacks(__ATPRERUN__); }
        function initRuntime() { runtimeInitialized = true; if (!Module["noFSInit"] && !FS.init.initialized)
            FS.init(); TTY.init(); callRuntimeCallbacks(__ATINIT__); }
        function preMain() { FS.ignorePermissions = false; callRuntimeCallbacks(__ATMAIN__); }
        function exitRuntime() { runtimeExited = true; }
        function postRun() { if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
                Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
                addOnPostRun(Module["postRun"].shift());
            }
        } callRuntimeCallbacks(__ATPOSTRUN__); }
        function addOnPreRun(cb) { __ATPRERUN__.unshift(cb); }
        function addOnPostRun(cb) { __ATPOSTRUN__.unshift(cb); }
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) { return id; }
        function addRunDependency(id) { runDependencies++; if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
        } }
        function removeRunDependency(id) { runDependencies--; if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
        } if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback();
            }
        } }
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        function abort(what) { if (Module["onAbort"]) {
            Module["onAbort"](what);
        } what += ""; err(what); ABORT = true; EXITSTATUS = 1; what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info."; var e = new WebAssembly.RuntimeError(what); readyPromiseReject(e); throw e; }
        function hasPrefix(str, prefix) { return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0; }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) { return hasPrefix(filename, dataURIPrefix); }
        var wasmBinaryFile = "ffish.wasm";
        if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary() { try {
            if (wasmBinary) {
                return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
                return readBinary(wasmBinaryFile);
            }
            else {
                throw "both async and sync fetching of the wasm failed";
            }
        }
        catch (err) {
            abort(err);
        } }
        function getBinaryPromise() { if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function") {
            return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function (response) { if (!response["ok"]) {
                throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
            } return response["arrayBuffer"](); }).catch(function () { return getBinary(); });
        } return Promise.resolve().then(getBinary); }
        function createWasm() { var info = { "a": asmLibraryArg }; function receiveInstance(instance, module) { var exports = instance.exports; Module["asm"] = exports; wasmTable = Module["asm"]["Q"]; removeRunDependency("wasm-instantiate"); } addRunDependency("wasm-instantiate"); function receiveInstantiatedSource(output) { receiveInstance(output["instance"]); } function instantiateArrayBuffer(receiver) { return getBinaryPromise().then(function (binary) { return WebAssembly.instantiate(binary, info); }).then(receiver, function (reason) { err("failed to asynchronously prepare wasm: " + reason); abort(reason); }); } function instantiateAsync() { if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && typeof fetch === "function") {
            return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function (response) { var result = WebAssembly.instantiateStreaming(response, info); return result.then(receiveInstantiatedSource, function (reason) { err("wasm streaming compile failed: " + reason); err("falling back to ArrayBuffer instantiation"); return instantiateArrayBuffer(receiveInstantiatedSource); }); });
        }
        else {
            return instantiateArrayBuffer(receiveInstantiatedSource);
        } } if (Module["instantiateWasm"]) {
            try {
                var exports = Module["instantiateWasm"](info, receiveInstance);
                return exports;
            }
            catch (e) {
                err("Module.instantiateWasm callback failed with error: " + e);
                return false;
            }
        } instantiateAsync().catch(readyPromiseReject); return {}; }
        var tempDouble;
        var tempI64;
        function callRuntimeCallbacks(callbacks) { while (callbacks.length > 0) {
            var callback = callbacks.shift();
            if (typeof callback == "function") {
                callback(Module);
                continue;
            }
            var func = callback.func;
            if (typeof func === "number") {
                if (callback.arg === undefined) {
                    wasmTable.get(func)();
                }
                else {
                    wasmTable.get(func)(callback.arg);
                }
            }
            else {
                func(callback.arg === undefined ? null : callback.arg);
            }
        } }
        function demangle(func) { return func; }
        function demangleAll(text) { var regex = /\b_Z[\w\d_]+/g; return text.replace(regex, function (x) { var y = demangle(x); return x === y ? x : y + " [" + x + "]"; }); }
        function dynCallLegacy(sig, ptr, args) { if (args && args.length) {
            return Module["dynCall_" + sig].apply(null, [ptr].concat(args));
        } return Module["dynCall_" + sig].call(null, ptr); }
        function dynCall(sig, ptr, args) { if (sig.indexOf("j") != -1) {
            return dynCallLegacy(sig, ptr, args);
        } return wasmTable.get(ptr).apply(null, args); }
        function jsStackTrace() { var error = new Error; if (!error.stack) {
            try {
                throw new Error;
            }
            catch (e) {
                error = e;
            }
            if (!error.stack) {
                return "(no stack trace available)";
            }
        } return error.stack.toString(); }
        function stackTrace() { var js = jsStackTrace(); if (Module["extraStackTrace"])
            js += "\n" + Module["extraStackTrace"](); return demangleAll(js); }
        var ExceptionInfoAttrs = { DESTRUCTOR_OFFSET: 0, REFCOUNT_OFFSET: 4, TYPE_OFFSET: 8, CAUGHT_OFFSET: 12, RETHROWN_OFFSET: 13, SIZE: 16 };
        function ___cxa_allocate_exception(size) { return _malloc(size + ExceptionInfoAttrs.SIZE) + ExceptionInfoAttrs.SIZE; }
        function ExceptionInfo(excPtr) { this.excPtr = excPtr; this.ptr = excPtr - ExceptionInfoAttrs.SIZE; this.set_type = function (type) { HEAP32[this.ptr + ExceptionInfoAttrs.TYPE_OFFSET >> 2] = type; }; this.get_type = function () { return HEAP32[this.ptr + ExceptionInfoAttrs.TYPE_OFFSET >> 2]; }; this.set_destructor = function (destructor) { HEAP32[this.ptr + ExceptionInfoAttrs.DESTRUCTOR_OFFSET >> 2] = destructor; }; this.get_destructor = function () { return HEAP32[this.ptr + ExceptionInfoAttrs.DESTRUCTOR_OFFSET >> 2]; }; this.set_refcount = function (refcount) { HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2] = refcount; }; this.set_caught = function (caught) { caught = caught ? 1 : 0; HEAP8[this.ptr + ExceptionInfoAttrs.CAUGHT_OFFSET >> 0] = caught; }; this.get_caught = function () { return HEAP8[this.ptr + ExceptionInfoAttrs.CAUGHT_OFFSET >> 0] != 0; }; this.set_rethrown = function (rethrown) { rethrown = rethrown ? 1 : 0; HEAP8[this.ptr + ExceptionInfoAttrs.RETHROWN_OFFSET >> 0] = rethrown; }; this.get_rethrown = function () { return HEAP8[this.ptr + ExceptionInfoAttrs.RETHROWN_OFFSET >> 0] != 0; }; this.init = function (type, destructor) { this.set_type(type); this.set_destructor(destructor); this.set_refcount(0); this.set_caught(false); this.set_rethrown(false); }; this.add_ref = function () { var value = HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2]; HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2] = value + 1; }; this.release_ref = function () { var prev = HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2]; HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2] = prev - 1; return prev === 1; }; }
        var exceptionLast = 0;
        function __ZSt18uncaught_exceptionv() { return __ZSt18uncaught_exceptionv.uncaught_exceptions > 0; }
        function ___cxa_throw(ptr, type, destructor) { var info = new ExceptionInfo(ptr); info.init(type, destructor); exceptionLast = ptr; if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
            __ZSt18uncaught_exceptionv.uncaught_exceptions = 1;
        }
        else {
            __ZSt18uncaught_exceptionv.uncaught_exceptions++;
        } throw ptr; }
        function setErrNo(value) { HEAP32[___errno_location() >> 2] = value; return value; }
        var PATH = { splitPath: function (filename) { var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/; return splitPathRe.exec(filename).slice(1); }, normalizeArray: function (parts, allowAboveRoot) { var up = 0; for (var i = parts.length - 1; i >= 0; i--) {
                var last = parts[i];
                if (last === ".") {
                    parts.splice(i, 1);
                }
                else if (last === "..") {
                    parts.splice(i, 1);
                    up++;
                }
                else if (up) {
                    parts.splice(i, 1);
                    up--;
                }
            } if (allowAboveRoot) {
                for (; up; up--) {
                    parts.unshift("..");
                }
            } return parts; }, normalize: function (path) { var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/"; path = PATH.normalizeArray(path.split("/").filter(function (p) { return !!p; }), !isAbsolute).join("/"); if (!path && !isAbsolute) {
                path = ".";
            } if (path && trailingSlash) {
                path += "/";
            } return (isAbsolute ? "/" : "") + path; }, dirname: function (path) { var result = PATH.splitPath(path), root = result[0], dir = result[1]; if (!root && !dir) {
                return ".";
            } if (dir) {
                dir = dir.substr(0, dir.length - 1);
            } return root + dir; }, basename: function (path) { if (path === "/")
                return "/"; path = PATH.normalize(path); path = path.replace(/\/$/, ""); var lastSlash = path.lastIndexOf("/"); if (lastSlash === -1)
                return path; return path.substr(lastSlash + 1); }, extname: function (path) { return PATH.splitPath(path)[3]; }, join: function () { var paths = Array.prototype.slice.call(arguments, 0); return PATH.normalize(paths.join("/")); }, join2: function (l, r) { return PATH.normalize(l + "/" + r); } };
        function getRandomDevice() { if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
            var randomBuffer = new Uint8Array(1);
            return function () { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
        }
        else
            return function () { abort("randomDevice"); }; }
        var PATH_FS = { resolve: function () { var resolvedPath = "", resolvedAbsolute = false; for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path = i >= 0 ? arguments[i] : FS.cwd();
                if (typeof path !== "string") {
                    throw new TypeError("Arguments to path.resolve must be strings");
                }
                else if (!path) {
                    return "";
                }
                resolvedPath = path + "/" + resolvedPath;
                resolvedAbsolute = path.charAt(0) === "/";
            } resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function (p) { return !!p; }), !resolvedAbsolute).join("/"); return (resolvedAbsolute ? "/" : "") + resolvedPath || "."; }, relative: function (from, to) { from = PATH_FS.resolve(from).substr(1); to = PATH_FS.resolve(to).substr(1); function trim(arr) { var start = 0; for (; start < arr.length; start++) {
                if (arr[start] !== "")
                    break;
            } var end = arr.length - 1; for (; end >= 0; end--) {
                if (arr[end] !== "")
                    break;
            } if (start > end)
                return []; return arr.slice(start, end - start + 1); } var fromParts = trim(from.split("/")); var toParts = trim(to.split("/")); var length = Math.min(fromParts.length, toParts.length); var samePartsLength = length; for (var i = 0; i < length; i++) {
                if (fromParts[i] !== toParts[i]) {
                    samePartsLength = i;
                    break;
                }
            } var outputParts = []; for (var i = samePartsLength; i < fromParts.length; i++) {
                outputParts.push("..");
            } outputParts = outputParts.concat(toParts.slice(samePartsLength)); return outputParts.join("/"); } };
        var TTY = { ttys: [], init: function () { }, shutdown: function () { }, register: function (dev, ops) { TTY.ttys[dev] = { input: [], output: [], ops: ops }; FS.registerDevice(dev, TTY.stream_ops); }, stream_ops: { open: function (stream) { var tty = TTY.ttys[stream.node.rdev]; if (!tty) {
                    throw new FS.ErrnoError(43);
                } stream.tty = tty; stream.seekable = false; }, close: function (stream) { stream.tty.ops.flush(stream.tty); }, flush: function (stream) { stream.tty.ops.flush(stream.tty); }, read: function (stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.get_char) {
                    throw new FS.ErrnoError(60);
                } var bytesRead = 0; for (var i = 0; i < length; i++) {
                    var result;
                    try {
                        result = stream.tty.ops.get_char(stream.tty);
                    }
                    catch (e) {
                        throw new FS.ErrnoError(29);
                    }
                    if (result === undefined && bytesRead === 0) {
                        throw new FS.ErrnoError(6);
                    }
                    if (result === null || result === undefined)
                        break;
                    bytesRead++;
                    buffer[offset + i] = result;
                } if (bytesRead) {
                    stream.node.timestamp = Date.now();
                } return bytesRead; }, write: function (stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.put_char) {
                    throw new FS.ErrnoError(60);
                } try {
                    for (var i = 0; i < length; i++) {
                        stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
                    }
                }
                catch (e) {
                    throw new FS.ErrnoError(29);
                } if (length) {
                    stream.node.timestamp = Date.now();
                } return i; } }, default_tty_ops: { get_char: function (tty) { if (!tty.input.length) {
                    var result = null;
                    if (typeof window != "undefined" && typeof window.prompt == "function") {
                        result = window.prompt("Input: ");
                        if (result !== null) {
                            result += "\n";
                        }
                    }
                    else if (typeof readline == "function") {
                        result = readline();
                        if (result !== null) {
                            result += "\n";
                        }
                    }
                    if (!result) {
                        return null;
                    }
                    tty.input = intArrayFromString(result, true);
                } return tty.input.shift(); }, put_char: function (tty, val) { if (val === null || val === 10) {
                    out(UTF8ArrayToString(tty.output, 0));
                    tty.output = [];
                }
                else {
                    if (val != 0)
                        tty.output.push(val);
                } }, flush: function (tty) { if (tty.output && tty.output.length > 0) {
                    out(UTF8ArrayToString(tty.output, 0));
                    tty.output = [];
                } } }, default_tty1_ops: { put_char: function (tty, val) { if (val === null || val === 10) {
                    err(UTF8ArrayToString(tty.output, 0));
                    tty.output = [];
                }
                else {
                    if (val != 0)
                        tty.output.push(val);
                } }, flush: function (tty) { if (tty.output && tty.output.length > 0) {
                    err(UTF8ArrayToString(tty.output, 0));
                    tty.output = [];
                } } } };
        function mmapAlloc(size) { var alignedSize = alignMemory(size, 16384); var ptr = _malloc(alignedSize); while (size < alignedSize)
            HEAP8[ptr + size++] = 0; return ptr; }
        var MEMFS = { ops_table: null, mount: function (mount) { return MEMFS.createNode(null, "/", 16384 | 511, 0); }, createNode: function (parent, name, mode, dev) { if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
                throw new FS.ErrnoError(63);
            } if (!MEMFS.ops_table) {
                MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
            } var node = FS.createNode(parent, name, mode, dev); if (FS.isDir(node.mode)) {
                node.node_ops = MEMFS.ops_table.dir.node;
                node.stream_ops = MEMFS.ops_table.dir.stream;
                node.contents = {};
            }
            else if (FS.isFile(node.mode)) {
                node.node_ops = MEMFS.ops_table.file.node;
                node.stream_ops = MEMFS.ops_table.file.stream;
                node.usedBytes = 0;
                node.contents = null;
            }
            else if (FS.isLink(node.mode)) {
                node.node_ops = MEMFS.ops_table.link.node;
                node.stream_ops = MEMFS.ops_table.link.stream;
            }
            else if (FS.isChrdev(node.mode)) {
                node.node_ops = MEMFS.ops_table.chrdev.node;
                node.stream_ops = MEMFS.ops_table.chrdev.stream;
            } node.timestamp = Date.now(); if (parent) {
                parent.contents[name] = node;
            } return node; }, getFileDataAsRegularArray: function (node) { if (node.contents && node.contents.subarray) {
                var arr = [];
                for (var i = 0; i < node.usedBytes; ++i)
                    arr.push(node.contents[i]);
                return arr;
            } return node.contents; }, getFileDataAsTypedArray: function (node) { if (!node.contents)
                return new Uint8Array(0); if (node.contents.subarray)
                return node.contents.subarray(0, node.usedBytes); return new Uint8Array(node.contents); }, expandFileStorage: function (node, newCapacity) { var prevCapacity = node.contents ? node.contents.length : 0; if (prevCapacity >= newCapacity)
                return; var CAPACITY_DOUBLING_MAX = 1024 * 1024; newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0); if (prevCapacity != 0)
                newCapacity = Math.max(newCapacity, 256); var oldContents = node.contents; node.contents = new Uint8Array(newCapacity); if (node.usedBytes > 0)
                node.contents.set(oldContents.subarray(0, node.usedBytes), 0); return; }, resizeFileStorage: function (node, newSize) { if (node.usedBytes == newSize)
                return; if (newSize == 0) {
                node.contents = null;
                node.usedBytes = 0;
                return;
            } if (!node.contents || node.contents.subarray) {
                var oldContents = node.contents;
                node.contents = new Uint8Array(newSize);
                if (oldContents) {
                    node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
                }
                node.usedBytes = newSize;
                return;
            } if (!node.contents)
                node.contents = []; if (node.contents.length > newSize)
                node.contents.length = newSize;
            else
                while (node.contents.length < newSize)
                    node.contents.push(0); node.usedBytes = newSize; }, node_ops: { getattr: function (node) { var attr = {}; attr.dev = FS.isChrdev(node.mode) ? node.id : 1; attr.ino = node.id; attr.mode = node.mode; attr.nlink = 1; attr.uid = 0; attr.gid = 0; attr.rdev = node.rdev; if (FS.isDir(node.mode)) {
                    attr.size = 4096;
                }
                else if (FS.isFile(node.mode)) {
                    attr.size = node.usedBytes;
                }
                else if (FS.isLink(node.mode)) {
                    attr.size = node.link.length;
                }
                else {
                    attr.size = 0;
                } attr.atime = new Date(node.timestamp); attr.mtime = new Date(node.timestamp); attr.ctime = new Date(node.timestamp); attr.blksize = 4096; attr.blocks = Math.ceil(attr.size / attr.blksize); return attr; }, setattr: function (node, attr) { if (attr.mode !== undefined) {
                    node.mode = attr.mode;
                } if (attr.timestamp !== undefined) {
                    node.timestamp = attr.timestamp;
                } if (attr.size !== undefined) {
                    MEMFS.resizeFileStorage(node, attr.size);
                } }, lookup: function (parent, name) { throw FS.genericErrors[44]; }, mknod: function (parent, name, mode, dev) { return MEMFS.createNode(parent, name, mode, dev); }, rename: function (old_node, new_dir, new_name) { if (FS.isDir(old_node.mode)) {
                    var new_node;
                    try {
                        new_node = FS.lookupNode(new_dir, new_name);
                    }
                    catch (e) { }
                    if (new_node) {
                        for (var i in new_node.contents) {
                            throw new FS.ErrnoError(55);
                        }
                    }
                } delete old_node.parent.contents[old_node.name]; old_node.name = new_name; new_dir.contents[new_name] = old_node; old_node.parent = new_dir; }, unlink: function (parent, name) { delete parent.contents[name]; }, rmdir: function (parent, name) { var node = FS.lookupNode(parent, name); for (var i in node.contents) {
                    throw new FS.ErrnoError(55);
                } delete parent.contents[name]; }, readdir: function (node) { var entries = [".", ".."]; for (var key in node.contents) {
                    if (!node.contents.hasOwnProperty(key)) {
                        continue;
                    }
                    entries.push(key);
                } return entries; }, symlink: function (parent, newname, oldpath) { var node = MEMFS.createNode(parent, newname, 511 | 40960, 0); node.link = oldpath; return node; }, readlink: function (node) { if (!FS.isLink(node.mode)) {
                    throw new FS.ErrnoError(28);
                } return node.link; } }, stream_ops: { read: function (stream, buffer, offset, length, position) { var contents = stream.node.contents; if (position >= stream.node.usedBytes)
                    return 0; var size = Math.min(stream.node.usedBytes - position, length); if (size > 8 && contents.subarray) {
                    buffer.set(contents.subarray(position, position + size), offset);
                }
                else {
                    for (var i = 0; i < size; i++)
                        buffer[offset + i] = contents[position + i];
                } return size; }, write: function (stream, buffer, offset, length, position, canOwn) { if (buffer.buffer === HEAP8.buffer) {
                    canOwn = false;
                } if (!length)
                    return 0; var node = stream.node; node.timestamp = Date.now(); if (buffer.subarray && (!node.contents || node.contents.subarray)) {
                    if (canOwn) {
                        node.contents = buffer.subarray(offset, offset + length);
                        node.usedBytes = length;
                        return length;
                    }
                    else if (node.usedBytes === 0 && position === 0) {
                        node.contents = buffer.slice(offset, offset + length);
                        node.usedBytes = length;
                        return length;
                    }
                    else if (position + length <= node.usedBytes) {
                        node.contents.set(buffer.subarray(offset, offset + length), position);
                        return length;
                    }
                } MEMFS.expandFileStorage(node, position + length); if (node.contents.subarray && buffer.subarray) {
                    node.contents.set(buffer.subarray(offset, offset + length), position);
                }
                else {
                    for (var i = 0; i < length; i++) {
                        node.contents[position + i] = buffer[offset + i];
                    }
                } node.usedBytes = Math.max(node.usedBytes, position + length); return length; }, llseek: function (stream, offset, whence) { var position = offset; if (whence === 1) {
                    position += stream.position;
                }
                else if (whence === 2) {
                    if (FS.isFile(stream.node.mode)) {
                        position += stream.node.usedBytes;
                    }
                } if (position < 0) {
                    throw new FS.ErrnoError(28);
                } return position; }, allocate: function (stream, offset, length) { MEMFS.expandFileStorage(stream.node, offset + length); stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length); }, mmap: function (stream, address, length, position, prot, flags) { assert(address === 0); if (!FS.isFile(stream.node.mode)) {
                    throw new FS.ErrnoError(43);
                } var ptr; var allocated; var contents = stream.node.contents; if (!(flags & 2) && contents.buffer === buffer) {
                    allocated = false;
                    ptr = contents.byteOffset;
                }
                else {
                    if (position > 0 || position + length < contents.length) {
                        if (contents.subarray) {
                            contents = contents.subarray(position, position + length);
                        }
                        else {
                            contents = Array.prototype.slice.call(contents, position, position + length);
                        }
                    }
                    allocated = true;
                    ptr = mmapAlloc(length);
                    if (!ptr) {
                        throw new FS.ErrnoError(48);
                    }
                    HEAP8.set(contents, ptr);
                } return { ptr: ptr, allocated: allocated }; }, msync: function (stream, buffer, offset, length, mmapFlags) { if (!FS.isFile(stream.node.mode)) {
                    throw new FS.ErrnoError(43);
                } if (mmapFlags & 2) {
                    return 0;
                } var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false); return 0; } } };
        var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, handleFSError: function (e) { if (!(e instanceof FS.ErrnoError))
                throw e + " : " + stackTrace(); return setErrNo(e.errno); }, lookupPath: function (path, opts) { path = PATH_FS.resolve(FS.cwd(), path); opts = opts || {}; if (!path)
                return { path: "", node: null }; var defaults = { follow_mount: true, recurse_count: 0 }; for (var key in defaults) {
                if (opts[key] === undefined) {
                    opts[key] = defaults[key];
                }
            } if (opts.recurse_count > 8) {
                throw new FS.ErrnoError(32);
            } var parts = PATH.normalizeArray(path.split("/").filter(function (p) { return !!p; }), false); var current = FS.root; var current_path = "/"; for (var i = 0; i < parts.length; i++) {
                var islast = i === parts.length - 1;
                if (islast && opts.parent) {
                    break;
                }
                current = FS.lookupNode(current, parts[i]);
                current_path = PATH.join2(current_path, parts[i]);
                if (FS.isMountpoint(current)) {
                    if (!islast || islast && opts.follow_mount) {
                        current = current.mounted.root;
                    }
                }
                if (!islast || opts.follow) {
                    var count = 0;
                    while (FS.isLink(current.mode)) {
                        var link = FS.readlink(current_path);
                        current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                        var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                        current = lookup.node;
                        if (count++ > 40) {
                            throw new FS.ErrnoError(32);
                        }
                    }
                }
            } return { path: current_path, node: current }; }, getPath: function (node) { var path; while (true) {
                if (FS.isRoot(node)) {
                    var mount = node.mount.mountpoint;
                    if (!path)
                        return mount;
                    return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
                }
                path = path ? node.name + "/" + path : node.name;
                node = node.parent;
            } }, hashName: function (parentid, name) { var hash = 0; for (var i = 0; i < name.length; i++) {
                hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
            } return (parentid + hash >>> 0) % FS.nameTable.length; }, hashAddNode: function (node) { var hash = FS.hashName(node.parent.id, node.name); node.name_next = FS.nameTable[hash]; FS.nameTable[hash] = node; }, hashRemoveNode: function (node) { var hash = FS.hashName(node.parent.id, node.name); if (FS.nameTable[hash] === node) {
                FS.nameTable[hash] = node.name_next;
            }
            else {
                var current = FS.nameTable[hash];
                while (current) {
                    if (current.name_next === node) {
                        current.name_next = node.name_next;
                        break;
                    }
                    current = current.name_next;
                }
            } }, lookupNode: function (parent, name) { var errCode = FS.mayLookup(parent); if (errCode) {
                throw new FS.ErrnoError(errCode, parent);
            } var hash = FS.hashName(parent.id, name); for (var node = FS.nameTable[hash]; node; node = node.name_next) {
                var nodeName = node.name;
                if (node.parent.id === parent.id && nodeName === name) {
                    return node;
                }
            } return FS.lookup(parent, name); }, createNode: function (parent, name, mode, rdev) { var node = new FS.FSNode(parent, name, mode, rdev); FS.hashAddNode(node); return node; }, destroyNode: function (node) { FS.hashRemoveNode(node); }, isRoot: function (node) { return node === node.parent; }, isMountpoint: function (node) { return !!node.mounted; }, isFile: function (mode) { return (mode & 61440) === 32768; }, isDir: function (mode) { return (mode & 61440) === 16384; }, isLink: function (mode) { return (mode & 61440) === 40960; }, isChrdev: function (mode) { return (mode & 61440) === 8192; }, isBlkdev: function (mode) { return (mode & 61440) === 24576; }, isFIFO: function (mode) { return (mode & 61440) === 4096; }, isSocket: function (mode) { return (mode & 49152) === 49152; }, flagModes: { "r": 0, "rs": 1052672, "r+": 2, "w": 577, "wx": 705, "xw": 705, "w+": 578, "wx+": 706, "xw+": 706, "a": 1089, "ax": 1217, "xa": 1217, "a+": 1090, "ax+": 1218, "xa+": 1218 }, modeStringToFlags: function (str) { var flags = FS.flagModes[str]; if (typeof flags === "undefined") {
                throw new Error("Unknown file open mode: " + str);
            } return flags; }, flagsToPermissionString: function (flag) { var perms = ["r", "w", "rw"][flag & 3]; if (flag & 512) {
                perms += "w";
            } return perms; }, nodePermissions: function (node, perms) { if (FS.ignorePermissions) {
                return 0;
            } if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
                return 2;
            }
            else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
                return 2;
            }
            else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
                return 2;
            } return 0; }, mayLookup: function (dir) { var errCode = FS.nodePermissions(dir, "x"); if (errCode)
                return errCode; if (!dir.node_ops.lookup)
                return 2; return 0; }, mayCreate: function (dir, name) { try {
                var node = FS.lookupNode(dir, name);
                return 20;
            }
            catch (e) { } return FS.nodePermissions(dir, "wx"); }, mayDelete: function (dir, name, isdir) { var node; try {
                node = FS.lookupNode(dir, name);
            }
            catch (e) {
                return e.errno;
            } var errCode = FS.nodePermissions(dir, "wx"); if (errCode) {
                return errCode;
            } if (isdir) {
                if (!FS.isDir(node.mode)) {
                    return 54;
                }
                if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                    return 10;
                }
            }
            else {
                if (FS.isDir(node.mode)) {
                    return 31;
                }
            } return 0; }, mayOpen: function (node, flags) { if (!node) {
                return 44;
            } if (FS.isLink(node.mode)) {
                return 32;
            }
            else if (FS.isDir(node.mode)) {
                if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
                    return 31;
                }
            } return FS.nodePermissions(node, FS.flagsToPermissionString(flags)); }, MAX_OPEN_FDS: 4096, nextfd: function (fd_start, fd_end) { fd_start = fd_start || 0; fd_end = fd_end || FS.MAX_OPEN_FDS; for (var fd = fd_start; fd <= fd_end; fd++) {
                if (!FS.streams[fd]) {
                    return fd;
                }
            } throw new FS.ErrnoError(33); }, getStream: function (fd) { return FS.streams[fd]; }, createStream: function (stream, fd_start, fd_end) { if (!FS.FSStream) {
                FS.FSStream = function () { };
                FS.FSStream.prototype = { object: { get: function () { return this.node; }, set: function (val) { this.node = val; } }, isRead: { get: function () { return (this.flags & 2097155) !== 1; } }, isWrite: { get: function () { return (this.flags & 2097155) !== 0; } }, isAppend: { get: function () { return this.flags & 1024; } } };
            } var newStream = new FS.FSStream; for (var p in stream) {
                newStream[p] = stream[p];
            } stream = newStream; var fd = FS.nextfd(fd_start, fd_end); stream.fd = fd; FS.streams[fd] = stream; return stream; }, closeStream: function (fd) { FS.streams[fd] = null; }, chrdev_stream_ops: { open: function (stream) { var device = FS.getDevice(stream.node.rdev); stream.stream_ops = device.stream_ops; if (stream.stream_ops.open) {
                    stream.stream_ops.open(stream);
                } }, llseek: function () { throw new FS.ErrnoError(70); } }, major: function (dev) { return dev >> 8; }, minor: function (dev) { return dev & 255; }, makedev: function (ma, mi) { return ma << 8 | mi; }, registerDevice: function (dev, ops) { FS.devices[dev] = { stream_ops: ops }; }, getDevice: function (dev) { return FS.devices[dev]; }, getMounts: function (mount) { var mounts = []; var check = [mount]; while (check.length) {
                var m = check.pop();
                mounts.push(m);
                check.push.apply(check, m.mounts);
            } return mounts; }, syncfs: function (populate, callback) { if (typeof populate === "function") {
                callback = populate;
                populate = false;
            } FS.syncFSRequests++; if (FS.syncFSRequests > 1) {
                err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
            } var mounts = FS.getMounts(FS.root.mount); var completed = 0; function doCallback(errCode) { FS.syncFSRequests--; return callback(errCode); } function done(errCode) { if (errCode) {
                if (!done.errored) {
                    done.errored = true;
                    return doCallback(errCode);
                }
                return;
            } if (++completed >= mounts.length) {
                doCallback(null);
            } } mounts.forEach(function (mount) { if (!mount.type.syncfs) {
                return done(null);
            } mount.type.syncfs(mount, populate, done); }); }, mount: function (type, opts, mountpoint) { var root = mountpoint === "/"; var pseudo = !mountpoint; var node; if (root && FS.root) {
                throw new FS.ErrnoError(10);
            }
            else if (!root && !pseudo) {
                var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
                mountpoint = lookup.path;
                node = lookup.node;
                if (FS.isMountpoint(node)) {
                    throw new FS.ErrnoError(10);
                }
                if (!FS.isDir(node.mode)) {
                    throw new FS.ErrnoError(54);
                }
            } var mount = { type: type, opts: opts, mountpoint: mountpoint, mounts: [] }; var mountRoot = type.mount(mount); mountRoot.mount = mount; mount.root = mountRoot; if (root) {
                FS.root = mountRoot;
            }
            else if (node) {
                node.mounted = mount;
                if (node.mount) {
                    node.mount.mounts.push(mount);
                }
            } return mountRoot; }, unmount: function (mountpoint) { var lookup = FS.lookupPath(mountpoint, { follow_mount: false }); if (!FS.isMountpoint(lookup.node)) {
                throw new FS.ErrnoError(28);
            } var node = lookup.node; var mount = node.mounted; var mounts = FS.getMounts(mount); Object.keys(FS.nameTable).forEach(function (hash) { var current = FS.nameTable[hash]; while (current) {
                var next = current.name_next;
                if (mounts.indexOf(current.mount) !== -1) {
                    FS.destroyNode(current);
                }
                current = next;
            } }); node.mounted = null; var idx = node.mount.mounts.indexOf(mount); node.mount.mounts.splice(idx, 1); }, lookup: function (parent, name) { return parent.node_ops.lookup(parent, name); }, mknod: function (path, mode, dev) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); if (!name || name === "." || name === "..") {
                throw new FS.ErrnoError(28);
            } var errCode = FS.mayCreate(parent, name); if (errCode) {
                throw new FS.ErrnoError(errCode);
            } if (!parent.node_ops.mknod) {
                throw new FS.ErrnoError(63);
            } return parent.node_ops.mknod(parent, name, mode, dev); }, create: function (path, mode) { mode = mode !== undefined ? mode : 438; mode &= 4095; mode |= 32768; return FS.mknod(path, mode, 0); }, mkdir: function (path, mode) { mode = mode !== undefined ? mode : 511; mode &= 511 | 512; mode |= 16384; return FS.mknod(path, mode, 0); }, mkdirTree: function (path, mode) { var dirs = path.split("/"); var d = ""; for (var i = 0; i < dirs.length; ++i) {
                if (!dirs[i])
                    continue;
                d += "/" + dirs[i];
                try {
                    FS.mkdir(d, mode);
                }
                catch (e) {
                    if (e.errno != 20)
                        throw e;
                }
            } }, mkdev: function (path, mode, dev) { if (typeof dev === "undefined") {
                dev = mode;
                mode = 438;
            } mode |= 8192; return FS.mknod(path, mode, dev); }, symlink: function (oldpath, newpath) { if (!PATH_FS.resolve(oldpath)) {
                throw new FS.ErrnoError(44);
            } var lookup = FS.lookupPath(newpath, { parent: true }); var parent = lookup.node; if (!parent) {
                throw new FS.ErrnoError(44);
            } var newname = PATH.basename(newpath); var errCode = FS.mayCreate(parent, newname); if (errCode) {
                throw new FS.ErrnoError(errCode);
            } if (!parent.node_ops.symlink) {
                throw new FS.ErrnoError(63);
            } return parent.node_ops.symlink(parent, newname, oldpath); }, rename: function (old_path, new_path) { var old_dirname = PATH.dirname(old_path); var new_dirname = PATH.dirname(new_path); var old_name = PATH.basename(old_path); var new_name = PATH.basename(new_path); var lookup, old_dir, new_dir; lookup = FS.lookupPath(old_path, { parent: true }); old_dir = lookup.node; lookup = FS.lookupPath(new_path, { parent: true }); new_dir = lookup.node; if (!old_dir || !new_dir)
                throw new FS.ErrnoError(44); if (old_dir.mount !== new_dir.mount) {
                throw new FS.ErrnoError(75);
            } var old_node = FS.lookupNode(old_dir, old_name); var relative = PATH_FS.relative(old_path, new_dirname); if (relative.charAt(0) !== ".") {
                throw new FS.ErrnoError(28);
            } relative = PATH_FS.relative(new_path, old_dirname); if (relative.charAt(0) !== ".") {
                throw new FS.ErrnoError(55);
            } var new_node; try {
                new_node = FS.lookupNode(new_dir, new_name);
            }
            catch (e) { } if (old_node === new_node) {
                return;
            } var isdir = FS.isDir(old_node.mode); var errCode = FS.mayDelete(old_dir, old_name, isdir); if (errCode) {
                throw new FS.ErrnoError(errCode);
            } errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name); if (errCode) {
                throw new FS.ErrnoError(errCode);
            } if (!old_dir.node_ops.rename) {
                throw new FS.ErrnoError(63);
            } if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
                throw new FS.ErrnoError(10);
            } if (new_dir !== old_dir) {
                errCode = FS.nodePermissions(old_dir, "w");
                if (errCode) {
                    throw new FS.ErrnoError(errCode);
                }
            } try {
                if (FS.trackingDelegate["willMovePath"]) {
                    FS.trackingDelegate["willMovePath"](old_path, new_path);
                }
            }
            catch (e) {
                err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
            } FS.hashRemoveNode(old_node); try {
                old_dir.node_ops.rename(old_node, new_dir, new_name);
            }
            catch (e) {
                throw e;
            }
            finally {
                FS.hashAddNode(old_node);
            } try {
                if (FS.trackingDelegate["onMovePath"])
                    FS.trackingDelegate["onMovePath"](old_path, new_path);
            }
            catch (e) {
                err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
            } }, rmdir: function (path) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); var node = FS.lookupNode(parent, name); var errCode = FS.mayDelete(parent, name, true); if (errCode) {
                throw new FS.ErrnoError(errCode);
            } if (!parent.node_ops.rmdir) {
                throw new FS.ErrnoError(63);
            } if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
            } try {
                if (FS.trackingDelegate["willDeletePath"]) {
                    FS.trackingDelegate["willDeletePath"](path);
                }
            }
            catch (e) {
                err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
            } parent.node_ops.rmdir(parent, name); FS.destroyNode(node); try {
                if (FS.trackingDelegate["onDeletePath"])
                    FS.trackingDelegate["onDeletePath"](path);
            }
            catch (e) {
                err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
            } }, readdir: function (path) { var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; if (!node.node_ops.readdir) {
                throw new FS.ErrnoError(54);
            } return node.node_ops.readdir(node); }, unlink: function (path) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); var node = FS.lookupNode(parent, name); var errCode = FS.mayDelete(parent, name, false); if (errCode) {
                throw new FS.ErrnoError(errCode);
            } if (!parent.node_ops.unlink) {
                throw new FS.ErrnoError(63);
            } if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
            } try {
                if (FS.trackingDelegate["willDeletePath"]) {
                    FS.trackingDelegate["willDeletePath"](path);
                }
            }
            catch (e) {
                err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
            } parent.node_ops.unlink(parent, name); FS.destroyNode(node); try {
                if (FS.trackingDelegate["onDeletePath"])
                    FS.trackingDelegate["onDeletePath"](path);
            }
            catch (e) {
                err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
            } }, readlink: function (path) { var lookup = FS.lookupPath(path); var link = lookup.node; if (!link) {
                throw new FS.ErrnoError(44);
            } if (!link.node_ops.readlink) {
                throw new FS.ErrnoError(28);
            } return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link)); }, stat: function (path, dontFollow) { var lookup = FS.lookupPath(path, { follow: !dontFollow }); var node = lookup.node; if (!node) {
                throw new FS.ErrnoError(44);
            } if (!node.node_ops.getattr) {
                throw new FS.ErrnoError(63);
            } return node.node_ops.getattr(node); }, lstat: function (path) { return FS.stat(path, true); }, chmod: function (path, mode, dontFollow) { var node; if (typeof path === "string") {
                var lookup = FS.lookupPath(path, { follow: !dontFollow });
                node = lookup.node;
            }
            else {
                node = path;
            } if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(63);
            } node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() }); }, lchmod: function (path, mode) { FS.chmod(path, mode, true); }, fchmod: function (fd, mode) { var stream = FS.getStream(fd); if (!stream) {
                throw new FS.ErrnoError(8);
            } FS.chmod(stream.node, mode); }, chown: function (path, uid, gid, dontFollow) { var node; if (typeof path === "string") {
                var lookup = FS.lookupPath(path, { follow: !dontFollow });
                node = lookup.node;
            }
            else {
                node = path;
            } if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(63);
            } node.node_ops.setattr(node, { timestamp: Date.now() }); }, lchown: function (path, uid, gid) { FS.chown(path, uid, gid, true); }, fchown: function (fd, uid, gid) { var stream = FS.getStream(fd); if (!stream) {
                throw new FS.ErrnoError(8);
            } FS.chown(stream.node, uid, gid); }, truncate: function (path, len) { if (len < 0) {
                throw new FS.ErrnoError(28);
            } var node; if (typeof path === "string") {
                var lookup = FS.lookupPath(path, { follow: true });
                node = lookup.node;
            }
            else {
                node = path;
            } if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(63);
            } if (FS.isDir(node.mode)) {
                throw new FS.ErrnoError(31);
            } if (!FS.isFile(node.mode)) {
                throw new FS.ErrnoError(28);
            } var errCode = FS.nodePermissions(node, "w"); if (errCode) {
                throw new FS.ErrnoError(errCode);
            } node.node_ops.setattr(node, { size: len, timestamp: Date.now() }); }, ftruncate: function (fd, len) { var stream = FS.getStream(fd); if (!stream) {
                throw new FS.ErrnoError(8);
            } if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(28);
            } FS.truncate(stream.node, len); }, utime: function (path, atime, mtime) { var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) }); }, open: function (path, flags, mode, fd_start, fd_end) { if (path === "") {
                throw new FS.ErrnoError(44);
            } flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags; mode = typeof mode === "undefined" ? 438 : mode; if (flags & 64) {
                mode = mode & 4095 | 32768;
            }
            else {
                mode = 0;
            } var node; if (typeof path === "object") {
                node = path;
            }
            else {
                path = PATH.normalize(path);
                try {
                    var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
                    node = lookup.node;
                }
                catch (e) { }
            } var created = false; if (flags & 64) {
                if (node) {
                    if (flags & 128) {
                        throw new FS.ErrnoError(20);
                    }
                }
                else {
                    node = FS.mknod(path, mode, 0);
                    created = true;
                }
            } if (!node) {
                throw new FS.ErrnoError(44);
            } if (FS.isChrdev(node.mode)) {
                flags &= ~512;
            } if (flags & 65536 && !FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
            } if (!created) {
                var errCode = FS.mayOpen(node, flags);
                if (errCode) {
                    throw new FS.ErrnoError(errCode);
                }
            } if (flags & 512) {
                FS.truncate(node, 0);
            } flags &= ~(128 | 512 | 131072); var stream = FS.createStream({ node: node, path: FS.getPath(node), flags: flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end); if (stream.stream_ops.open) {
                stream.stream_ops.open(stream);
            } if (Module["logReadFiles"] && !(flags & 1)) {
                if (!FS.readFiles)
                    FS.readFiles = {};
                if (!(path in FS.readFiles)) {
                    FS.readFiles[path] = 1;
                    err("FS.trackingDelegate error on read file: " + path);
                }
            } try {
                if (FS.trackingDelegate["onOpenFile"]) {
                    var trackingFlags = 0;
                    if ((flags & 2097155) !== 1) {
                        trackingFlags |= FS.tracking.openFlags.READ;
                    }
                    if ((flags & 2097155) !== 0) {
                        trackingFlags |= FS.tracking.openFlags.WRITE;
                    }
                    FS.trackingDelegate["onOpenFile"](path, trackingFlags);
                }
            }
            catch (e) {
                err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
            } return stream; }, close: function (stream) { if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
            } if (stream.getdents)
                stream.getdents = null; try {
                if (stream.stream_ops.close) {
                    stream.stream_ops.close(stream);
                }
            }
            catch (e) {
                throw e;
            }
            finally {
                FS.closeStream(stream.fd);
            } stream.fd = null; }, isClosed: function (stream) { return stream.fd === null; }, llseek: function (stream, offset, whence) { if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
            } if (!stream.seekable || !stream.stream_ops.llseek) {
                throw new FS.ErrnoError(70);
            } if (whence != 0 && whence != 1 && whence != 2) {
                throw new FS.ErrnoError(28);
            } stream.position = stream.stream_ops.llseek(stream, offset, whence); stream.ungotten = []; return stream.position; }, read: function (stream, buffer, offset, length, position) { if (length < 0 || position < 0) {
                throw new FS.ErrnoError(28);
            } if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
            } if ((stream.flags & 2097155) === 1) {
                throw new FS.ErrnoError(8);
            } if (FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(31);
            } if (!stream.stream_ops.read) {
                throw new FS.ErrnoError(28);
            } var seeking = typeof position !== "undefined"; if (!seeking) {
                position = stream.position;
            }
            else if (!stream.seekable) {
                throw new FS.ErrnoError(70);
            } var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position); if (!seeking)
                stream.position += bytesRead; return bytesRead; }, write: function (stream, buffer, offset, length, position, canOwn) { if (length < 0 || position < 0) {
                throw new FS.ErrnoError(28);
            } if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
            } if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(8);
            } if (FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(31);
            } if (!stream.stream_ops.write) {
                throw new FS.ErrnoError(28);
            } if (stream.seekable && stream.flags & 1024) {
                FS.llseek(stream, 0, 2);
            } var seeking = typeof position !== "undefined"; if (!seeking) {
                position = stream.position;
            }
            else if (!stream.seekable) {
                throw new FS.ErrnoError(70);
            } var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn); if (!seeking)
                stream.position += bytesWritten; try {
                if (stream.path && FS.trackingDelegate["onWriteToFile"])
                    FS.trackingDelegate["onWriteToFile"](stream.path);
            }
            catch (e) {
                err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
            } return bytesWritten; }, allocate: function (stream, offset, length) { if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
            } if (offset < 0 || length <= 0) {
                throw new FS.ErrnoError(28);
            } if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(8);
            } if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(43);
            } if (!stream.stream_ops.allocate) {
                throw new FS.ErrnoError(138);
            } stream.stream_ops.allocate(stream, offset, length); }, mmap: function (stream, address, length, position, prot, flags) { if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
                throw new FS.ErrnoError(2);
            } if ((stream.flags & 2097155) === 1) {
                throw new FS.ErrnoError(2);
            } if (!stream.stream_ops.mmap) {
                throw new FS.ErrnoError(43);
            } return stream.stream_ops.mmap(stream, address, length, position, prot, flags); }, msync: function (stream, buffer, offset, length, mmapFlags) { if (!stream || !stream.stream_ops.msync) {
                return 0;
            } return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags); }, munmap: function (stream) { return 0; }, ioctl: function (stream, cmd, arg) { if (!stream.stream_ops.ioctl) {
                throw new FS.ErrnoError(59);
            } return stream.stream_ops.ioctl(stream, cmd, arg); }, readFile: function (path, opts) { opts = opts || {}; opts.flags = opts.flags || "r"; opts.encoding = opts.encoding || "binary"; if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
                throw new Error('Invalid encoding type "' + opts.encoding + '"');
            } var ret; var stream = FS.open(path, opts.flags); var stat = FS.stat(path); var length = stat.size; var buf = new Uint8Array(length); FS.read(stream, buf, 0, length, 0); if (opts.encoding === "utf8") {
                ret = UTF8ArrayToString(buf, 0);
            }
            else if (opts.encoding === "binary") {
                ret = buf;
            } FS.close(stream); return ret; }, writeFile: function (path, data, opts) { opts = opts || {}; opts.flags = opts.flags || "w"; var stream = FS.open(path, opts.flags, opts.mode); if (typeof data === "string") {
                var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
                var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
                FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
            }
            else if (ArrayBuffer.isView(data)) {
                FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
            }
            else {
                throw new Error("Unsupported data type");
            } FS.close(stream); }, cwd: function () { return FS.currentPath; }, chdir: function (path) { var lookup = FS.lookupPath(path, { follow: true }); if (lookup.node === null) {
                throw new FS.ErrnoError(44);
            } if (!FS.isDir(lookup.node.mode)) {
                throw new FS.ErrnoError(54);
            } var errCode = FS.nodePermissions(lookup.node, "x"); if (errCode) {
                throw new FS.ErrnoError(errCode);
            } FS.currentPath = lookup.path; }, createDefaultDirectories: function () { FS.mkdir("/tmp"); FS.mkdir("/home"); FS.mkdir("/home/web_user"); }, createDefaultDevices: function () { FS.mkdir("/dev"); FS.registerDevice(FS.makedev(1, 3), { read: function () { return 0; }, write: function (stream, buffer, offset, length, pos) { return length; } }); FS.mkdev("/dev/null", FS.makedev(1, 3)); TTY.register(FS.makedev(5, 0), TTY.default_tty_ops); TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops); FS.mkdev("/dev/tty", FS.makedev(5, 0)); FS.mkdev("/dev/tty1", FS.makedev(6, 0)); var random_device = getRandomDevice(); FS.createDevice("/dev", "random", random_device); FS.createDevice("/dev", "urandom", random_device); FS.mkdir("/dev/shm"); FS.mkdir("/dev/shm/tmp"); }, createSpecialDirectories: function () { FS.mkdir("/proc"); FS.mkdir("/proc/self"); FS.mkdir("/proc/self/fd"); FS.mount({ mount: function () { var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73); node.node_ops = { lookup: function (parent, name) { var fd = +name; var stream = FS.getStream(fd); if (!stream)
                        throw new FS.ErrnoError(8); var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function () { return stream.path; } } }; ret.parent = ret; return ret; } }; return node; } }, {}, "/proc/self/fd"); }, createStandardStreams: function () { if (Module["stdin"]) {
                FS.createDevice("/dev", "stdin", Module["stdin"]);
            }
            else {
                FS.symlink("/dev/tty", "/dev/stdin");
            } if (Module["stdout"]) {
                FS.createDevice("/dev", "stdout", null, Module["stdout"]);
            }
            else {
                FS.symlink("/dev/tty", "/dev/stdout");
            } if (Module["stderr"]) {
                FS.createDevice("/dev", "stderr", null, Module["stderr"]);
            }
            else {
                FS.symlink("/dev/tty1", "/dev/stderr");
            } var stdin = FS.open("/dev/stdin", "r"); var stdout = FS.open("/dev/stdout", "w"); var stderr = FS.open("/dev/stderr", "w"); }, ensureErrnoError: function () { if (FS.ErrnoError)
                return; FS.ErrnoError = function ErrnoError(errno, node) { this.node = node; this.setErrno = function (errno) { this.errno = errno; }; this.setErrno(errno); this.message = "FS error"; }; FS.ErrnoError.prototype = new Error; FS.ErrnoError.prototype.constructor = FS.ErrnoError; [44].forEach(function (code) { FS.genericErrors[code] = new FS.ErrnoError(code); FS.genericErrors[code].stack = "<generic error, no stack>"; }); }, staticInit: function () { FS.ensureErrnoError(); FS.nameTable = new Array(4096); FS.mount(MEMFS, {}, "/"); FS.createDefaultDirectories(); FS.createDefaultDevices(); FS.createSpecialDirectories(); FS.filesystems = { "MEMFS": MEMFS }; }, init: function (input, output, error) { FS.init.initialized = true; FS.ensureErrnoError(); Module["stdin"] = input || Module["stdin"]; Module["stdout"] = output || Module["stdout"]; Module["stderr"] = error || Module["stderr"]; FS.createStandardStreams(); }, quit: function () { FS.init.initialized = false; var fflush = Module["_fflush"]; if (fflush)
                fflush(0); for (var i = 0; i < FS.streams.length; i++) {
                var stream = FS.streams[i];
                if (!stream) {
                    continue;
                }
                FS.close(stream);
            } }, getMode: function (canRead, canWrite) { var mode = 0; if (canRead)
                mode |= 292 | 73; if (canWrite)
                mode |= 146; return mode; }, findObject: function (path, dontResolveLastLink) { var ret = FS.analyzePath(path, dontResolveLastLink); if (ret.exists) {
                return ret.object;
            }
            else {
                setErrNo(ret.error);
                return null;
            } }, analyzePath: function (path, dontResolveLastLink) { try {
                var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
                path = lookup.path;
            }
            catch (e) { } var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null }; try {
                var lookup = FS.lookupPath(path, { parent: true });
                ret.parentExists = true;
                ret.parentPath = lookup.path;
                ret.parentObject = lookup.node;
                ret.name = PATH.basename(path);
                lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
                ret.exists = true;
                ret.path = lookup.path;
                ret.object = lookup.node;
                ret.name = lookup.node.name;
                ret.isRoot = lookup.path === "/";
            }
            catch (e) {
                ret.error = e.errno;
            } return ret; }, createPath: function (parent, path, canRead, canWrite) { parent = typeof parent === "string" ? parent : FS.getPath(parent); var parts = path.split("/").reverse(); while (parts.length) {
                var part = parts.pop();
                if (!part)
                    continue;
                var current = PATH.join2(parent, part);
                try {
                    FS.mkdir(current);
                }
                catch (e) { }
                parent = current;
            } return current; }, createFile: function (parent, name, properties, canRead, canWrite) { var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name); var mode = FS.getMode(canRead, canWrite); return FS.create(path, mode); }, createDataFile: function (parent, name, data, canRead, canWrite, canOwn) { var path = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent; var mode = FS.getMode(canRead, canWrite); var node = FS.create(path, mode); if (data) {
                if (typeof data === "string") {
                    var arr = new Array(data.length);
                    for (var i = 0, len = data.length; i < len; ++i)
                        arr[i] = data.charCodeAt(i);
                    data = arr;
                }
                FS.chmod(node, mode | 146);
                var stream = FS.open(node, "w");
                FS.write(stream, data, 0, data.length, 0, canOwn);
                FS.close(stream);
                FS.chmod(node, mode);
            } return node; }, createDevice: function (parent, name, input, output) { var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name); var mode = FS.getMode(!!input, !!output); if (!FS.createDevice.major)
                FS.createDevice.major = 64; var dev = FS.makedev(FS.createDevice.major++, 0); FS.registerDevice(dev, { open: function (stream) { stream.seekable = false; }, close: function (stream) { if (output && output.buffer && output.buffer.length) {
                    output(10);
                } }, read: function (stream, buffer, offset, length, pos) { var bytesRead = 0; for (var i = 0; i < length; i++) {
                    var result;
                    try {
                        result = input();
                    }
                    catch (e) {
                        throw new FS.ErrnoError(29);
                    }
                    if (result === undefined && bytesRead === 0) {
                        throw new FS.ErrnoError(6);
                    }
                    if (result === null || result === undefined)
                        break;
                    bytesRead++;
                    buffer[offset + i] = result;
                } if (bytesRead) {
                    stream.node.timestamp = Date.now();
                } return bytesRead; }, write: function (stream, buffer, offset, length, pos) { for (var i = 0; i < length; i++) {
                    try {
                        output(buffer[offset + i]);
                    }
                    catch (e) {
                        throw new FS.ErrnoError(29);
                    }
                } if (length) {
                    stream.node.timestamp = Date.now();
                } return i; } }); return FS.mkdev(path, mode, dev); }, forceLoadFile: function (obj) { if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
                return true; var success = true; if (typeof XMLHttpRequest !== "undefined") {
                throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
            }
            else if (read_) {
                try {
                    obj.contents = intArrayFromString(read_(obj.url), true);
                    obj.usedBytes = obj.contents.length;
                }
                catch (e) {
                    success = false;
                }
            }
            else {
                throw new Error("Cannot load without read() or XMLHttpRequest.");
            } if (!success)
                setErrNo(29); return success; }, createLazyFile: function (parent, name, url, canRead, canWrite) { function LazyUint8Array() { this.lengthKnown = false; this.chunks = []; } LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) { if (idx > this.length - 1 || idx < 0) {
                return undefined;
            } var chunkOffset = idx % this.chunkSize; var chunkNum = idx / this.chunkSize | 0; return this.getter(chunkNum)[chunkOffset]; }; LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) { this.getter = getter; }; LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() { var xhr = new XMLHttpRequest; xhr.open("HEAD", url, false); xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr.status); var datalength = Number(xhr.getResponseHeader("Content-length")); var header; var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes"; var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip"; var chunkSize = 1024 * 1024; if (!hasByteServing)
                chunkSize = datalength; var doXHR = function (from, to) { if (from > to)
                throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!"); if (to > datalength - 1)
                throw new Error("only " + datalength + " bytes available! programmer error!"); var xhr = new XMLHttpRequest; xhr.open("GET", url, false); if (datalength !== chunkSize)
                xhr.setRequestHeader("Range", "bytes=" + from + "-" + to); if (typeof Uint8Array != "undefined")
                xhr.responseType = "arraybuffer"; if (xhr.overrideMimeType) {
                xhr.overrideMimeType("text/plain; charset=x-user-defined");
            } xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr.status); if (xhr.response !== undefined) {
                return new Uint8Array(xhr.response || []);
            }
            else {
                return intArrayFromString(xhr.responseText || "", true);
            } }; var lazyArray = this; lazyArray.setDataGetter(function (chunkNum) { var start = chunkNum * chunkSize; var end = (chunkNum + 1) * chunkSize - 1; end = Math.min(end, datalength - 1); if (typeof lazyArray.chunks[chunkNum] === "undefined") {
                lazyArray.chunks[chunkNum] = doXHR(start, end);
            } if (typeof lazyArray.chunks[chunkNum] === "undefined")
                throw new Error("doXHR failed!"); return lazyArray.chunks[chunkNum]; }); if (usesGzip || !datalength) {
                chunkSize = datalength = 1;
                datalength = this.getter(0).length;
                chunkSize = datalength;
                out("LazyFiles on gzip forces download of the whole file when length is accessed");
            } this._length = datalength; this._chunkSize = chunkSize; this.lengthKnown = true; }; if (typeof XMLHttpRequest !== "undefined") {
                if (!ENVIRONMENT_IS_WORKER)
                    throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
                var lazyArray = new LazyUint8Array;
                Object.defineProperties(lazyArray, { length: { get: function () { if (!this.lengthKnown) {
                            this.cacheLength();
                        } return this._length; } }, chunkSize: { get: function () { if (!this.lengthKnown) {
                            this.cacheLength();
                        } return this._chunkSize; } } });
                var properties = { isDevice: false, contents: lazyArray };
            }
            else {
                var properties = { isDevice: false, url: url };
            } var node = FS.createFile(parent, name, properties, canRead, canWrite); if (properties.contents) {
                node.contents = properties.contents;
            }
            else if (properties.url) {
                node.contents = null;
                node.url = properties.url;
            } Object.defineProperties(node, { usedBytes: { get: function () { return this.contents.length; } } }); var stream_ops = {}; var keys = Object.keys(node.stream_ops); keys.forEach(function (key) { var fn = node.stream_ops[key]; stream_ops[key] = function forceLoadLazyFile() { if (!FS.forceLoadFile(node)) {
                throw new FS.ErrnoError(29);
            } return fn.apply(null, arguments); }; }); stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) { if (!FS.forceLoadFile(node)) {
                throw new FS.ErrnoError(29);
            } var contents = stream.node.contents; if (position >= contents.length)
                return 0; var size = Math.min(contents.length - position, length); if (contents.slice) {
                for (var i = 0; i < size; i++) {
                    buffer[offset + i] = contents[position + i];
                }
            }
            else {
                for (var i = 0; i < size; i++) {
                    buffer[offset + i] = contents.get(position + i);
                }
            } return size; }; node.stream_ops = stream_ops; return node; }, createPreloadedFile: function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) { Browser.init(); var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent; var dep = getUniqueRunDependency("cp " + fullname); function processData(byteArray) { function finish(byteArray) { if (preFinish)
                preFinish(); if (!dontCreateFile) {
                FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            } if (onload)
                onload(); removeRunDependency(dep); } var handled = false; Module["preloadPlugins"].forEach(function (plugin) { if (handled)
                return; if (plugin["canHandle"](fullname)) {
                plugin["handle"](byteArray, fullname, finish, function () { if (onerror)
                    onerror(); removeRunDependency(dep); });
                handled = true;
            } }); if (!handled)
                finish(byteArray); } addRunDependency(dep); if (typeof url == "string") {
                Browser.asyncLoad(url, function (byteArray) { processData(byteArray); }, onerror);
            }
            else {
                processData(url);
            } }, indexedDB: function () { return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB; }, DB_NAME: function () { return "EM_FS_" + window.location.pathname; }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function (paths, onload, onerror) { onload = onload || function () { }; onerror = onerror || function () { }; var indexedDB = FS.indexedDB(); try {
                var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            }
            catch (e) {
                return onerror(e);
            } openRequest.onupgradeneeded = function openRequest_onupgradeneeded() { out("creating db"); var db = openRequest.result; db.createObjectStore(FS.DB_STORE_NAME); }; openRequest.onsuccess = function openRequest_onsuccess() { var db = openRequest.result; var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite"); var files = transaction.objectStore(FS.DB_STORE_NAME); var ok = 0, fail = 0, total = paths.length; function finish() { if (fail == 0)
                onload();
            else
                onerror(); } paths.forEach(function (path) { var putRequest = files.put(FS.analyzePath(path).object.contents, path); putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total)
                finish(); }; putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total)
                finish(); }; }); transaction.onerror = onerror; }; openRequest.onerror = onerror; }, loadFilesFromDB: function (paths, onload, onerror) { onload = onload || function () { }; onerror = onerror || function () { }; var indexedDB = FS.indexedDB(); try {
                var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            }
            catch (e) {
                return onerror(e);
            } openRequest.onupgradeneeded = onerror; openRequest.onsuccess = function openRequest_onsuccess() { var db = openRequest.result; try {
                var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
            }
            catch (e) {
                onerror(e);
                return;
            } var files = transaction.objectStore(FS.DB_STORE_NAME); var ok = 0, fail = 0, total = paths.length; function finish() { if (fail == 0)
                onload();
            else
                onerror(); } paths.forEach(function (path) { var getRequest = files.get(path); getRequest.onsuccess = function getRequest_onsuccess() { if (FS.analyzePath(path).exists) {
                FS.unlink(path);
            } FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true); ok++; if (ok + fail == total)
                finish(); }; getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total)
                finish(); }; }); transaction.onerror = onerror; }; openRequest.onerror = onerror; } };
        var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function (dirfd, path) { if (path[0] !== "/") {
                var dir;
                if (dirfd === -100) {
                    dir = FS.cwd();
                }
                else {
                    var dirstream = FS.getStream(dirfd);
                    if (!dirstream)
                        throw new FS.ErrnoError(8);
                    dir = dirstream.path;
                }
                path = PATH.join2(dir, path);
            } return path; }, doStat: function (func, path, buf) { try {
                var stat = func(path);
            }
            catch (e) {
                if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
                    return -54;
                }
                throw e;
            } HEAP32[buf >> 2] = stat.dev; HEAP32[buf + 4 >> 2] = 0; HEAP32[buf + 8 >> 2] = stat.ino; HEAP32[buf + 12 >> 2] = stat.mode; HEAP32[buf + 16 >> 2] = stat.nlink; HEAP32[buf + 20 >> 2] = stat.uid; HEAP32[buf + 24 >> 2] = stat.gid; HEAP32[buf + 28 >> 2] = stat.rdev; HEAP32[buf + 32 >> 2] = 0; tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1]; HEAP32[buf + 48 >> 2] = 4096; HEAP32[buf + 52 >> 2] = stat.blocks; HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0; HEAP32[buf + 60 >> 2] = 0; HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0; HEAP32[buf + 68 >> 2] = 0; HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0; HEAP32[buf + 76 >> 2] = 0; tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1]; return 0; }, doMsync: function (addr, stream, len, flags, offset) { var buffer = HEAPU8.slice(addr, addr + len); FS.msync(stream, buffer, offset, len, flags); }, doMkdir: function (path, mode) { path = PATH.normalize(path); if (path[path.length - 1] === "/")
                path = path.substr(0, path.length - 1); FS.mkdir(path, mode, 0); return 0; }, doMknod: function (path, mode, dev) { switch (mode & 61440) {
                case 32768:
                case 8192:
                case 24576:
                case 4096:
                case 49152: break;
                default: return -28;
            } FS.mknod(path, mode, dev); return 0; }, doReadlink: function (path, buf, bufsize) { if (bufsize <= 0)
                return -28; var ret = FS.readlink(path); var len = Math.min(bufsize, lengthBytesUTF8(ret)); var endChar = HEAP8[buf + len]; stringToUTF8(ret, buf, bufsize + 1); HEAP8[buf + len] = endChar; return len; }, doAccess: function (path, amode) { if (amode & ~7) {
                return -28;
            } var node; var lookup = FS.lookupPath(path, { follow: true }); node = lookup.node; if (!node) {
                return -44;
            } var perms = ""; if (amode & 4)
                perms += "r"; if (amode & 2)
                perms += "w"; if (amode & 1)
                perms += "x"; if (perms && FS.nodePermissions(node, perms)) {
                return -2;
            } return 0; }, doDup: function (path, flags, suggestFD) { var suggest = FS.getStream(suggestFD); if (suggest)
                FS.close(suggest); return FS.open(path, flags, 0, suggestFD, suggestFD).fd; }, doReadv: function (stream, iov, iovcnt, offset) { var ret = 0; for (var i = 0; i < iovcnt; i++) {
                var ptr = HEAP32[iov + i * 8 >> 2];
                var len = HEAP32[iov + (i * 8 + 4) >> 2];
                var curr = FS.read(stream, HEAP8, ptr, len, offset);
                if (curr < 0)
                    return -1;
                ret += curr;
                if (curr < len)
                    break;
            } return ret; }, doWritev: function (stream, iov, iovcnt, offset) { var ret = 0; for (var i = 0; i < iovcnt; i++) {
                var ptr = HEAP32[iov + i * 8 >> 2];
                var len = HEAP32[iov + (i * 8 + 4) >> 2];
                var curr = FS.write(stream, HEAP8, ptr, len, offset);
                if (curr < 0)
                    return -1;
                ret += curr;
            } return ret; }, varargs: undefined, get: function () { SYSCALLS.varargs += 4; var ret = HEAP32[SYSCALLS.varargs - 4 >> 2]; return ret; }, getStr: function (ptr) { var ret = UTF8ToString(ptr); return ret; }, getStreamFromFD: function (fd) { var stream = FS.getStream(fd); if (!stream)
                throw new FS.ErrnoError(8); return stream; }, get64: function (low, high) { return low; } };
        function ___sys_fcntl64(fd, cmd, varargs) { SYSCALLS.varargs = varargs; try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
                case 0: {
                    var arg = SYSCALLS.get();
                    if (arg < 0) {
                        return -28;
                    }
                    var newStream;
                    newStream = FS.open(stream.path, stream.flags, 0, arg);
                    return newStream.fd;
                }
                case 1:
                case 2: return 0;
                case 3: return stream.flags;
                case 4: {
                    var arg = SYSCALLS.get();
                    stream.flags |= arg;
                    return 0;
                }
                case 12: {
                    var arg = SYSCALLS.get();
                    var offset = 0;
                    HEAP16[arg + offset >> 1] = 2;
                    return 0;
                }
                case 13:
                case 14: return 0;
                case 16:
                case 8: return -28;
                case 9:
                    setErrNo(28);
                    return -1;
                default: {
                    return -28;
                }
            }
        }
        catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
            return -e.errno;
        } }
        function ___sys_fstat64(fd, buf) { try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            return SYSCALLS.doStat(FS.stat, stream.path, buf);
        }
        catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
            return -e.errno;
        } }
        function ___sys_ioctl(fd, op, varargs) { SYSCALLS.varargs = varargs; try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
                case 21509:
                case 21505: {
                    if (!stream.tty)
                        return -59;
                    return 0;
                }
                case 21510:
                case 21511:
                case 21512:
                case 21506:
                case 21507:
                case 21508: {
                    if (!stream.tty)
                        return -59;
                    return 0;
                }
                case 21519: {
                    if (!stream.tty)
                        return -59;
                    var argp = SYSCALLS.get();
                    HEAP32[argp >> 2] = 0;
                    return 0;
                }
                case 21520: {
                    if (!stream.tty)
                        return -59;
                    return -28;
                }
                case 21531: {
                    var argp = SYSCALLS.get();
                    return FS.ioctl(stream, op, argp);
                }
                case 21523: {
                    if (!stream.tty)
                        return -59;
                    return 0;
                }
                case 21524: {
                    if (!stream.tty)
                        return -59;
                    return 0;
                }
                default: abort("bad ioctl syscall " + op);
            }
        }
        catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
            return -e.errno;
        } }
        function ___sys_madvise1(addr, length, advice) { return 0; }
        function syscallMmap2(addr, len, prot, flags, fd, off) { off <<= 12; var ptr; var allocated = false; if ((flags & 16) !== 0 && addr % 16384 !== 0) {
            return -28;
        } if ((flags & 32) !== 0) {
            ptr = _memalign(16384, len);
            if (!ptr)
                return -48;
            _memset(ptr, 0, len);
            allocated = true;
        }
        else {
            var info = FS.getStream(fd);
            if (!info)
                return -8;
            var res = FS.mmap(info, addr, len, off, prot, flags);
            ptr = res.ptr;
            allocated = res.allocated;
        } SYSCALLS.mappings[ptr] = { malloc: ptr, len: len, allocated: allocated, fd: fd, prot: prot, flags: flags, offset: off }; return ptr; }
        function ___sys_mmap2(addr, len, prot, flags, fd, off) { try {
            return syscallMmap2(addr, len, prot, flags, fd, off);
        }
        catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
            return -e.errno;
        } }
        function syscallMunmap(addr, len) { if ((addr | 0) === -1 || len === 0) {
            return -28;
        } var info = SYSCALLS.mappings[addr]; if (!info)
            return 0; if (len === info.len) {
            var stream = FS.getStream(info.fd);
            if (info.prot & 2) {
                SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset);
            }
            FS.munmap(stream);
            SYSCALLS.mappings[addr] = null;
            if (info.allocated) {
                _free(info.malloc);
            }
        } return 0; }
        function ___sys_munmap(addr, len) { try {
            return syscallMunmap(addr, len);
        }
        catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
            return -e.errno;
        } }
        function ___sys_open(path, flags, varargs) { SYSCALLS.varargs = varargs; try {
            var pathname = SYSCALLS.getStr(path);
            var mode = SYSCALLS.get();
            var stream = FS.open(pathname, flags, mode);
            return stream.fd;
        }
        catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
            return -e.errno;
        } }
        function ___sys_stat64(path, buf) { try {
            path = SYSCALLS.getStr(path);
            return SYSCALLS.doStat(FS.stat, path, buf);
        }
        catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
            return -e.errno;
        } }
        function getShiftFromSize(size) { switch (size) {
            case 1: return 0;
            case 2: return 1;
            case 4: return 2;
            case 8: return 3;
            default: throw new TypeError("Unknown type size: " + size);
        } }
        function embind_init_charCodes() { var codes = new Array(256); for (var i = 0; i < 256; ++i) {
            codes[i] = String.fromCharCode(i);
        } embind_charCodes = codes; }
        var embind_charCodes = undefined;
        function readLatin1String(ptr) { var ret = ""; var c = ptr; while (HEAPU8[c]) {
            ret += embind_charCodes[HEAPU8[c++]];
        } return ret; }
        var awaitingDependencies = {};
        var registeredTypes = {};
        var typeDependencies = {};
        var char_0 = 48;
        var char_9 = 57;
        function makeLegalFunctionName(name) { if (undefined === name) {
            return "_unknown";
        } name = name.replace(/[^a-zA-Z0-9_]/g, "$"); var f = name.charCodeAt(0); if (f >= char_0 && f <= char_9) {
            return "_" + name;
        }
        else {
            return name;
        } }
        function createNamedFunction(name, body) { name = makeLegalFunctionName(name); return new Function("body", "return function " + name + "() {\n" + '    "use strict";' + "    return body.apply(this, arguments);\n" + "};\n")(body); }
        function extendError(baseErrorType, errorName) { var errorClass = createNamedFunction(errorName, function (message) { this.name = errorName; this.message = message; var stack = new Error(message).stack; if (stack !== undefined) {
            this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
        } }); errorClass.prototype = Object.create(baseErrorType.prototype); errorClass.prototype.constructor = errorClass; errorClass.prototype.toString = function () { if (this.message === undefined) {
            return this.name;
        }
        else {
            return this.name + ": " + this.message;
        } }; return errorClass; }
        var BindingError = undefined;
        function throwBindingError(message) { throw new BindingError(message); }
        var InternalError = undefined;
        function throwInternalError(message) { throw new InternalError(message); }
        function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) { myTypes.forEach(function (type) { typeDependencies[type] = dependentTypes; }); function onComplete(typeConverters) { var myTypeConverters = getTypeConverters(typeConverters); if (myTypeConverters.length !== myTypes.length) {
            throwInternalError("Mismatched type converter count");
        } for (var i = 0; i < myTypes.length; ++i) {
            registerType(myTypes[i], myTypeConverters[i]);
        } } var typeConverters = new Array(dependentTypes.length); var unregisteredTypes = []; var registered = 0; dependentTypes.forEach(function (dt, i) { if (registeredTypes.hasOwnProperty(dt)) {
            typeConverters[i] = registeredTypes[dt];
        }
        else {
            unregisteredTypes.push(dt);
            if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
            }
            awaitingDependencies[dt].push(function () { typeConverters[i] = registeredTypes[dt]; ++registered; if (registered === unregisteredTypes.length) {
                onComplete(typeConverters);
            } });
        } }); if (0 === unregisteredTypes.length) {
            onComplete(typeConverters);
        } }
        function registerType(rawType, registeredInstance, options) { options = options || {}; if (!("argPackAdvance" in registeredInstance)) {
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
        } var name = registeredInstance.name; if (!rawType) {
            throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
        } if (registeredTypes.hasOwnProperty(rawType)) {
            if (options.ignoreDuplicateRegistrations) {
                return;
            }
            else {
                throwBindingError("Cannot register type '" + name + "' twice");
            }
        } registeredTypes[rawType] = registeredInstance; delete typeDependencies[rawType]; if (awaitingDependencies.hasOwnProperty(rawType)) {
            var callbacks = awaitingDependencies[rawType];
            delete awaitingDependencies[rawType];
            callbacks.forEach(function (cb) { cb(); });
        } }
        function __embind_register_bool(rawType, name, size, trueValue, falseValue) { var shift = getShiftFromSize(size); name = readLatin1String(name); registerType(rawType, { name: name, "fromWireType": function (wt) { return !!wt; }, "toWireType": function (destructors, o) { return o ? trueValue : falseValue; }, "argPackAdvance": 8, "readValueFromPointer": function (pointer) { var heap; if (size === 1) {
                heap = HEAP8;
            }
            else if (size === 2) {
                heap = HEAP16;
            }
            else if (size === 4) {
                heap = HEAP32;
            }
            else {
                throw new TypeError("Unknown boolean type size: " + name);
            } return this["fromWireType"](heap[pointer >> shift]); }, destructorFunction: null }); }
        function ClassHandle_isAliasOf(other) { if (!(this instanceof ClassHandle)) {
            return false;
        } if (!(other instanceof ClassHandle)) {
            return false;
        } var leftClass = this.$$.ptrType.registeredClass; var left = this.$$.ptr; var rightClass = other.$$.ptrType.registeredClass; var right = other.$$.ptr; while (leftClass.baseClass) {
            left = leftClass.upcast(left);
            leftClass = leftClass.baseClass;
        } while (rightClass.baseClass) {
            right = rightClass.upcast(right);
            rightClass = rightClass.baseClass;
        } return leftClass === rightClass && left === right; }
        function shallowCopyInternalPointer(o) { return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType }; }
        function throwInstanceAlreadyDeleted(obj) { function getInstanceTypeName(handle) { return handle.$$.ptrType.registeredClass.name; } throwBindingError(getInstanceTypeName(obj) + " instance already deleted"); }
        var finalizationGroup = false;
        function detachFinalizer(handle) { }
        function runDestructor($$) { if ($$.smartPtr) {
            $$.smartPtrType.rawDestructor($$.smartPtr);
        }
        else {
            $$.ptrType.registeredClass.rawDestructor($$.ptr);
        } }
        function releaseClassHandle($$) { $$.count.value -= 1; var toDelete = 0 === $$.count.value; if (toDelete) {
            runDestructor($$);
        } }
        function attachFinalizer(handle) { if ("undefined" === typeof FinalizationGroup) {
            attachFinalizer = function (handle) { return handle; };
            return handle;
        } finalizationGroup = new FinalizationGroup(function (iter) { for (var result = iter.next(); !result.done; result = iter.next()) {
            var $$ = result.value;
            if (!$$.ptr) {
                console.warn("object already deleted: " + $$.ptr);
            }
            else {
                releaseClassHandle($$);
            }
        } }); attachFinalizer = function (handle) { finalizationGroup.register(handle, handle.$$, handle.$$); return handle; }; detachFinalizer = function (handle) { finalizationGroup.unregister(handle.$$); }; return attachFinalizer(handle); }
        function ClassHandle_clone() { if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
        } if (this.$$.preservePointerOnDelete) {
            this.$$.count.value += 1;
            return this;
        }
        else {
            var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
            clone.$$.count.value += 1;
            clone.$$.deleteScheduled = false;
            return clone;
        } }
        function ClassHandle_delete() { if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
        } if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
        } detachFinalizer(this); releaseClassHandle(this.$$); if (!this.$$.preservePointerOnDelete) {
            this.$$.smartPtr = undefined;
            this.$$.ptr = undefined;
        } }
        function ClassHandle_isDeleted() { return !this.$$.ptr; }
        var delayFunction = undefined;
        var deletionQueue = [];
        function flushPendingDeletes() { while (deletionQueue.length) {
            var obj = deletionQueue.pop();
            obj.$$.deleteScheduled = false;
            obj["delete"]();
        } }
        function ClassHandle_deleteLater() { if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
        } if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
        } deletionQueue.push(this); if (deletionQueue.length === 1 && delayFunction) {
            delayFunction(flushPendingDeletes);
        } this.$$.deleteScheduled = true; return this; }
        function init_ClassHandle() { ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf; ClassHandle.prototype["clone"] = ClassHandle_clone; ClassHandle.prototype["delete"] = ClassHandle_delete; ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted; ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater; }
        function ClassHandle() { }
        var registeredPointers = {};
        function ensureOverloadTable(proto, methodName, humanName) { if (undefined === proto[methodName].overloadTable) {
            var prevFunc = proto[methodName];
            proto[methodName] = function () { if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
            } return proto[methodName].overloadTable[arguments.length].apply(this, arguments); };
            proto[methodName].overloadTable = [];
            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
        } }
        function exposePublicSymbol(name, value, numArguments) { if (Module.hasOwnProperty(name)) {
            if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {
                throwBindingError("Cannot register public name '" + name + "' twice");
            }
            ensureOverloadTable(Module, name, name);
            if (Module.hasOwnProperty(numArguments)) {
                throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
            }
            Module[name].overloadTable[numArguments] = value;
        }
        else {
            Module[name] = value;
            if (undefined !== numArguments) {
                Module[name].numArguments = numArguments;
            }
        } }
        function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) { this.name = name; this.constructor = constructor; this.instancePrototype = instancePrototype; this.rawDestructor = rawDestructor; this.baseClass = baseClass; this.getActualType = getActualType; this.upcast = upcast; this.downcast = downcast; this.pureVirtualFunctions = []; }
        function upcastPointer(ptr, ptrClass, desiredClass) { while (ptrClass !== desiredClass) {
            if (!ptrClass.upcast) {
                throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
            }
            ptr = ptrClass.upcast(ptr);
            ptrClass = ptrClass.baseClass;
        } return ptr; }
        function constNoSmartPtrRawPointerToWireType(destructors, handle) { if (handle === null) {
            if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
            }
            return 0;
        } if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
        } if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
        } var handleClass = handle.$$.ptrType.registeredClass; var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass); return ptr; }
        function genericPointerToWireType(destructors, handle) { var ptr; if (handle === null) {
            if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
            }
            if (this.isSmartPointer) {
                ptr = this.rawConstructor();
                if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr);
                }
                return ptr;
            }
            else {
                return 0;
            }
        } if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
        } if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
        } if (!this.isConst && handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
        } var handleClass = handle.$$.ptrType.registeredClass; ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass); if (this.isSmartPointer) {
            if (undefined === handle.$$.smartPtr) {
                throwBindingError("Passing raw pointer to smart pointer is illegal");
            }
            switch (this.sharingPolicy) {
                case 0:
                    if (handle.$$.smartPtrType === this) {
                        ptr = handle.$$.smartPtr;
                    }
                    else {
                        throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                    }
                    break;
                case 1:
                    ptr = handle.$$.smartPtr;
                    break;
                case 2:
                    if (handle.$$.smartPtrType === this) {
                        ptr = handle.$$.smartPtr;
                    }
                    else {
                        var clonedHandle = handle["clone"]();
                        ptr = this.rawShare(ptr, __emval_register(function () { clonedHandle["delete"](); }));
                        if (destructors !== null) {
                            destructors.push(this.rawDestructor, ptr);
                        }
                    }
                    break;
                default: throwBindingError("Unsupporting sharing policy");
            }
        } return ptr; }
        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) { if (handle === null) {
            if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
            }
            return 0;
        } if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
        } if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
        } if (handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
        } var handleClass = handle.$$.ptrType.registeredClass; var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass); return ptr; }
        function simpleReadValueFromPointer(pointer) { return this["fromWireType"](HEAPU32[pointer >> 2]); }
        function RegisteredPointer_getPointee(ptr) { if (this.rawGetPointee) {
            ptr = this.rawGetPointee(ptr);
        } return ptr; }
        function RegisteredPointer_destructor(ptr) { if (this.rawDestructor) {
            this.rawDestructor(ptr);
        } }
        function RegisteredPointer_deleteObject(handle) { if (handle !== null) {
            handle["delete"]();
        } }
        function downcastPointer(ptr, ptrClass, desiredClass) { if (ptrClass === desiredClass) {
            return ptr;
        } if (undefined === desiredClass.baseClass) {
            return null;
        } var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass); if (rv === null) {
            return null;
        } return desiredClass.downcast(rv); }
        function getInheritedInstanceCount() { return Object.keys(registeredInstances).length; }
        function getLiveInheritedInstances() { var rv = []; for (var k in registeredInstances) {
            if (registeredInstances.hasOwnProperty(k)) {
                rv.push(registeredInstances[k]);
            }
        } return rv; }
        function setDelayFunction(fn) { delayFunction = fn; if (deletionQueue.length && delayFunction) {
            delayFunction(flushPendingDeletes);
        } }
        function init_embind() { Module["getInheritedInstanceCount"] = getInheritedInstanceCount; Module["getLiveInheritedInstances"] = getLiveInheritedInstances; Module["flushPendingDeletes"] = flushPendingDeletes; Module["setDelayFunction"] = setDelayFunction; }
        var registeredInstances = {};
        function getBasestPointer(class_, ptr) { if (ptr === undefined) {
            throwBindingError("ptr should not be undefined");
        } while (class_.baseClass) {
            ptr = class_.upcast(ptr);
            class_ = class_.baseClass;
        } return ptr; }
        function getInheritedInstance(class_, ptr) { ptr = getBasestPointer(class_, ptr); return registeredInstances[ptr]; }
        function makeClassHandle(prototype, record) { if (!record.ptrType || !record.ptr) {
            throwInternalError("makeClassHandle requires ptr and ptrType");
        } var hasSmartPtrType = !!record.smartPtrType; var hasSmartPtr = !!record.smartPtr; if (hasSmartPtrType !== hasSmartPtr) {
            throwInternalError("Both smartPtrType and smartPtr must be specified");
        } record.count = { value: 1 }; return attachFinalizer(Object.create(prototype, { $$: { value: record } })); }
        function RegisteredPointer_fromWireType(ptr) { var rawPointer = this.getPointee(ptr); if (!rawPointer) {
            this.destructor(ptr);
            return null;
        } var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer); if (undefined !== registeredInstance) {
            if (0 === registeredInstance.$$.count.value) {
                registeredInstance.$$.ptr = rawPointer;
                registeredInstance.$$.smartPtr = ptr;
                return registeredInstance["clone"]();
            }
            else {
                var rv = registeredInstance["clone"]();
                this.destructor(ptr);
                return rv;
            }
        } function makeDefaultHandle() { if (this.isSmartPointer) {
            return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
        }
        else {
            return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr: ptr });
        } } var actualType = this.registeredClass.getActualType(rawPointer); var registeredPointerRecord = registeredPointers[actualType]; if (!registeredPointerRecord) {
            return makeDefaultHandle.call(this);
        } var toType; if (this.isConst) {
            toType = registeredPointerRecord.constPointerType;
        }
        else {
            toType = registeredPointerRecord.pointerType;
        } var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass); if (dp === null) {
            return makeDefaultHandle.call(this);
        } if (this.isSmartPointer) {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
        }
        else {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
        } }
        function init_RegisteredPointer() { RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee; RegisteredPointer.prototype.destructor = RegisteredPointer_destructor; RegisteredPointer.prototype["argPackAdvance"] = 8; RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer; RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject; RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType; }
        function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) { this.name = name; this.registeredClass = registeredClass; this.isReference = isReference; this.isConst = isConst; this.isSmartPointer = isSmartPointer; this.pointeeType = pointeeType; this.sharingPolicy = sharingPolicy; this.rawGetPointee = rawGetPointee; this.rawConstructor = rawConstructor; this.rawShare = rawShare; this.rawDestructor = rawDestructor; if (!isSmartPointer && registeredClass.baseClass === undefined) {
            if (isConst) {
                this["toWireType"] = constNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
            }
            else {
                this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
            }
        }
        else {
            this["toWireType"] = genericPointerToWireType;
        } }
        function replacePublicSymbol(name, value, numArguments) { if (!Module.hasOwnProperty(name)) {
            throwInternalError("Replacing nonexistant public symbol");
        } if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
            Module[name].overloadTable[numArguments] = value;
        }
        else {
            Module[name] = value;
            Module[name].argCount = numArguments;
        } }
        function getDynCaller(sig, ptr) { assert(sig.indexOf("j") >= 0, "getDynCaller should only be called with i64 sigs"); var argCache = []; return function () { argCache.length = arguments.length; for (var i = 0; i < arguments.length; i++) {
            argCache[i] = arguments[i];
        } return dynCall(sig, ptr, argCache); }; }
        function embind__requireFunction(signature, rawFunction) { signature = readLatin1String(signature); function makeDynCaller() { if (signature.indexOf("j") != -1) {
            return getDynCaller(signature, rawFunction);
        } return wasmTable.get(rawFunction); } var fp = makeDynCaller(); if (typeof fp !== "function") {
            throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
        } return fp; }
        var UnboundTypeError = undefined;
        function getTypeName(type) { var ptr = ___getTypeName(type); var rv = readLatin1String(ptr); _free(ptr); return rv; }
        function throwUnboundTypeError(message, types) { var unboundTypes = []; var seen = {}; function visit(type) { if (seen[type]) {
            return;
        } if (registeredTypes[type]) {
            return;
        } if (typeDependencies[type]) {
            typeDependencies[type].forEach(visit);
            return;
        } unboundTypes.push(type); seen[type] = true; } types.forEach(visit); throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "])); }
        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) { name = readLatin1String(name); getActualType = embind__requireFunction(getActualTypeSignature, getActualType); if (upcast) {
            upcast = embind__requireFunction(upcastSignature, upcast);
        } if (downcast) {
            downcast = embind__requireFunction(downcastSignature, downcast);
        } rawDestructor = embind__requireFunction(destructorSignature, rawDestructor); var legalFunctionName = makeLegalFunctionName(name); exposePublicSymbol(legalFunctionName, function () { throwUnboundTypeError("Cannot construct " + name + " due to unbound types", [baseClassRawType]); }); whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function (base) { base = base[0]; var baseClass; var basePrototype; if (baseClassRawType) {
            baseClass = base.registeredClass;
            basePrototype = baseClass.instancePrototype;
        }
        else {
            basePrototype = ClassHandle.prototype;
        } var constructor = createNamedFunction(legalFunctionName, function () { if (Object.getPrototypeOf(this) !== instancePrototype) {
            throw new BindingError("Use 'new' to construct " + name);
        } if (undefined === registeredClass.constructor_body) {
            throw new BindingError(name + " has no accessible constructor");
        } var body = registeredClass.constructor_body[arguments.length]; if (undefined === body) {
            throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
        } return body.apply(this, arguments); }); var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } }); constructor.prototype = instancePrototype; var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast); var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false); var pointerConverter = new RegisteredPointer(name + "*", registeredClass, false, false, false); var constPointerConverter = new RegisteredPointer(name + " const*", registeredClass, false, true, false); registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter }; replacePublicSymbol(legalFunctionName, constructor); return [referenceConverter, pointerConverter, constPointerConverter]; }); }
        function heap32VectorToArray(count, firstElement) { var array = []; for (var i = 0; i < count; i++) {
            array.push(HEAP32[(firstElement >> 2) + i]);
        } return array; }
        function runDestructors(destructors) { while (destructors.length) {
            var ptr = destructors.pop();
            var del = destructors.pop();
            del(ptr);
        } }
        function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) { assert(argCount > 0); var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr); invoker = embind__requireFunction(invokerSignature, invoker); var args = [rawConstructor]; var destructors = []; whenDependentTypesAreResolved([], [rawClassType], function (classType) { classType = classType[0]; var humanName = "constructor " + classType.name; if (undefined === classType.registeredClass.constructor_body) {
            classType.registeredClass.constructor_body = [];
        } if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
            throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        } classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() { throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes); }; whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) { classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() { if (arguments.length !== argCount - 1) {
            throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
        } destructors.length = 0; args.length = argCount; for (var i = 1; i < argCount; ++i) {
            args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
        } var ptr = invoker.apply(null, args); runDestructors(destructors); return argTypes[0]["fromWireType"](ptr); }; return []; }); return []; }); }
        function new_(constructor, argumentList) { if (!(constructor instanceof Function)) {
            throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
        } var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function () { }); dummy.prototype = constructor.prototype; var obj = new dummy; var r = constructor.apply(obj, argumentList); return r instanceof Object ? r : obj; }
        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) { var argCount = argTypes.length; if (argCount < 2) {
            throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
        } var isClassMethodFunc = argTypes[1] !== null && classType !== null; var needsDestructorStack = false; for (var i = 1; i < argTypes.length; ++i) {
            if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
                needsDestructorStack = true;
                break;
            }
        } var returns = argTypes[0].name !== "void"; var argsList = ""; var argsListWired = ""; for (var i = 0; i < argCount - 2; ++i) {
            argsList += (i !== 0 ? ", " : "") + "arg" + i;
            argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
        } var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\n" + "if (arguments.length !== " + (argCount - 2) + ") {\n" + "throwBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n" + "}\n"; if (needsDestructorStack) {
            invokerFnBody += "var destructors = [];\n";
        } var dtorStack = needsDestructorStack ? "destructors" : "null"; var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"]; var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]]; if (isClassMethodFunc) {
            invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
        } for (var i = 0; i < argCount - 2; ++i) {
            invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
            args1.push("argType" + i);
            args2.push(argTypes[i + 2]);
        } if (isClassMethodFunc) {
            argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
        } invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n"; if (needsDestructorStack) {
            invokerFnBody += "runDestructors(destructors);\n";
        }
        else {
            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
                var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
                if (argTypes[i].destructorFunction !== null) {
                    invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                    args1.push(paramName + "_dtor");
                    args2.push(argTypes[i].destructorFunction);
                }
            }
        } if (returns) {
            invokerFnBody += "var ret = retType.fromWireType(rv);\n" + "return ret;\n";
        }
        else { } invokerFnBody += "}\n"; args1.push(invokerFnBody); var invokerFunction = new_(Function, args1).apply(null, args2); return invokerFunction; }
        function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) { var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr); methodName = readLatin1String(methodName); rawInvoker = embind__requireFunction(invokerSignature, rawInvoker); whenDependentTypesAreResolved([], [rawClassType], function (classType) { classType = classType[0]; var humanName = classType.name + "." + methodName; if (isPureVirtual) {
            classType.registeredClass.pureVirtualFunctions.push(methodName);
        } function unboundTypesHandler() { throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes); } var proto = classType.registeredClass.instancePrototype; var method = proto[methodName]; if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
            unboundTypesHandler.argCount = argCount - 2;
            unboundTypesHandler.className = classType.name;
            proto[methodName] = unboundTypesHandler;
        }
        else {
            ensureOverloadTable(proto, methodName, humanName);
            proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
        } whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) { var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context); if (undefined === proto[methodName].overloadTable) {
            memberFunction.argCount = argCount - 2;
            proto[methodName] = memberFunction;
        }
        else {
            proto[methodName].overloadTable[argCount - 2] = memberFunction;
        } return []; }); return []; }); }
        var emval_free_list = [];
        var emval_handle_array = [{}, { value: undefined }, { value: null }, { value: true }, { value: false }];
        function __emval_decref(handle) { if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
            emval_handle_array[handle] = undefined;
            emval_free_list.push(handle);
        } }
        function count_emval_handles() { var count = 0; for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== undefined) {
                ++count;
            }
        } return count; }
        function get_first_emval() { for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== undefined) {
                return emval_handle_array[i];
            }
        } return null; }
        function init_emval() { Module["count_emval_handles"] = count_emval_handles; Module["get_first_emval"] = get_first_emval; }
        function __emval_register(value) { switch (value) {
            case undefined: {
                return 1;
            }
            case null: {
                return 2;
            }
            case true: {
                return 3;
            }
            case false: {
                return 4;
            }
            default: {
                var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
                emval_handle_array[handle] = { refcount: 1, value: value };
                return handle;
            }
        } }
        function __embind_register_emval(rawType, name) { name = readLatin1String(name); registerType(rawType, { name: name, "fromWireType": function (handle) { var rv = emval_handle_array[handle].value; __emval_decref(handle); return rv; }, "toWireType": function (destructors, value) { return __emval_register(value); }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null }); }
        function enumReadValueFromPointer(name, shift, signed) { switch (shift) {
            case 0: return function (pointer) { var heap = signed ? HEAP8 : HEAPU8; return this["fromWireType"](heap[pointer]); };
            case 1: return function (pointer) { var heap = signed ? HEAP16 : HEAPU16; return this["fromWireType"](heap[pointer >> 1]); };
            case 2: return function (pointer) { var heap = signed ? HEAP32 : HEAPU32; return this["fromWireType"](heap[pointer >> 2]); };
            default: throw new TypeError("Unknown integer type: " + name);
        } }
        function __embind_register_enum(rawType, name, size, isSigned) { var shift = getShiftFromSize(size); name = readLatin1String(name); function ctor() { } ctor.values = {}; registerType(rawType, { name: name, constructor: ctor, "fromWireType": function (c) { return this.constructor.values[c]; }, "toWireType": function (destructors, c) { return c.value; }, "argPackAdvance": 8, "readValueFromPointer": enumReadValueFromPointer(name, shift, isSigned), destructorFunction: null }); exposePublicSymbol(name, ctor); }
        function requireRegisteredType(rawType, humanName) { var impl = registeredTypes[rawType]; if (undefined === impl) {
            throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
        } return impl; }
        function __embind_register_enum_value(rawEnumType, name, enumValue) { var enumType = requireRegisteredType(rawEnumType, "enum"); name = readLatin1String(name); var Enum = enumType.constructor; var Value = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(enumType.name + "_" + name, function () { }) } }); Enum.values[enumValue] = Value; Enum[name] = Value; }
        function _embind_repr(v) { if (v === null) {
            return "null";
        } var t = typeof v; if (t === "object" || t === "array" || t === "function") {
            return v.toString();
        }
        else {
            return "" + v;
        } }
        function floatReadValueFromPointer(name, shift) { switch (shift) {
            case 2: return function (pointer) { return this["fromWireType"](HEAPF32[pointer >> 2]); };
            case 3: return function (pointer) { return this["fromWireType"](HEAPF64[pointer >> 3]); };
            default: throw new TypeError("Unknown float type: " + name);
        } }
        function __embind_register_float(rawType, name, size) { var shift = getShiftFromSize(size); name = readLatin1String(name); registerType(rawType, { name: name, "fromWireType": function (value) { return value; }, "toWireType": function (destructors, value) { if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            } return value; }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name, shift), destructorFunction: null }); }
        function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) { var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr); name = readLatin1String(name); rawInvoker = embind__requireFunction(signature, rawInvoker); exposePublicSymbol(name, function () { throwUnboundTypeError("Cannot call " + name + " due to unbound types", argTypes); }, argCount - 1); whenDependentTypesAreResolved([], argTypes, function (argTypes) { var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1)); replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1); return []; }); }
        function integerReadValueFromPointer(name, shift, signed) { switch (shift) {
            case 0: return signed ? function readS8FromPointer(pointer) { return HEAP8[pointer]; } : function readU8FromPointer(pointer) { return HEAPU8[pointer]; };
            case 1: return signed ? function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } : function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };
            case 2: return signed ? function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } : function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };
            default: throw new TypeError("Unknown integer type: " + name);
        } }
        function __embind_register_integer(primitiveType, name, size, minRange, maxRange) { name = readLatin1String(name); if (maxRange === -1) {
            maxRange = 4294967295;
        } var shift = getShiftFromSize(size); var fromWireType = function (value) { return value; }; if (minRange === 0) {
            var bitshift = 32 - 8 * size;
            fromWireType = function (value) { return value << bitshift >>> bitshift; };
        } var isUnsignedType = name.indexOf("unsigned") != -1; registerType(primitiveType, { name: name, "fromWireType": fromWireType, "toWireType": function (destructors, value) { if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            } if (value < minRange || value > maxRange) {
                throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
            } return isUnsignedType ? value >>> 0 : value | 0; }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name, shift, minRange !== 0), destructorFunction: null }); }
        function __embind_register_memory_view(rawType, dataTypeIndex, name) { var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array]; var TA = typeMapping[dataTypeIndex]; function decodeMemoryView(handle) { handle = handle >> 2; var heap = HEAPU32; var size = heap[handle]; var data = heap[handle + 1]; return new TA(buffer, data, size); } name = readLatin1String(name); registerType(rawType, { name: name, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true }); }
        function __embind_register_std_string(rawType, name) { name = readLatin1String(name); var stdStringIsUTF8 = name === "std::string"; registerType(rawType, { name: name, "fromWireType": function (value) { var length = HEAPU32[value >> 2]; var str; if (stdStringIsUTF8) {
                var decodeStartPtr = value + 4;
                for (var i = 0; i <= length; ++i) {
                    var currentBytePtr = value + 4 + i;
                    if (i == length || HEAPU8[currentBytePtr] == 0) {
                        var maxRead = currentBytePtr - decodeStartPtr;
                        var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                        if (str === undefined) {
                            str = stringSegment;
                        }
                        else {
                            str += String.fromCharCode(0);
                            str += stringSegment;
                        }
                        decodeStartPtr = currentBytePtr + 1;
                    }
                }
            }
            else {
                var a = new Array(length);
                for (var i = 0; i < length; ++i) {
                    a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
                }
                str = a.join("");
            } _free(value); return str; }, "toWireType": function (destructors, value) { if (value instanceof ArrayBuffer) {
                value = new Uint8Array(value);
            } var getLength; var valueIsOfTypeString = typeof value === "string"; if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                throwBindingError("Cannot pass non-string to std::string");
            } if (stdStringIsUTF8 && valueIsOfTypeString) {
                getLength = function () { return lengthBytesUTF8(value); };
            }
            else {
                getLength = function () { return value.length; };
            } var length = getLength(); var ptr = _malloc(4 + length + 1); HEAPU32[ptr >> 2] = length; if (stdStringIsUTF8 && valueIsOfTypeString) {
                stringToUTF8(value, ptr + 4, length + 1);
            }
            else {
                if (valueIsOfTypeString) {
                    for (var i = 0; i < length; ++i) {
                        var charCode = value.charCodeAt(i);
                        if (charCode > 255) {
                            _free(ptr);
                            throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                        }
                        HEAPU8[ptr + 4 + i] = charCode;
                    }
                }
                else {
                    for (var i = 0; i < length; ++i) {
                        HEAPU8[ptr + 4 + i] = value[i];
                    }
                }
            } if (destructors !== null) {
                destructors.push(_free, ptr);
            } return ptr; }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function (ptr) { _free(ptr); } }); }
        function __embind_register_std_wstring(rawType, charSize, name) { name = readLatin1String(name); var decodeString, encodeString, getHeap, lengthBytesUTF, shift; if (charSize === 2) {
            decodeString = UTF16ToString;
            encodeString = stringToUTF16;
            lengthBytesUTF = lengthBytesUTF16;
            getHeap = function () { return HEAPU16; };
            shift = 1;
        }
        else if (charSize === 4) {
            decodeString = UTF32ToString;
            encodeString = stringToUTF32;
            lengthBytesUTF = lengthBytesUTF32;
            getHeap = function () { return HEAPU32; };
            shift = 2;
        } registerType(rawType, { name: name, "fromWireType": function (value) { var length = HEAPU32[value >> 2]; var HEAP = getHeap(); var str; var decodeStartPtr = value + 4; for (var i = 0; i <= length; ++i) {
                var currentBytePtr = value + 4 + i * charSize;
                if (i == length || HEAP[currentBytePtr >> shift] == 0) {
                    var maxReadBytes = currentBytePtr - decodeStartPtr;
                    var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                    if (str === undefined) {
                        str = stringSegment;
                    }
                    else {
                        str += String.fromCharCode(0);
                        str += stringSegment;
                    }
                    decodeStartPtr = currentBytePtr + charSize;
                }
            } _free(value); return str; }, "toWireType": function (destructors, value) { if (!(typeof value === "string")) {
                throwBindingError("Cannot pass non-string to C++ string type " + name);
            } var length = lengthBytesUTF(value); var ptr = _malloc(4 + length + charSize); HEAPU32[ptr >> 2] = length >> shift; encodeString(value, ptr + 4, length + charSize); if (destructors !== null) {
                destructors.push(_free, ptr);
            } return ptr; }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function (ptr) { _free(ptr); } }); }
        function __embind_register_void(rawType, name) { name = readLatin1String(name); registerType(rawType, { isVoid: true, name: name, "argPackAdvance": 0, "fromWireType": function () { return undefined; }, "toWireType": function (destructors, o) { return undefined; } }); }
        function _abort() { abort(); }
        var _emscripten_get_now;
        _emscripten_get_now = function () { return performance.now(); };
        var _emscripten_get_now_is_monotonic = true;
        function _clock_gettime(clk_id, tp) { var now; if (clk_id === 0) {
            now = Date.now();
        }
        else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
            now = _emscripten_get_now();
        }
        else {
            setErrNo(28);
            return -1;
        } HEAP32[tp >> 2] = now / 1e3 | 0; HEAP32[tp + 4 >> 2] = now % 1e3 * 1e3 * 1e3 | 0; return 0; }
        function _emscripten_memcpy_big(dest, src, num) { HEAPU8.copyWithin(dest, src, src + num); }
        function _emscripten_get_heap_size() { return HEAPU8.length; }
        function emscripten_realloc_buffer(size) { try {
            wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
        }
        catch (e) { } }
        function _emscripten_resize_heap(requestedSize) { requestedSize = requestedSize >>> 0; var oldSize = _emscripten_get_heap_size(); var maxHeapSize = 1073741824; if (requestedSize > maxHeapSize) {
            return false;
        } var minHeapSize = 16777216; for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + .2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), 65536));
            var replacement = emscripten_realloc_buffer(newSize);
            if (replacement) {
                return true;
            }
        } return false; }
        var ENV = {};
        function getExecutableName() { return thisProgram || "./this.program"; }
        function getEnvStrings() { if (!getEnvStrings.strings) {
            var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
            var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
            for (var x in ENV) {
                env[x] = ENV[x];
            }
            var strings = [];
            for (var x in env) {
                strings.push(x + "=" + env[x]);
            }
            getEnvStrings.strings = strings;
        } return getEnvStrings.strings; }
        function _environ_get(__environ, environ_buf) { var bufSize = 0; getEnvStrings().forEach(function (string, i) { var ptr = environ_buf + bufSize; HEAP32[__environ + i * 4 >> 2] = ptr; writeAsciiToMemory(string, ptr); bufSize += string.length + 1; }); return 0; }
        function _environ_sizes_get(penviron_count, penviron_buf_size) { var strings = getEnvStrings(); HEAP32[penviron_count >> 2] = strings.length; var bufSize = 0; strings.forEach(function (string) { bufSize += string.length + 1; }); HEAP32[penviron_buf_size >> 2] = bufSize; return 0; }
        function _exit(status) { exit(status); }
        function _fd_close(fd) { try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
        }
        catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
            return e.errno;
        } }
        function _fd_fdstat_get(fd, pbuf) { try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
            HEAP8[pbuf >> 0] = type;
            return 0;
        }
        catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
            return e.errno;
        } }
        function _fd_read(fd, iov, iovcnt, pnum) { try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doReadv(stream, iov, iovcnt);
            HEAP32[pnum >> 2] = num;
            return 0;
        }
        catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
            return e.errno;
        } }
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) { try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var HIGH_OFFSET = 4294967296;
            var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
            var DOUBLE_LIMIT = 9007199254740992;
            if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
                return -61;
            }
            FS.llseek(stream, offset, whence);
            tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
            if (stream.getdents && offset === 0 && whence === 0)
                stream.getdents = null;
            return 0;
        }
        catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
            return e.errno;
        } }
        function _fd_write(fd, iov, iovcnt, pnum) { try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doWritev(stream, iov, iovcnt);
            HEAP32[pnum >> 2] = num;
            return 0;
        }
        catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
            return e.errno;
        } }
        function _pthread_create() { return 6; }
        function _pthread_detach() { }
        function _pthread_join() { }
        function _setTempRet0($i) { setTempRet0($i | 0); }
        function __isLeapYear(year) { return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0); }
        function __arraySum(array, index) { var sum = 0; for (var i = 0; i <= index; sum += array[i++]) { } return sum; }
        var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function __addDays(date, days) { var newDate = new Date(date.getTime()); while (days > 0) {
            var leap = __isLeapYear(newDate.getFullYear());
            var currentMonth = newDate.getMonth();
            var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
            if (days > daysInCurrentMonth - newDate.getDate()) {
                days -= daysInCurrentMonth - newDate.getDate() + 1;
                newDate.setDate(1);
                if (currentMonth < 11) {
                    newDate.setMonth(currentMonth + 1);
                }
                else {
                    newDate.setMonth(0);
                    newDate.setFullYear(newDate.getFullYear() + 1);
                }
            }
            else {
                newDate.setDate(newDate.getDate() + days);
                return newDate;
            }
        } return newDate; }
        function _strftime(s, maxsize, format, tm) { var tm_zone = HEAP32[tm + 40 >> 2]; var date = { tm_sec: HEAP32[tm >> 2], tm_min: HEAP32[tm + 4 >> 2], tm_hour: HEAP32[tm + 8 >> 2], tm_mday: HEAP32[tm + 12 >> 2], tm_mon: HEAP32[tm + 16 >> 2], tm_year: HEAP32[tm + 20 >> 2], tm_wday: HEAP32[tm + 24 >> 2], tm_yday: HEAP32[tm + 28 >> 2], tm_isdst: HEAP32[tm + 32 >> 2], tm_gmtoff: HEAP32[tm + 36 >> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" }; var pattern = UTF8ToString(format); var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }; for (var rule in EXPANSION_RULES_1) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
        } var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]; var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]; function leadingSomething(value, digits, character) { var str = typeof value === "number" ? value.toString() : value || ""; while (str.length < digits) {
            str = character[0] + str;
        } return str; } function leadingNulls(value, digits) { return leadingSomething(value, digits, "0"); } function compareByDay(date1, date2) { function sgn(value) { return value < 0 ? -1 : value > 0 ? 1 : 0; } var compare; if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
            if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                compare = sgn(date1.getDate() - date2.getDate());
            }
        } return compare; } function getFirstWeekStartDate(janFourth) { switch (janFourth.getDay()) {
            case 0: return new Date(janFourth.getFullYear() - 1, 11, 29);
            case 1: return janFourth;
            case 2: return new Date(janFourth.getFullYear(), 0, 3);
            case 3: return new Date(janFourth.getFullYear(), 0, 2);
            case 4: return new Date(janFourth.getFullYear(), 0, 1);
            case 5: return new Date(janFourth.getFullYear() - 1, 11, 31);
            case 6: return new Date(janFourth.getFullYear() - 1, 11, 30);
        } } function getWeekBasedYear(date) { var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday); var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4); var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4); var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear); var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear); if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                return thisDate.getFullYear() + 1;
            }
            else {
                return thisDate.getFullYear();
            }
        }
        else {
            return thisDate.getFullYear() - 1;
        } } var EXPANSION_RULES_2 = { "%a": function (date) { return WEEKDAYS[date.tm_wday].substring(0, 3); }, "%A": function (date) { return WEEKDAYS[date.tm_wday]; }, "%b": function (date) { return MONTHS[date.tm_mon].substring(0, 3); }, "%B": function (date) { return MONTHS[date.tm_mon]; }, "%C": function (date) { var year = date.tm_year + 1900; return leadingNulls(year / 100 | 0, 2); }, "%d": function (date) { return leadingNulls(date.tm_mday, 2); }, "%e": function (date) { return leadingSomething(date.tm_mday, 2, " "); }, "%g": function (date) { return getWeekBasedYear(date).toString().substring(2); }, "%G": function (date) { return getWeekBasedYear(date); }, "%H": function (date) { return leadingNulls(date.tm_hour, 2); }, "%I": function (date) { var twelveHour = date.tm_hour; if (twelveHour == 0)
                twelveHour = 12;
            else if (twelveHour > 12)
                twelveHour -= 12; return leadingNulls(twelveHour, 2); }, "%j": function (date) { return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3); }, "%m": function (date) { return leadingNulls(date.tm_mon + 1, 2); }, "%M": function (date) { return leadingNulls(date.tm_min, 2); }, "%n": function () { return "\n"; }, "%p": function (date) { if (date.tm_hour >= 0 && date.tm_hour < 12) {
                return "AM";
            }
            else {
                return "PM";
            } }, "%S": function (date) { return leadingNulls(date.tm_sec, 2); }, "%t": function () { return "\t"; }, "%u": function (date) { return date.tm_wday || 7; }, "%U": function (date) { var janFirst = new Date(date.tm_year + 1900, 0, 1); var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay()); var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday); if (compareByDay(firstSunday, endDate) < 0) {
                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
                var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
                var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
                return leadingNulls(Math.ceil(days / 7), 2);
            } return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00"; }, "%V": function (date) { var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4); var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4); var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear); var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear); var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday); if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
                return "53";
            } if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
                return "01";
            } var daysDifference; if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {
                daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate();
            }
            else {
                daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate();
            } return leadingNulls(Math.ceil(daysDifference / 7), 2); }, "%w": function (date) { return date.tm_wday; }, "%W": function (date) { var janFirst = new Date(date.tm_year, 0, 1); var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1); var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday); if (compareByDay(firstMonday, endDate) < 0) {
                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
                var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
                var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
                return leadingNulls(Math.ceil(days / 7), 2);
            } return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00"; }, "%y": function (date) { return (date.tm_year + 1900).toString().substring(2); }, "%Y": function (date) { return date.tm_year + 1900; }, "%z": function (date) { var off = date.tm_gmtoff; var ahead = off >= 0; off = Math.abs(off) / 60; off = off / 60 * 100 + off % 60; return (ahead ? "+" : "-") + String("0000" + off).slice(-4); }, "%Z": function (date) { return date.tm_zone; }, "%%": function () { return "%"; } }; for (var rule in EXPANSION_RULES_2) {
            if (pattern.indexOf(rule) >= 0) {
                pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
            }
        } var bytes = intArrayFromString(pattern, false); if (bytes.length > maxsize) {
            return 0;
        } writeArrayToMemory(bytes, s); return bytes.length - 1; }
        function _strftime_l(s, maxsize, format, tm) { return _strftime(s, maxsize, format, tm); }
        var FSNode = function (parent, name, mode, rdev) { if (!parent) {
            parent = this;
        } this.parent = parent; this.mount = parent.mount; this.mounted = null; this.id = FS.nextInode++; this.name = name; this.mode = mode; this.node_ops = {}; this.stream_ops = {}; this.rdev = rdev; };
        var readMode = 292 | 73;
        var writeMode = 146;
        Object.defineProperties(FSNode.prototype, { read: { get: function () { return (this.mode & readMode) === readMode; }, set: function (val) { val ? this.mode |= readMode : this.mode &= ~readMode; } }, write: { get: function () { return (this.mode & writeMode) === writeMode; }, set: function (val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; } }, isFolder: { get: function () { return FS.isDir(this.mode); } }, isDevice: { get: function () { return FS.isChrdev(this.mode); } } });
        FS.FSNode = FSNode;
        FS.staticInit();
        embind_init_charCodes();
        BindingError = Module["BindingError"] = extendError(Error, "BindingError");
        InternalError = Module["InternalError"] = extendError(Error, "InternalError");
        init_ClassHandle();
        init_RegisteredPointer();
        init_embind();
        UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
        init_emval();
        function intArrayFromString(stringy, dontAddNull, length) { var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1; var u8array = new Array(len); var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length); if (dontAddNull)
            u8array.length = numBytesWritten; return u8array; }
        __ATINIT__.push({ func: function () { ___wasm_call_ctors(); } });
        var asmLibraryArg = { "l": ___cxa_allocate_exception, "k": ___cxa_throw, "p": ___sys_fcntl64, "M": ___sys_fstat64, "H": ___sys_ioctl, "J": ___sys_madvise1, "I": ___sys_mmap2, "K": ___sys_munmap, "q": ___sys_open, "L": ___sys_stat64, "O": __embind_register_bool, "t": __embind_register_class, "j": __embind_register_class_constructor, "b": __embind_register_class_function, "N": __embind_register_emval, "E": __embind_register_enum, "f": __embind_register_enum_value, "r": __embind_register_float, "c": __embind_register_function, "e": __embind_register_integer, "d": __embind_register_memory_view, "s": __embind_register_std_string, "n": __embind_register_std_wstring, "P": __embind_register_void, "i": _abort, "D": _clock_gettime, "w": _emscripten_memcpy_big, "x": _emscripten_resize_heap, "B": _environ_get, "C": _environ_sizes_get, "g": _exit, "m": _fd_close, "F": _fd_fdstat_get, "G": _fd_read, "u": _fd_seek, "o": _fd_write, "a": wasmMemory, "h": _pthread_create, "y": _pthread_detach, "z": _pthread_join, "v": _setTempRet0, "A": _strftime_l };
        var asm = createWasm();
        var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function () { return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["R"]).apply(null, arguments); };
        var _memset = Module["_memset"] = function () { return (_memset = Module["_memset"] = Module["asm"]["S"]).apply(null, arguments); };
        var _malloc = Module["_malloc"] = function () { return (_malloc = Module["_malloc"] = Module["asm"]["T"]).apply(null, arguments); };
        var _free = Module["_free"] = function () { return (_free = Module["_free"] = Module["asm"]["U"]).apply(null, arguments); };
        var ___getTypeName = Module["___getTypeName"] = function () { return (___getTypeName = Module["___getTypeName"] = Module["asm"]["V"]).apply(null, arguments); };
        var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function () { return (___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = Module["asm"]["W"]).apply(null, arguments); };
        var ___errno_location = Module["___errno_location"] = function () { return (___errno_location = Module["___errno_location"] = Module["asm"]["X"]).apply(null, arguments); };
        var _memalign = Module["_memalign"] = function () { return (_memalign = Module["_memalign"] = Module["asm"]["Y"]).apply(null, arguments); };
        var dynCall_viijii = Module["dynCall_viijii"] = function () { return (dynCall_viijii = Module["dynCall_viijii"] = Module["asm"]["Z"]).apply(null, arguments); };
        var dynCall_jiji = Module["dynCall_jiji"] = function () { return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["_"]).apply(null, arguments); };
        var dynCall_iiiiij = Module["dynCall_iiiiij"] = function () { return (dynCall_iiiiij = Module["dynCall_iiiiij"] = Module["asm"]["$"]).apply(null, arguments); };
        var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = function () { return (dynCall_iiiiijj = Module["dynCall_iiiiijj"] = Module["asm"]["aa"]).apply(null, arguments); };
        var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = function () { return (dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = Module["asm"]["ba"]).apply(null, arguments); };
        var calledRun;
        function ExitStatus(status) { this.name = "ExitStatus"; this.message = "Program terminated with exit(" + status + ")"; this.status = status; }
        dependenciesFulfilled = function runCaller() { if (!calledRun)
            run(); if (!calledRun)
            dependenciesFulfilled = runCaller; };
        function run(args) { args = args || arguments_; if (runDependencies > 0) {
            return;
        } preRun(); if (runDependencies > 0)
            return; function doRun() { if (calledRun)
            return; calledRun = true; Module["calledRun"] = true; if (ABORT)
            return; initRuntime(); preMain(); readyPromiseResolve(Module); if (Module["onRuntimeInitialized"])
            Module["onRuntimeInitialized"](); postRun(); } if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(function () { setTimeout(function () { Module["setStatus"](""); }, 1); doRun(); }, 1);
        }
        else {
            doRun();
        } }
        Module["run"] = run;
        function exit(status, implicit) { if (implicit && noExitRuntime && status === 0) {
            return;
        } if (noExitRuntime) { }
        else {
            EXITSTATUS = status;
            exitRuntime();
            if (Module["onExit"])
                Module["onExit"](status);
            ABORT = true;
        } quit_(status, new ExitStatus(status)); }
        if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function")
                Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
                Module["preInit"].pop()();
            }
        }
        noExitRuntime = true;
        run();
        return Module.ready;
    });
})();
exports.default = Module;

}).call(this)}).call(this,require('_process'))

},{"_process":84}]},{},[31])(31)
});
